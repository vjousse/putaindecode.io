{"head":{"layout":"Post","comments":true,"date":"2016-04-19","title":"Déploiement continu avec Travis-CI (et GitHub Pages)","tags":["ci","tests","travis-ci"],"authors":["MoOx"],"reviewers":["magsout","lionelB","Macxim"],"header":{"linearGradient":"160deg, rgba(204, 51, 51, .8), rgba(204, 51, 51, .4)","image":"https://farm8.staticflickr.com/7279/7408451314_e0c3faeaaa_z.jpg","credit":"https://www.flickr.com/photos/jurvetson/7408451314"},"description":"On va partir comme ça : on a un projet sur git et tous les commits dans la\nbranche master provoqueront une mise en production automatique…"},"body":"<p>On va partir comme ça : on a un projet sur git et tous les commits dans la\nbranche <code>master</code> provoqueront une mise en production automatique une fois les\ntests validés.</p>\n<p>Les autres commits sur les autres branches et pull/merge requests joueront juste\nles tests pour notifier l&#x27;état. Quand même.</p>\n<h2 id=\"cest-qui-travis\"><a href=\"#cest-qui-travis\" class=\"phenomic-HeadingAnchor\">#</a>C&#x27;est qui Travis?</h2>\n<p><a href=\"https://travis-ci.com/\">Travis-CI</a> est un service en ligne qui permet de tester\net déployer ses applications de manière automatisée.</p>\n<p>Ce service payant propose une solution gratuite à tous les projets open source,\nce qui est assez cool. Cette version est disponible sur\n<a href=\"https://travis-ci.org/\">travis-ci.org</a>.\nIl existe bien entendu plein d&#x27;autres services similaires, mais Travis-CI étant\ntrès répandu dans la communauté open source, on le prendra pour notre exemple.</p>\n<h2 id=\"configuration-de-travis-ci\"><a href=\"#configuration-de-travis-ci\" class=\"phenomic-HeadingAnchor\">#</a>Configuration de Travis-CI</h2>\n<p>Travis-CI fonctionne avec un fichier de configuration assez simple. Il n&#x27;y a\nqu&#x27;à voir <a href=\"https://github.com/putaindecode/putaindecode.io/blob/master/.travis.yml\">le\nnôtre</a>.</p>\n<p>Voici ci-dessous une version minimale pour faire tourner un projet node par\nexemple :</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">language:</span> node_js</code></pre>\n<p>Oui, c&#x27;est tout. Selon le language et/ou les fichiers présents,\nTravis-CI va choisir la commande de test par défaut.\nAvec node par exemple, ce sera <code>npm test</code> si un package.json est présent.\nSi un <a href=\"/fr/articles/make/\">Makefile</a> est de la partie, Travis-CI va exécuter\n<code>make test</code>.</p>\n<p>Voici un fichier plus complet avec quelques exemples et trucs bons à savoir.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">language:</span> node_js\n\n<span class=\"hljs-attr\">node_js:</span>\n<span class=\"hljs-bullet\">  -</span> <span class=\"hljs-string\">'5'</span>\n<span class=\"hljs-bullet\">  -</span> ‘<span class=\"hljs-number\">4</span>’\n\n<span class=\"hljs-comment\"># échoue dès qu'une erreur intervient</span>\n<span class=\"hljs-attr\">matrix:</span>\n<span class=\"hljs-attr\">  fast_finish:</span> <span class=\"hljs-literal\">true</span>\n\n<span class=\"hljs-comment\"># met en cache node_modules, à noter que dans ce genre d’utilisation pour des</span>\n<span class=\"hljs-comment\"># librairies open source consommées via npm, il ne faudra pas oublier</span>\n<span class=\"hljs-comment\"># npm prune utilisé ci-après, histoire de ne pas lancer des tests avec</span>\n<span class=\"hljs-comment\"># des paquets encore en cache mais non présents dans le package.json</span>\n<span class=\"hljs-attr\">cache:</span>\n<span class=\"hljs-attr\">  directories:</span>\n<span class=\"hljs-bullet\">    -</span> node_modules\n\n<span class=\"hljs-attr\">before_install:</span>\n<span class=\"hljs-bullet\">  -</span> npm prune\n\n<span class=\"hljs-comment\"># ici on peut mettre des commandes à utiliser avec le script</span>\n<span class=\"hljs-attr\">before_script:</span>\n  <span class=\"hljs-comment\"># certains runners comme karma, testem ou testling peuvent avoir</span>\n  <span class=\"hljs-comment\"># besoin d'un écran pour fonctionner, voici l'astuce :)</span>\n<span class=\"hljs-bullet\">  -</span> export DISPLAY=:<span class=\"hljs-number\">99.0</span>\n<span class=\"hljs-bullet\">  -</span> sh -e /etc/init.d/xvfb start\n\n<span class=\"hljs-comment\"># si on veut utiliser autre chose que la commande par défaut</span>\n<span class=\"hljs-attr\">script:</span> npm run test-with-coverage\n\n<span class=\"hljs-comment\"># voici un exemple de ce que l’on peut faire après les tests :</span>\n<span class=\"hljs-comment\"># on peut lancer une tâche qui va envoyer les informations de</span>\n<span class=\"hljs-comment\"># pourcentage de couverture de code à un service tiers.</span>\n<span class=\"hljs-comment\"># (eg: http://coveralls.io/, https://codecov.io/)</span>\n<span class=\"hljs-attr\">after_success:</span> <span class=\"hljs-string\">'npm run coverage'</span>\n\n<span class=\"hljs-comment\"># partie intéressante : ici on ne va déployer que les commits sur la</span>\n<span class=\"hljs-comment\"># branche master uniquement pour une version de node</span>\n<span class=\"hljs-comment\"># (car sinon on déploierait plusieurs fois…)</span>\n<span class=\"hljs-attr\">deploy:</span>\n<span class=\"hljs-attr\">  skip_cleanup:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">  provider:</span> script\n<span class=\"hljs-attr\">  script:</span> ./scripts/deploy.sh\n<span class=\"hljs-attr\">  on:</span>\n<span class=\"hljs-attr\">    branch:</span> master\n<span class=\"hljs-attr\">    node:</span> <span class=\"hljs-string\">'5'</span>\n\n<span class=\"hljs-comment\"># variables d'env</span>\n<span class=\"hljs-attr\">env:</span>\n<span class=\"hljs-attr\">  global:</span>\n<span class=\"hljs-bullet\">    -</span> NODE_ENV=production</code></pre>\n<h2 id=\"exemple-concret\"><a href=\"#exemple-concret\" class=\"phenomic-HeadingAnchor\">#</a>Exemple concret</h2>\n<p>On va prendre un petit projet simple en JavaScript qu’on va déployer sur GitHub\nPages.\nIl va donc nous falloir un token GitHub qu’on va encrypter via un utilitaire\nspécifique afin de ne pas publier cela à la vue de tous.</p>\n<h3 id=\"gnrer-un-token-github-encrypt-sur-travis-ci\"><a href=\"#gnrer-un-token-github-encrypt-sur-travis-ci\" class=\"phenomic-HeadingAnchor\">#</a>Générer un token GitHub encrypté sur Travis-CI</h3>\n<p>Le plus simple est d’utiliser l&#x27;interface GitHub pour <a href=\"https://github.com/settings/tokens/new\">ajouter un\ntoken</a>.</p>\n<h4 id=\"encryption-du-token\"><a href=\"#encryption-du-token\" class=\"phenomic-HeadingAnchor\">#</a>Encryption du token</h4>\n<p>Maintenant, nous allons encrypter ce token. Vous avez 2 possibilités :</p>\n<ul>\n<li>soit installer le paquet node <code>travis-encrypt</code></li>\n<li>soit installer la gem ruby <code>travis</code> (qui embarque la commande <code>encrypt</code>)</li>\n</ul>\n<h5 id=\"via-la-gem-ruby-travis\"><a href=\"#via-la-gem-ruby-travis\" class=\"phenomic-HeadingAnchor\">#</a>Via la gem Ruby <code>travis</code></h5>\n<pre><code class=\"hljs language-console\">$ sudo gem install travis\n$ travis encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>\n<h5 id=\"via-le-paquet-node-travis-encrypt\"><a href=\"#via-le-paquet-node-travis-encrypt\" class=\"phenomic-HeadingAnchor\">#</a>Via le paquet Node <code>travis-encrypt</code></h5>\n<pre><code class=\"hljs language-bash\">$ npm i -g travis-encrypt\n$ travis-encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>\n<p>Les 2 commandes devraient ajouter automatiquement le token encrypté dans votre\n<code>.travis.yml</code> dans la section <code>env.global</code>.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-comment\"># …</span>\n\n<span class=\"hljs-attr\">env:</span>\n<span class=\"hljs-attr\">  global:</span>\n<span class=\"hljs-bullet\">    -</span> NODE_ENV=production\n    <span class=\"hljs-comment\"># Ajouter un petit commentaire pour indiquer que c’est votre token GitHub</span>\n    <span class=\"hljs-comment\"># GITHUB_TOKEN</span>\n    <span class=\"hljs-comment\"># cela permettra, si vous avez d’autres variables encryptées et</span>\nque vous devez\n    <span class=\"hljs-comment\"># changer de token pour X raison(s), de savoir lequel supprimer</span>\n<span class=\"hljs-attr\">    - secure:</span> vqhHD....ROxGPQo= <span class=\"hljs-comment\"># VOTRE TOKEN DOIT ETRE PAR LA</span>\n\n    <span class=\"hljs-comment\"># ici vous pouvez définir en plus d'autres variables non encryptées</span>\n    <span class=\"hljs-comment\"># qui seront réutilsables par la suite</span></code></pre>\n<h3 id=\"utilisation-du-token-encrypt\"><a href=\"#utilisation-du-token-encrypt\" class=\"phenomic-HeadingAnchor\">#</a>Utilisation du token encrypté</h3>\n<h4 id=\"utilisation-dans-un-script\"><a href=\"#utilisation-dans-un-script\" class=\"phenomic-HeadingAnchor\">#</a>Utilisation dans un script</h4>\n<p>Imaginons que vous ayez un projet à deployer sur GitHub Pages (exemple : vous\ngénérez un site statique avec <a href=\"https://phenomic.io/\">Phenomic</a>, le générateur\nde site statique qu&#x27;on utilise).\nVous aller devoir générer votre projet, puis ensuite pousser le dossier généré\nsur votre branche <code>gh-pages</code>.</p>\n<h4 id=\"utiliser-la-tche-de-dploiement-seulement-si-ncessaire\"><a href=\"#utiliser-la-tche-de-dploiement-seulement-si-ncessaire\" class=\"phenomic-HeadingAnchor\">#</a>Utiliser la tâche de déploiement seulement si nécessaire</h4>\n<p>Travis-CI possède une étape qui s&#x27;exécute après le succès des tests afin de\npouvoir faire un deploiement.</p>\n<p><a href=\"https://docs.travis-ci.com/user/deployment/\">https://docs.travis-ci.com/user/deployment/</a></p>\n<p>Dans notre cas, on va choisir un provider très simple : un script bash.</p>\n<p><strong>Par défaut, ceci sera executé pour tous les commits, sur toutes les\nbranches.</strong></p>\n<p>On va donc devoir ajuster un peu le tir, car par exemple les commits sur\n<code>gh-pages</code> ne doivent rien faire (déjà pour éviter la boucle infinie).\nIl en sera de même pour les commits sur d&#x27;autres branches de travail ainsi que\nles pull/merge requests, comme on l’a vu dans le précédent exemple.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">deploy:</span>\n\n  <span class=\"hljs-comment\"># très important, on garde notre build, sans ça, nos fichiers buildés</span>\n  <span class=\"hljs-comment\"># sont supprimés.</span>\n<span class=\"hljs-attr\">  skip_cleanup:</span> <span class=\"hljs-literal\">true</span>\n\n<span class=\"hljs-attr\">  provider:</span> script\n<span class=\"hljs-attr\">  script:</span> ./scripts/deploy.sh\n\n  <span class=\"hljs-comment\"># ici on pose notre restriction</span>\n<span class=\"hljs-attr\">  on:</span>\n<span class=\"hljs-attr\">    branch:</span> master\n<span class=\"hljs-attr\">    node:</span> <span class=\"hljs-string\">'5'</span></code></pre>\n<h4 id=\"crire-notre-fameux-scriptsdeploysh\"><a href=\"#crire-notre-fameux-scriptsdeploysh\" class=\"phenomic-HeadingAnchor\">#</a>Écrire notre fameux <code>scripts/deploy.sh</code></h4>\n<p>Dans le cas d’un déploiement de dossier sur une branche <code>gh-pages</code>, on peut\nfaire de manière assez simple avec le script suivant :</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/usr/bin/env bash\n</span>\n<span class=\"hljs-comment\"># on lit GIT_DEPLOY_REPO ou si y‘a pas on tente le package.json repository field</span>\n<span class=\"hljs-comment\"># (il faut une string et pas un objet dans ce cas)</span>\nGIT_DEPLOY_REPO=${GIT_DEPLOY_REPO:-$(node <span class=\"hljs-_\">-e</span>\n<span class=\"hljs-string\">'process.stdout.write(require(\"./package.json\").repository)'</span>)}\n\n<span class=\"hljs-comment\"># on se déplace dans le dossier de build</span>\n<span class=\"hljs-built_in\">cd</span> dist &amp;&amp; \\\n<span class=\"hljs-comment\"># on repart sur un repo git vierge, pas besoin de versionner quelque chose qui</span>\n<span class=\"hljs-comment\"># se build</span>\n$(npm bin)/rimraf .git\ngit init &amp;&amp; \\\n<span class=\"hljs-comment\"># il faut quelques infos pour que git soit content</span>\ngit config user.name <span class=\"hljs-string\">\"Travis CI\"</span> &amp;&amp; \\\ngit config user.email <span class=\"hljs-string\">\"github@travis-ci.org\"</span> &amp;&amp; \\\n<span class=\"hljs-comment\"># on met tout dans git et on commit</span>\ngit add . &amp;&amp; \\\ngit commit -m <span class=\"hljs-string\">\"Deploy to GitHub Pages\"</span> &amp;&amp; \\\n<span class=\"hljs-comment\"># puis on force push sur gh-pages</span>\ngit push --force <span class=\"hljs-string\">\"<span class=\"hljs-variable\">${GIT_DEPLOY_REPO}</span>\"</span> master:gh-pages</code></pre>\n<h2 id=\"ya-plus-qu-\"><a href=\"#ya-plus-qu-\" class=\"phenomic-HeadingAnchor\">#</a>Y&#x27;a plus qu&#x27;à !</h2>\n<p>Et voilà ! On pousse un commit sur <code>master</code> et la magie devrait opérer !</p>\n<p><em>Note: pour commiter sans déclencher un build sur Travis-CI, il suffit d&#x27;ajouter\n<code>[ci skip]</code> dans votre message de commit. Pratique quand on modifie juste un\nREADME par exemple.</em></p>\n<p>Cette méthode est celle que nous utilisons pour générer et deployer notre site\nstatique. Et cela permet, par exemple, si quelqu&#x27;un corrige une typo depuis\nl&#x27;interface en ligne de GitHub, de n&#x27;avoir rien d&#x27;autre à faire que de &quot;merger&quot;\nla correction\n(et pour rappel : vous pouvez <strong>modifier</strong> n&#x27;importe quel article via le lien\nsitué plus bas).</p>\n<p>Travis exécutera nos tests, génèrera notre site si les tests sont bons et mettra\nça en production. Les mises en prod&#x27; le vendredi à 19h45 ? Même pas peur.</p>\n","rawBody":"\nOn va partir comme ça : on a un projet sur git et tous les commits dans la\nbranche `master` provoqueront une mise en production automatique une fois les\ntests validés.\n\nLes autres commits sur les autres branches et pull/merge requests joueront juste\nles tests pour notifier l'état. Quand même.\n\n## C'est qui Travis?\n\n[Travis-CI](https://travis-ci.com/) est un service en ligne qui permet de tester\net déployer ses applications de manière automatisée.\n\nCe service payant propose une solution gratuite à tous les projets open source,\nce qui est assez cool. Cette version est disponible sur\n[travis-ci.org](https://travis-ci.org/).\nIl existe bien entendu plein d'autres services similaires, mais Travis-CI étant\ntrès répandu dans la communauté open source, on le prendra pour notre exemple.\n\n## Configuration de Travis-CI\n\nTravis-CI fonctionne avec un fichier de configuration assez simple. Il n'y a\nqu'à voir [le\nnôtre](https://github.com/putaindecode/putaindecode.io/blob/master/.travis.yml).\n\nVoici ci-dessous une version minimale pour faire tourner un projet node par\nexemple :\n\n```yml\nlanguage: node_js\n```\n\nOui, c'est tout. Selon le language et/ou les fichiers présents,\nTravis-CI va choisir la commande de test par défaut.\nAvec node par exemple, ce sera `npm test` si un package.json est présent.\nSi un [Makefile](/fr/articles/make/) est de la partie, Travis-CI va exécuter\n`make test`.\n\nVoici un fichier plus complet avec quelques exemples et trucs bons à savoir.\n\n```yml\nlanguage: node_js\n\nnode_js:\n  - '5'\n  - ‘4’\n\n# échoue dès qu'une erreur intervient\nmatrix:\n  fast_finish: true\n\n# met en cache node_modules, à noter que dans ce genre d’utilisation pour des\n# librairies open source consommées via npm, il ne faudra pas oublier\n# npm prune utilisé ci-après, histoire de ne pas lancer des tests avec\n# des paquets encore en cache mais non présents dans le package.json\ncache:\n  directories:\n    - node_modules\n\nbefore_install:\n  - npm prune\n\n# ici on peut mettre des commandes à utiliser avec le script\nbefore_script:\n  # certains runners comme karma, testem ou testling peuvent avoir\n  # besoin d'un écran pour fonctionner, voici l'astuce :)\n  - export DISPLAY=:99.0\n  - sh -e /etc/init.d/xvfb start\n\n# si on veut utiliser autre chose que la commande par défaut\nscript: npm run test-with-coverage\n\n# voici un exemple de ce que l’on peut faire après les tests :\n# on peut lancer une tâche qui va envoyer les informations de\n# pourcentage de couverture de code à un service tiers.\n# (eg: http://coveralls.io/, https://codecov.io/)\nafter_success: 'npm run coverage'\n\n# partie intéressante : ici on ne va déployer que les commits sur la\n# branche master uniquement pour une version de node\n# (car sinon on déploierait plusieurs fois…)\ndeploy:\n  skip_cleanup: true\n  provider: script\n  script: ./scripts/deploy.sh\n  on:\n    branch: master\n    node: '5'\n\n# variables d'env\nenv:\n  global:\n    - NODE_ENV=production\n```\n\n## Exemple concret\n\nOn va prendre un petit projet simple en JavaScript qu’on va déployer sur GitHub\nPages.\nIl va donc nous falloir un token GitHub qu’on va encrypter via un utilitaire\nspécifique afin de ne pas publier cela à la vue de tous.\n\n### Générer un token GitHub encrypté sur Travis-CI\n\nLe plus simple est d’utiliser l'interface GitHub pour [ajouter un\ntoken](https://github.com/settings/tokens/new).\n\n#### Encryption du token\n\nMaintenant, nous allons encrypter ce token. Vous avez 2 possibilités :\n\n- soit installer le paquet node `travis-encrypt`\n- soit installer la gem ruby `travis` (qui embarque la commande `encrypt`)\n\n##### Via la gem Ruby `travis`\n\n```console\n$ sudo gem install travis\n$ travis encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}\n```\n\n##### Via le paquet Node `travis-encrypt`\n\n```bash\n$ npm i -g travis-encrypt\n$ travis-encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}\n```\n\nLes 2 commandes devraient ajouter automatiquement le token encrypté dans votre\n`.travis.yml` dans la section `env.global`.\n\n```yml\n# …\n\nenv:\n  global:\n    - NODE_ENV=production\n    # Ajouter un petit commentaire pour indiquer que c’est votre token GitHub\n    # GITHUB_TOKEN\n    # cela permettra, si vous avez d’autres variables encryptées et\nque vous devez\n    # changer de token pour X raison(s), de savoir lequel supprimer\n    - secure: vqhHD....ROxGPQo= # VOTRE TOKEN DOIT ETRE PAR LA\n\n    # ici vous pouvez définir en plus d'autres variables non encryptées\n    # qui seront réutilsables par la suite\n```\n\n### Utilisation du token encrypté\n\n#### Utilisation dans un script\n\nImaginons que vous ayez un projet à deployer sur GitHub Pages (exemple : vous\ngénérez un site statique avec [Phenomic](https://phenomic.io/), le générateur\nde site statique qu'on utilise).\nVous aller devoir générer votre projet, puis ensuite pousser le dossier généré\nsur votre branche `gh-pages`.\n\n#### Utiliser la tâche de déploiement seulement si nécessaire\n\nTravis-CI possède une étape qui s'exécute après le succès des tests afin de\npouvoir faire un deploiement.\n\nhttps://docs.travis-ci.com/user/deployment/\n\nDans notre cas, on va choisir un provider très simple : un script bash.\n\n**Par défaut, ceci sera executé pour tous les commits, sur toutes les\nbranches.**\n\nOn va donc devoir ajuster un peu le tir, car par exemple les commits sur\n`gh-pages` ne doivent rien faire (déjà pour éviter la boucle infinie).\nIl en sera de même pour les commits sur d'autres branches de travail ainsi que\nles pull/merge requests, comme on l’a vu dans le précédent exemple.\n\n```yml\ndeploy:\n\n  # très important, on garde notre build, sans ça, nos fichiers buildés\n  # sont supprimés.\n  skip_cleanup: true\n\n  provider: script\n  script: ./scripts/deploy.sh\n\n  # ici on pose notre restriction\n  on:\n    branch: master\n    node: '5'\n```\n\n#### Écrire notre fameux `scripts/deploy.sh`\n\nDans le cas d’un déploiement de dossier sur une branche `gh-pages`, on peut\nfaire de manière assez simple avec le script suivant :\n\n```sh\n#!/usr/bin/env bash\n\n# on lit GIT_DEPLOY_REPO ou si y‘a pas on tente le package.json repository field\n# (il faut une string et pas un objet dans ce cas)\nGIT_DEPLOY_REPO=${GIT_DEPLOY_REPO:-$(node -e\n'process.stdout.write(require(\"./package.json\").repository)')}\n\n# on se déplace dans le dossier de build\ncd dist && \\\n# on repart sur un repo git vierge, pas besoin de versionner quelque chose qui\n# se build\n$(npm bin)/rimraf .git\ngit init && \\\n# il faut quelques infos pour que git soit content\ngit config user.name \"Travis CI\" && \\\ngit config user.email \"github@travis-ci.org\" && \\\n# on met tout dans git et on commit\ngit add . && \\\ngit commit -m \"Deploy to GitHub Pages\" && \\\n# puis on force push sur gh-pages\ngit push --force \"${GIT_DEPLOY_REPO}\" master:gh-pages\n```\n\n## Y'a plus qu'à !\n\nEt voilà ! On pousse un commit sur `master` et la magie devrait opérer !\n\n_Note: pour commiter sans déclencher un build sur Travis-CI, il suffit d'ajouter\n`[ci skip]` dans votre message de commit. Pratique quand on modifie juste un\nREADME par exemple._\n\nCette méthode est celle que nous utilisons pour générer et deployer notre site\nstatique. Et cela permet, par exemple, si quelqu'un corrige une typo depuis\nl'interface en ligne de GitHub, de n'avoir rien d'autre à faire que de \"merger\"\nla correction\n(et pour rappel : vous pouvez **modifier** n'importe quel article via le lien\nsitué plus bas).\n\nTravis exécutera nos tests, génèrera notre site si les tests sont bons et mettra\nça en production. Les mises en prod' le vendredi à 19h45 ? Même pas peur.\n","raw":"---\ndate: \"2016-04-19\"\ntitle: Déploiement continu avec Travis-CI (et GitHub Pages)\ntags:\n  - ci\n  - tests\n  - travis-ci\nauthors:\n  - MoOx\nreviewers:\n  - magsout\n  - lionelB\n  - Macxim\nheader:\n  linearGradient: 160deg, rgba(204, 51, 51, .8), rgba(204, 51, 51, .4)\n  image: https://farm8.staticflickr.com/7279/7408451314_e0c3faeaaa_z.jpg\n  credit: https://www.flickr.com/photos/jurvetson/7408451314\n---\n\nOn va partir comme ça : on a un projet sur git et tous les commits dans la\nbranche `master` provoqueront une mise en production automatique une fois les\ntests validés.\n\nLes autres commits sur les autres branches et pull/merge requests joueront juste\nles tests pour notifier l'état. Quand même.\n\n## C'est qui Travis?\n\n[Travis-CI](https://travis-ci.com/) est un service en ligne qui permet de tester\net déployer ses applications de manière automatisée.\n\nCe service payant propose une solution gratuite à tous les projets open source,\nce qui est assez cool. Cette version est disponible sur\n[travis-ci.org](https://travis-ci.org/).\nIl existe bien entendu plein d'autres services similaires, mais Travis-CI étant\ntrès répandu dans la communauté open source, on le prendra pour notre exemple.\n\n## Configuration de Travis-CI\n\nTravis-CI fonctionne avec un fichier de configuration assez simple. Il n'y a\nqu'à voir [le\nnôtre](https://github.com/putaindecode/putaindecode.io/blob/master/.travis.yml).\n\nVoici ci-dessous une version minimale pour faire tourner un projet node par\nexemple :\n\n```yml\nlanguage: node_js\n```\n\nOui, c'est tout. Selon le language et/ou les fichiers présents,\nTravis-CI va choisir la commande de test par défaut.\nAvec node par exemple, ce sera `npm test` si un package.json est présent.\nSi un [Makefile](/fr/articles/make/) est de la partie, Travis-CI va exécuter\n`make test`.\n\nVoici un fichier plus complet avec quelques exemples et trucs bons à savoir.\n\n```yml\nlanguage: node_js\n\nnode_js:\n  - '5'\n  - ‘4’\n\n# échoue dès qu'une erreur intervient\nmatrix:\n  fast_finish: true\n\n# met en cache node_modules, à noter que dans ce genre d’utilisation pour des\n# librairies open source consommées via npm, il ne faudra pas oublier\n# npm prune utilisé ci-après, histoire de ne pas lancer des tests avec\n# des paquets encore en cache mais non présents dans le package.json\ncache:\n  directories:\n    - node_modules\n\nbefore_install:\n  - npm prune\n\n# ici on peut mettre des commandes à utiliser avec le script\nbefore_script:\n  # certains runners comme karma, testem ou testling peuvent avoir\n  # besoin d'un écran pour fonctionner, voici l'astuce :)\n  - export DISPLAY=:99.0\n  - sh -e /etc/init.d/xvfb start\n\n# si on veut utiliser autre chose que la commande par défaut\nscript: npm run test-with-coverage\n\n# voici un exemple de ce que l’on peut faire après les tests :\n# on peut lancer une tâche qui va envoyer les informations de\n# pourcentage de couverture de code à un service tiers.\n# (eg: http://coveralls.io/, https://codecov.io/)\nafter_success: 'npm run coverage'\n\n# partie intéressante : ici on ne va déployer que les commits sur la\n# branche master uniquement pour une version de node\n# (car sinon on déploierait plusieurs fois…)\ndeploy:\n  skip_cleanup: true\n  provider: script\n  script: ./scripts/deploy.sh\n  on:\n    branch: master\n    node: '5'\n\n# variables d'env\nenv:\n  global:\n    - NODE_ENV=production\n```\n\n## Exemple concret\n\nOn va prendre un petit projet simple en JavaScript qu’on va déployer sur GitHub\nPages.\nIl va donc nous falloir un token GitHub qu’on va encrypter via un utilitaire\nspécifique afin de ne pas publier cela à la vue de tous.\n\n### Générer un token GitHub encrypté sur Travis-CI\n\nLe plus simple est d’utiliser l'interface GitHub pour [ajouter un\ntoken](https://github.com/settings/tokens/new).\n\n#### Encryption du token\n\nMaintenant, nous allons encrypter ce token. Vous avez 2 possibilités :\n\n- soit installer le paquet node `travis-encrypt`\n- soit installer la gem ruby `travis` (qui embarque la commande `encrypt`)\n\n##### Via la gem Ruby `travis`\n\n```console\n$ sudo gem install travis\n$ travis encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}\n```\n\n##### Via le paquet Node `travis-encrypt`\n\n```bash\n$ npm i -g travis-encrypt\n$ travis-encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}\n```\n\nLes 2 commandes devraient ajouter automatiquement le token encrypté dans votre\n`.travis.yml` dans la section `env.global`.\n\n```yml\n# …\n\nenv:\n  global:\n    - NODE_ENV=production\n    # Ajouter un petit commentaire pour indiquer que c’est votre token GitHub\n    # GITHUB_TOKEN\n    # cela permettra, si vous avez d’autres variables encryptées et\nque vous devez\n    # changer de token pour X raison(s), de savoir lequel supprimer\n    - secure: vqhHD....ROxGPQo= # VOTRE TOKEN DOIT ETRE PAR LA\n\n    # ici vous pouvez définir en plus d'autres variables non encryptées\n    # qui seront réutilsables par la suite\n```\n\n### Utilisation du token encrypté\n\n#### Utilisation dans un script\n\nImaginons que vous ayez un projet à deployer sur GitHub Pages (exemple : vous\ngénérez un site statique avec [Phenomic](https://phenomic.io/), le générateur\nde site statique qu'on utilise).\nVous aller devoir générer votre projet, puis ensuite pousser le dossier généré\nsur votre branche `gh-pages`.\n\n#### Utiliser la tâche de déploiement seulement si nécessaire\n\nTravis-CI possède une étape qui s'exécute après le succès des tests afin de\npouvoir faire un deploiement.\n\nhttps://docs.travis-ci.com/user/deployment/\n\nDans notre cas, on va choisir un provider très simple : un script bash.\n\n**Par défaut, ceci sera executé pour tous les commits, sur toutes les\nbranches.**\n\nOn va donc devoir ajuster un peu le tir, car par exemple les commits sur\n`gh-pages` ne doivent rien faire (déjà pour éviter la boucle infinie).\nIl en sera de même pour les commits sur d'autres branches de travail ainsi que\nles pull/merge requests, comme on l’a vu dans le précédent exemple.\n\n```yml\ndeploy:\n\n  # très important, on garde notre build, sans ça, nos fichiers buildés\n  # sont supprimés.\n  skip_cleanup: true\n\n  provider: script\n  script: ./scripts/deploy.sh\n\n  # ici on pose notre restriction\n  on:\n    branch: master\n    node: '5'\n```\n\n#### Écrire notre fameux `scripts/deploy.sh`\n\nDans le cas d’un déploiement de dossier sur une branche `gh-pages`, on peut\nfaire de manière assez simple avec le script suivant :\n\n```sh\n#!/usr/bin/env bash\n\n# on lit GIT_DEPLOY_REPO ou si y‘a pas on tente le package.json repository field\n# (il faut une string et pas un objet dans ce cas)\nGIT_DEPLOY_REPO=${GIT_DEPLOY_REPO:-$(node -e\n'process.stdout.write(require(\"./package.json\").repository)')}\n\n# on se déplace dans le dossier de build\ncd dist && \\\n# on repart sur un repo git vierge, pas besoin de versionner quelque chose qui\n# se build\n$(npm bin)/rimraf .git\ngit init && \\\n# il faut quelques infos pour que git soit content\ngit config user.name \"Travis CI\" && \\\ngit config user.email \"github@travis-ci.org\" && \\\n# on met tout dans git et on commit\ngit add . && \\\ngit commit -m \"Deploy to GitHub Pages\" && \\\n# puis on force push sur gh-pages\ngit push --force \"${GIT_DEPLOY_REPO}\" master:gh-pages\n```\n\n## Y'a plus qu'à !\n\nEt voilà ! On pousse un commit sur `master` et la magie devrait opérer !\n\n_Note: pour commiter sans déclencher un build sur Travis-CI, il suffit d'ajouter\n`[ci skip]` dans votre message de commit. Pratique quand on modifie juste un\nREADME par exemple._\n\nCette méthode est celle que nous utilisons pour générer et deployer notre site\nstatique. Et cela permet, par exemple, si quelqu'un corrige une typo depuis\nl'interface en ligne de GitHub, de n'avoir rien d'autre à faire que de \"merger\"\nla correction\n(et pour rappel : vous pouvez **modifier** n'importe quel article via le lien\nsitué plus bas).\n\nTravis exécutera nos tests, génèrera notre site si les tests sont bons et mettra\nça en production. Les mises en prod' le vendredi à 19h45 ? Même pas peur.\n","__filename":"fr/articles/ci/travis-ci/index.md","__url":"/fr/articles/ci/travis-ci/","__resourceUrl":"/fr/articles/ci/travis-ci/index.html","__dataUrl":"/fr/articles/ci/travis-ci/index.html.76d13b2efe41d30f07f205429f92d056.json"}