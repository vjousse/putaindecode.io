<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[putaindecode.io]]></title><description><![CDATA[putaindecode.io]]></description><link>http://putaindecode.io</link><generator>RSS for Node</generator><lastBuildDate>Tue, 19 Apr 2016 07:46:57 GMT</lastBuildDate><atom:link href="http://putaindecode.io/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Déploiement continu avec Travis-CI (et GitHub Pages)]]></title><description><![CDATA[<p>On va partir comme ça : on a un projet sur git et tous les commits dans la
branche <code>master</code> provoqueront une mise en production automatique une fois les
tests validés.</p>
<p>Les autres commits sur les autres branches et pull/merge requests joueront juste
les tests pour notifier l&#x27;état. Quand même.</p>
<h2 id="cest-qui-travis"><a href="#cest-qui-travis" class="phenomic-HeadingAnchor">#</a>C&#x27;est qui Travis?</h2>
<p><a href="https://travis-ci.com/">Travis-CI</a> est un service en ligne qui permet de tester
et déployer ses applications de manière automatisée.</p>
<p>Ce service payant propose une solution gratuite à tous les projets open source,
ce qui est assez cool. Cette version est disponible sur
<a href="https://travis-ci.org/">travis-ci.org</a>.
Il existe bien entendu plein d&#x27;autres services similaires, mais Travis-CI étant
très répandu dans la communauté open source, on le prendra pour notre exemple.</p>
<h2 id="configuration-de-travis-ci"><a href="#configuration-de-travis-ci" class="phenomic-HeadingAnchor">#</a>Configuration de Travis-CI</h2>
<p>Travis-CI fonctionne avec un fichier de configuration assez simple. Il n&#x27;y a
qu&#x27;à voir <a href="https://github.com/putaindecode/putaindecode.io/blob/master/.travis.yml">le
nôtre</a>.</p>
<p>Voici ci-dessous une version minimale pour faire tourner un projet node par
exemple :</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">language:</span> node_js</code></pre>
<p>Oui, c&#x27;est tout. Selon le language et/ou les fichiers présents,
Travis-CI va choisir la commande de test par défaut.
Avec node par exemple, ce sera <code>npm test</code> si un package.json est présent.
Si un <a href="/fr/articles/make/">Makefile</a> est de la partie, Travis-CI va exécuter
<code>make test</code>.</p>
<p>Voici un fichier plus complet avec quelques exemples et trucs bons à savoir.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">language:</span> node_js

<span class="hljs-attr">node_js:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">'5'</span>
<span class="hljs-bullet">  -</span> ‘<span class="hljs-number">4</span>’

<span class="hljs-comment"># échoue dès qu'une erreur intervient</span>
<span class="hljs-attr">matrix:</span>
<span class="hljs-attr">  fast_finish:</span> <span class="hljs-literal">true</span>

<span class="hljs-comment"># met en cache node_modules, à noter que dans ce genre d’utilisation pour des</span>
<span class="hljs-comment"># librairies open source consommées via npm, il ne faudra pas oublier</span>
<span class="hljs-comment"># npm prune utilisé ci-après, histoire de ne pas lancer des tests avec</span>
<span class="hljs-comment"># des paquets encore en cache mais non présents dans le package.json</span>
<span class="hljs-attr">cache:</span>
<span class="hljs-attr">  directories:</span>
<span class="hljs-bullet">    -</span> node_modules

<span class="hljs-attr">before_install:</span>
<span class="hljs-bullet">  -</span> npm prune

<span class="hljs-comment"># ici on peut mettre des commandes à utiliser avec le script</span>
<span class="hljs-attr">before_script:</span>
  <span class="hljs-comment"># certains runners comme karma, testem ou testling peuvent avoir</span>
  <span class="hljs-comment"># besoin d'un écran pour fonctionner, voici l'astuce :)</span>
<span class="hljs-bullet">  -</span> export DISPLAY=:<span class="hljs-number">99.0</span>
<span class="hljs-bullet">  -</span> sh -e /etc/init.d/xvfb start

<span class="hljs-comment"># si on veut utiliser autre chose que la commande par défaut</span>
<span class="hljs-attr">script:</span> npm run test-with-coverage

<span class="hljs-comment"># voici un exemple de ce que l’on peut faire après les tests :</span>
<span class="hljs-comment"># on peut lancer une tâche qui va envoyer les informations de</span>
<span class="hljs-comment"># pourcentage de couverture de code à un service tiers.</span>
<span class="hljs-comment"># (eg: http://coveralls.io/, https://codecov.io/)</span>
<span class="hljs-attr">after_success:</span> <span class="hljs-string">'npm run coverage'</span>

<span class="hljs-comment"># partie intéressante : ici on ne va déployer que les commits sur la</span>
<span class="hljs-comment"># branche master uniquement pour une version de node</span>
<span class="hljs-comment"># (car sinon on déploierait plusieurs fois…)</span>
<span class="hljs-attr">deploy:</span>
<span class="hljs-attr">  skip_cleanup:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">  provider:</span> script
<span class="hljs-attr">  script:</span> ./scripts/deploy.sh
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    branch:</span> master
<span class="hljs-attr">    node:</span> <span class="hljs-string">'5'</span>

<span class="hljs-comment"># variables d'env</span>
<span class="hljs-attr">env:</span>
<span class="hljs-attr">  global:</span>
<span class="hljs-bullet">    -</span> NODE_ENV=production</code></pre>
<h2 id="exemple-concret"><a href="#exemple-concret" class="phenomic-HeadingAnchor">#</a>Exemple concret</h2>
<p>On va prendre un petit projet simple en JavaScript qu’on va déployer sur GitHub
Pages.
Il va donc nous falloir un token GitHub qu’on va encrypter via un utilitaire
spécifique afin de ne pas publier cela à la vue de tous.</p>
<h3 id="gnrer-un-token-github-encrypt-sur-travis-ci"><a href="#gnrer-un-token-github-encrypt-sur-travis-ci" class="phenomic-HeadingAnchor">#</a>Générer un token GitHub encrypté sur Travis-CI</h3>
<p>Le plus simple est d’utiliser l&#x27;interface GitHub pour <a href="https://github.com/settings/tokens/new">ajouter un
token</a>.</p>
<h4 id="encryption-du-token"><a href="#encryption-du-token" class="phenomic-HeadingAnchor">#</a>Encryption du token</h4>
<p>Maintenant, nous allons encrypter ce token. Vous avez 2 possibilités :</p>
<ul>
<li>soit installer le paquet node <code>travis-encrypt</code></li>
<li>soit installer la gem ruby <code>travis</code> (qui embarque la commande <code>encrypt</code>)</li>
</ul>
<h5 id="via-la-gem-ruby-travis"><a href="#via-la-gem-ruby-travis" class="phenomic-HeadingAnchor">#</a>Via la gem Ruby <code>travis</code></h5>
<pre><code class="hljs language-console">$ sudo gem install travis
$ travis encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>
<h5 id="via-le-paquet-node-travis-encrypt"><a href="#via-le-paquet-node-travis-encrypt" class="phenomic-HeadingAnchor">#</a>Via le paquet Node <code>travis-encrypt</code></h5>
<pre><code class="hljs language-bash">$ npm i -g travis-encrypt
$ travis-encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>
<p>Les 2 commandes devraient ajouter automatiquement le token encrypté dans votre
<code>.travis.yml</code> dans la section <code>env.global</code>.</p>
<pre><code class="hljs language-yml"><span class="hljs-comment"># …</span>

<span class="hljs-attr">env:</span>
<span class="hljs-attr">  global:</span>
<span class="hljs-bullet">    -</span> NODE_ENV=production
    <span class="hljs-comment"># Ajouter un petit commentaire pour indiquer que c’est votre token GitHub</span>
    <span class="hljs-comment"># GITHUB_TOKEN</span>
    <span class="hljs-comment"># cela permettra, si vous avez d’autres variables encryptées et</span>
que vous devez
    <span class="hljs-comment"># changer de token pour X raison(s), de savoir lequel supprimer</span>
<span class="hljs-attr">    - secure:</span> vqhHD....ROxGPQo= <span class="hljs-comment"># VOTRE TOKEN DOIT ETRE PAR LA</span>

    <span class="hljs-comment"># ici vous pouvez définir en plus d'autres variables non encryptées</span>
    <span class="hljs-comment"># qui seront réutilsables par la suite</span></code></pre>
<h3 id="utilisation-du-token-encrypt"><a href="#utilisation-du-token-encrypt" class="phenomic-HeadingAnchor">#</a>Utilisation du token encrypté</h3>
<h4 id="utilisation-dans-un-script"><a href="#utilisation-dans-un-script" class="phenomic-HeadingAnchor">#</a>Utilisation dans un script</h4>
<p>Imaginons que vous ayez un projet à deployer sur GitHub Pages (exemple : vous
générez un site statique avec <a href="https://phenomic.io/">Phenomic</a>, le générateur
de site statique qu&#x27;on utilise).
Vous aller devoir générer votre projet, puis ensuite pousser le dossier généré
sur votre branche <code>gh-pages</code>.</p>
<h4 id="utiliser-la-tche-de-dploiement-seulement-si-ncessaire"><a href="#utiliser-la-tche-de-dploiement-seulement-si-ncessaire" class="phenomic-HeadingAnchor">#</a>Utiliser la tâche de déploiement seulement si nécessaire</h4>
<p>Travis-CI possède une étape qui s&#x27;exécute après le succès des tests afin de
pouvoir faire un deploiement.</p>
<p><a href="https://docs.travis-ci.com/user/deployment/">https://docs.travis-ci.com/user/deployment/</a></p>
<p>Dans notre cas, on va choisir un provider très simple : un script bash.</p>
<p><strong>Par défaut, ceci sera executé pour tous les commits, sur toutes les
branches.</strong></p>
<p>On va donc devoir ajuster un peu le tir, car par exemple les commits sur
<code>gh-pages</code> ne doivent rien faire (déjà pour éviter la boucle infinie).
Il en sera de même pour les commits sur d&#x27;autres branches de travail ainsi que
les pull/merge requests, comme on l’a vu dans le précédent exemple.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">deploy:</span>

  <span class="hljs-comment"># très important, on garde notre build, sans ça, nos fichiers buildés</span>
  <span class="hljs-comment"># sont supprimés.</span>
<span class="hljs-attr">  skip_cleanup:</span> <span class="hljs-literal">true</span>

<span class="hljs-attr">  provider:</span> script
<span class="hljs-attr">  script:</span> ./scripts/deploy.sh

  <span class="hljs-comment"># ici on pose notre restriction</span>
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    branch:</span> master
<span class="hljs-attr">    node:</span> <span class="hljs-string">'5'</span></code></pre>
<h4 id="crire-notre-fameux-scriptsdeploysh"><a href="#crire-notre-fameux-scriptsdeploysh" class="phenomic-HeadingAnchor">#</a>Écrire notre fameux <code>scripts/deploy.sh</code></h4>
<p>Dans le cas d’un déploiement de dossier sur une branche <code>gh-pages</code>, on peut
faire de manière assez simple avec le script suivant :</p>
<pre><code class="hljs language-sh"><span class="hljs-meta">#!/usr/bin/env bash
</span>
<span class="hljs-comment"># on lit GIT_DEPLOY_REPO ou si y‘a pas on tente le package.json repository field</span>
<span class="hljs-comment"># (il faut une string et pas un objet dans ce cas)</span>
GIT_DEPLOY_REPO=${GIT_DEPLOY_REPO:-$(node <span class="hljs-_">-e</span>
<span class="hljs-string">'process.stdout.write(require("./package.json").repository)'</span>)}

<span class="hljs-comment"># on se déplace dans le dossier de build</span>
<span class="hljs-built_in">cd</span> dist &amp;&amp; \
<span class="hljs-comment"># on repart sur un repo git vierge, pas besoin de versionner quelque chose qui</span>
<span class="hljs-comment"># se build</span>
$(npm bin)/rimraf .git
git init &amp;&amp; \
<span class="hljs-comment"># il faut quelques infos pour que git soit content</span>
git config user.name <span class="hljs-string">"Travis CI"</span> &amp;&amp; \
git config user.email <span class="hljs-string">"github@travis-ci.org"</span> &amp;&amp; \
<span class="hljs-comment"># on met tout dans git et on commit</span>
git add . &amp;&amp; \
git commit -m <span class="hljs-string">"Deploy to GitHub Pages"</span> &amp;&amp; \
<span class="hljs-comment"># puis on force push sur gh-pages</span>
git push --force <span class="hljs-string">"<span class="hljs-variable">${GIT_DEPLOY_REPO}</span>"</span> master:gh-pages</code></pre>
<h2 id="ya-plus-qu-"><a href="#ya-plus-qu-" class="phenomic-HeadingAnchor">#</a>Y&#x27;a plus qu&#x27;à !</h2>
<p>Et voilà ! On pousse un commit sur <code>master</code> et la magie devrait opérer !</p>
<p><em>Note: pour commiter sans déclencher un build sur Travis-CI, il suffit d&#x27;ajouter
<code>[ci skip]</code> dans votre message de commit. Pratique quand on modifie juste un
README par exemple.</em></p>
<p>Cette méthode est celle que nous utilisons pour générer et deployer notre site
statique. Et cela permet, par exemple, si quelqu&#x27;un corrige une typo depuis
l&#x27;interface en ligne de GitHub, de n&#x27;avoir rien d&#x27;autre à faire que de &quot;merger&quot;
la correction
(et pour rappel : vous pouvez <strong>modifier</strong> n&#x27;importe quel article via le lien
situé plus bas).</p>
<p>Travis exécutera nos tests, génèrera notre site si les tests sont bons et mettra
ça en production. Les mises en prod&#x27; le vendredi à 19h45 ? Même pas peur.</p>
]]></description><link>http://putaindecode.io/fr/articles/ci/travis-ci/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/ci/travis-ci/</guid><pubDate>Tue, 19 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Angular 1.5 : un pas de plus vers les web-components]]></title><description><![CDATA[<p>Ce post a été écrit à la lumière du
<a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15">changelog d&#x27;Angular 1.5.0 rc1</a>.<br>
Toutes information est succeptible d&#x27;évoluer au cours des publications de
nouvelles versions du framework.</p>
<h2 id="le-petit-nouveau--component"><a href="#le-petit-nouveau--component" class="phenomic-HeadingAnchor">#</a>Le petit nouveau : <code>.component()</code></h2>
<p>Avec l&#x27;arrivée imminente de la version 2, Angular commence lentement à préparer la
transition et apporte de nombreux changements à la v1 pour tenter de
combler l&#x27;écart entre les deux et rendre les changements moins pénibles.</p>
<p>On voit donc progressivement apparaitre de nouvelles fonctionnalités comme :</p>
<ul>
<li><del>un <a href="https://angular.github.io/router/">nouveau router</a> ?</del> </li>
<li>la possibilité d&#x27;<a href="https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests">annuler une resource</a></li>
<li>les transclusions multiples</li>
<li>la compilation paresseuse des transclusions</li>
</ul>
<p>Mais le point qui nous intéresse particulièrement ici n&#x27;est autre que
le nouveau <em>helper</em> permettant la déclaration de similis
<a href="https://fr.wikipedia.org/wiki/Composants_web">composants web</a>, aka web-components.</p>
<p>Les habitués connaissaient déjà <a href="https://docs.angularjs.org/api/ng/service/$compile"><code>angular.directive()</code></a>,
un <em>helper</em> permettant la déclaration de composants réutilisables.
<code>angular.directive()</code> s&#x27;est donc enrichi au cours des années en faisant un atout
incontournable du framework de par sa flexibilité et sa simplicité.</p>
<p>Mais toutes ces possibilités de déclaration n&#x27;étaient plus vraiment en phase avec
les spécifications du W3C, <code>angular.component()</code> se présente donc un retour aux sources.</p>
<h2 id="de-directive--component"><a href="#de-directive--component" class="phenomic-HeadingAnchor">#</a>De <code>.directive()</code> à <code>.component()</code></h2>
<p>Pour comprendre à quoi on arrive, il faut savoir de quoi on est parti.
De toute évidence vous ne pourrez pas transformer toutes vos vieilles directives
en composants web, du moins, pas sans compromis.</p>
<p>Pour rappel une directive Angular est définie par un objet JavaScript pouvant comporter
les attributs suivants :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> directiveObj = {
  template          : <span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>,
  transclude        : <span class="hljs-literal">false</span>,
  restrict          : <span class="hljs-string">'EA'</span>,
  scope             : <span class="hljs-literal">false</span>,
  bindToController  : <span class="hljs-literal">false</span>,
  controller        : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ },
  controllerAs      : <span class="hljs-string">'stringIdentifier'</span>,
}</code></pre>
<h3 id="restriction--la-forme-lmentaire"><a href="#restriction--la-forme-lmentaire" class="phenomic-HeadingAnchor">#</a>Restriction à la forme élémentaire</h3>
<p>Ceux qui utilisent les directives Angular de manière régulière ne sont pas sans savoir
qu&#x27;il est possible de les instancier de 4 manières différentes dans son HTML en
modifiant l&#x27;attribut <code>restrict</code> :</p>
<ul>
<li>comme un élément avec <code>restrict : &#x27;E&#x27;</code></li>
<li>comme un attribut avec <code>restrict : &#x27;A&#x27;</code></li>
<li>comme une classe avec <code>restrict : &#x27;C&#x27;</code> (déconseillé)</li>
<li>comme un commentaire avec <code>restrict : &#x27;M&#x27;</code> (fortement déconseillé)</li>
</ul>
<p>On peut aussi autoriser l&#x27;utilisation mixe en combinant les lettres : <code>restrict : &#x27;EAC&#x27;</code></p>
<p><code>restrict</code> n&#x27;est donc plus configurable et est restreint <em>(sans mauvais jeu de mot)</em>
à la forme <code>&#x27;E&#x27;</code> en faisant un composant de façon claire.</p>
<h3 id="isolement-du-scope"><a href="#isolement-du-scope" class="phenomic-HeadingAnchor">#</a>Isolement du scope</h3>
<p>Contrairement à <code>.directive()</code>, <code>.component()</code> force l&#x27;isolement du scope,
ainsi on colle à la specification : le composant web est agnostique du contexte.</p>
<p>l&#x27;attribut <code>scope</code> est donc forcé à <code>{}</code> et n&#x27;est plus configurable.</p>
<h3 id="passage-de-paramtres-via-bindings"><a href="#passage-de-paramtres-via-bindings" class="phenomic-HeadingAnchor">#</a>Passage de paramètres via <code>bindings</code></h3>
<p>La propriété <code>scope</code> n&#x27;étant plus disponible <code>component</code>. Il faut à présent utiliser la propriété <code>bindings</code>. La syntaxe de celle-ci est équivalent à celle de la propriété <code>scope</code>. Mais les éléments passés sont automatiquement attachés à l&#x27;instance du contrôleur lié au <code>component</code>.</p>
<p>Notons, que s&#x27;il reste possible d&#x27;utiliser la syntaxe <code>=</code> (two-way data binding), celle-ci est déconseillée au profit de la syntaxe <code>&lt;</code> (one-way data binding).</p>
<h3 id="utilisation-force-de-controlleras"><a href="#utilisation-force-de-controlleras" class="phenomic-HeadingAnchor">#</a>Utilisation <em>forcée</em> de <code>controllerAs</code></h3>
<p>Déjà présenté comme une <em><a href="https://toddmotto.com/digging-into-angulars-controller-as-syntax/">best practice</a></em>,
<code>controllerAs</code> fait son chemin de manière évidente jusqu&#x27;au nouveau <em>helper</em>
<code>.component()</code> son utilisation va de pair avec celle de <code>bindings</code>.</p>
<p>L&#x27;attribut, qui prend une chaine de caractères pour valeur, est à présent facultatif.
S&#x27;il est omit le controller est automatiquement aliassé par l&#x27;objet <code>$ctrl</code>.</p>
<h2 id="exemple-de-migration"><a href="#exemple-de-migration" class="phenomic-HeadingAnchor">#</a>Exemple de migration</h2>
<p>Prenons l&#x27;exemple d&#x27;une directive simple et transformons la en composant Angular pour
mettre en évidence l&#x27;ensemble des changements :</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">hello-world</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"World"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello-world</span>&gt;</span></code></pre>
<p>La syntaxe <em>directive</em> :</p>
<pre><code class="hljs language-js">angular.directive(<span class="hljs-string">'helloWorld'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorld</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    restrict          : <span class="hljs-string">'E'</span>,
    scope             : {},
    bindToController  : {
      name : <span class="hljs-string">'@'</span>
    },
    controller        : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorldCtrl</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.logName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
      }
    },
    controllerAs      : <span class="hljs-string">'hw'</span>,
    template          : <span class="hljs-string">'&lt;div&gt;&lt;span ng-click="hw.logName()"&gt;Hello {{hw.name}}!&lt;/span&gt;&lt;/div&gt;'</span>
  }
});</code></pre>
<p>La syntaxe <em>component</em> :</p>
<pre><code class="hljs language-js">angular.component(<span class="hljs-string">'helloWorld'</span>, {
  bindings: {
    name: <span class="hljs-string">'@'</span>
  },
  controller : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorldCtrl</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.logName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
  },
  template : <span class="hljs-string">'&lt;div&gt;&lt;span ng-click="$ctrl.logName()"&gt;Hi {{$ctrl.name}}!&lt;/span&gt;&lt;/div&gt;'</span>
});</code></pre>
<p>Les changements sont légers mais permettent une lecture améliorée des attributs.
Le composant est donc une version simplifiée de la directive, plus en phase avec
la logique d&#x27;Angular 2.</p>
<p>Ce nouveau <em>helper</em> permet donc l&#x27;introduction progressive des <em>web-components</em> au
sein d&#x27;Angular en vue de leur intégration et utilisation active dans la version 2.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/angular/components/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/angular/components/</guid><pubDate>Tue, 12 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Hello Swift]]></title><description><![CDATA[<blockquote>
<p>Le <strong>Swift</strong> est un langage de programmation présenté en <strong>2014</strong> par
<strong>Apple</strong>. Il a été créé pour simplifier le développement d&#x27;applications pour
les environnements d&#x27;Apple (iOS, OS X, tvOS, watchOS), car les nouveaux
développeurs,  non habitués à <code>Objective C</code>, trouvent souvent celui-ci  trop dur
à appréhender. En 2015, Apple présente <strong>Swift 2.0</strong>, une version finalisée et
stable du langage. <strong>Swift</strong> est <strong>open-source</strong> depuis novembre 2015.</p>
</blockquote>
<h2 id="le-playground"><a href="#le-playground" class="phenomic-HeadingAnchor">#</a>Le playground</h2>
<p>Avec Swift, Apple a introduit un nouveau moyen de s&#x27;amuser avec du code : le
<strong>playground</strong>. C&#x27;est à mi-chemin entre le script <code>python</code> et le <code>main de C</code>.
Vous pouvez y écrire des <code>fonctions</code>, y définir des <code>classes</code>, mais aussi y
exécuter du code en direct. Tout ceci est vraiment pratique pour <strong>tester des
algorithmes</strong>, des animations ou plus simplement <strong>apprendre à maitriser le
langage</strong>. Les <code>playgrounds</code> servent à prototyper plus qu’à écrire de vrais
outils.</p>
<p>Grâce à un partenariat entre Apple et IBM,  vous pouvez faire du <strong>Swift sur
votre navigateur</strong> avec Bluemix. La plate-forme de cloud coding d&#x27;IBM
<a href="https://swiftlang.ng.bluemix.net">swiftlang.ng.bluemix.net</a> offre ainsi un
<strong><code>playground</code> en ligne</strong> pour apprendre et vous entrainer en <strong>Swift</strong>. Donc
plus de limitation due à l&#x27;OS pour apprendre !</p>
<p>Sur OS X vous pouvez utiliser les <code>playground</code> avec Xcode, l&#x27;IDE d&#x27;Apple. Pour
créer un  <strong><code>playground</code></strong>,  vous ouvrez Xcode et <code>File→New→Playground</code>(ou
<kbd>⌥</kbd> + <kbd>⇧</kbd> + <kbd>⌘</kbd> + <kbd>N</kbd>). Vous nommez votre
<code>playground</code> et choisissez une plate-forme pour utiliser des frameworks
spécifiques pour chaque environnement (iOS ou OS X).</p>
<p><img src="./playground.jpg" alt="Playground"></p>
<p>Enfin, Swift peut être utilisé comme langage de script, en créant un fichier
<code>.swift</code>, à exécuter dans le terminal avec <code>swift [file].swift</code>. Cette méthode
offre peu de confort, car même en ouvrant le fichier sur Xcode vous n&#x27;aurez pas
l&#x27;autocomplétion. Mais si vous êtes un mordu de <strong>Linux</strong>, sachez qu&#x27;il existe
un compilateur Swift Linux fourni par Apple sur la <a href="https://swift.org/download/#linux">page dédiée sur
swift.org</a>.</p>
<h2 id="les-variables"><a href="#les-variables" class="phenomic-HeadingAnchor">#</a>Les variables</h2>
<p>Les variables peuvent être constantes ou non. Le précompilateur d&#x27;Xcode est
assez strict avec la notion de constante. Si vous déclarez une variable non
constante mais que vous ne la modifiez nulle part, il vous proposera toujours de
la passer en constante.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Exemple de variables/constantes</span>
<span class="hljs-keyword">var</span> aVariable:<span class="hljs-type">Type</span> = something <span class="hljs-comment">// variable (mutable)</span>
<span class="hljs-keyword">let</span> aConstant:<span class="hljs-type">Type</span> = somethingElse <span class="hljs-comment">// constante</span></code></pre>
<p>Swift est un langage typé, mais le type peut être implicite lors de la
déclaration. Swift typera alors la variable automatiquement.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> explicitString:<span class="hljs-type">String</span> = <span class="hljs-string">"Mario"</span>
<span class="hljs-keyword">let</span> implicitString = <span class="hljs-string">"Luigi"</span> <span class="hljs-comment">// This is a string too</span></code></pre>
<p>Par défaut, les variables ne peuvent pas être nulles. Pour qu&#x27;une variable soit
dite <em>optionelle</em>, il faut déclarer une variable explicite en ajoutant un <code>?</code> à
son type.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Ce code ne compile pas :</span>
<span class="hljs-keyword">var</span> implicitString = <span class="hljs-string">"Luigi"</span>
name = <span class="hljs-literal">nil</span> <span class="hljs-comment">// Error : Nil cannot be assigned to type 'String'</span>

<span class="hljs-comment">// Mais celui-ci, si</span>
<span class="hljs-keyword">let</span> explicitOptionalString:<span class="hljs-type">String</span>? = <span class="hljs-string">"Mario"</span>
explicitOptionalString = <span class="hljs-literal">nil</span> <span class="hljs-comment">// Olé 💃</span></code></pre>
<h2 id="affichage"><a href="#affichage" class="phenomic-HeadingAnchor">#</a>Affichage</h2>
<p>La fonction <code>print()</code> sert à afficher une chaîne de caractères dans la console
pour un script ou une application. Pour afficher des variables dans des chaînes
de caractères, on utilise cette syntaxe <code>\(maVariable)</code>. Exemple :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> age:<span class="hljs-type">Int</span> = <span class="hljs-number">32</span>
<span class="hljs-keyword">let</span> name:<span class="hljs-type">String</span> = <span class="hljs-string">"Luigi"</span>
<span class="hljs-keyword">let</span> point:<span class="hljs-type">Float</span> = <span class="hljs-number">43.4</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> have <span class="hljs-subst">\(age)</span> and <span class="hljs-subst">\(point)</span> points"</span>)

<span class="hljs-comment">// Ou</span>
<span class="hljs-keyword">let</span> toPrint:<span class="hljs-type">String</span> = <span class="hljs-string">"<span class="hljs-subst">\(name)</span> have <span class="hljs-subst">\(age)</span> and <span class="hljs-subst">\(point)</span> points"</span>
<span class="hljs-built_in">print</span>(toPrint)</code></pre>
<h2 id="conditions--boucles"><a href="#conditions--boucles" class="phenomic-HeadingAnchor">#</a>Conditions &amp; boucles</h2>
<p>Un langage sans condition ça sert pas à grand-chose, donc voici la syntaxe :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">if</span> (a &gt; x) || (a &lt; y) { <span class="hljs-comment">// Si a est plus grand que x ou plus petit que y</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a &gt; x OR a &lt; y "</span>) <span class="hljs-comment">// j'affiche</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; z { <span class="hljs-comment">// Sinon si ...</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a &lt; z"</span>)
} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Sinon</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"y &lt;= a &lt;= x"</span>)
}</code></pre>
<p>Quelques exemples de boucles <code>while</code> et <code>for</code> :</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// While</span>
<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span> { <span class="hljs-comment">// Tant que i &lt; 10 j'affiche</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"i = <span class="hljs-subst">\(i)</span>"</span>)
    i+=<span class="hljs-number">1</span> <span class="hljs-comment">// incrémente i de 1</span>
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>...<span class="hljs-number">10</span>) { <span class="hljs-comment">// pour i de 0 à 10</span>
	<span class="hljs-built_in">print</span>(i)
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>...<span class="hljs-number">10</span>).<span class="hljs-built_in">reverse</span>() { <span class="hljs-comment">// pour i de 1 à 10 en moonwalk</span>
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.<span class="hljs-built_in">stride</span>(to: <span class="hljs-number">10</span>, by: <span class="hljs-number">2</span>) { <span class="hljs-comment">// pour i de 0 à 10 par saut de 2 (10 non compris)</span>
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-comment">// autre notation de For utilisant des Ranges</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">3</span>{
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-comment">// For-In : Pour mes éléments d'un Array</span>
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> myCollection {
    element.doSomething()
}

<span class="hljs-comment">// For-In : en enumurant la boucle</span>
<span class="hljs-keyword">for</span> (index,valeur) <span class="hljs-keyword">in</span> myCollection.<span class="hljs-built_in">enumerate</span>(){
	<span class="hljs-built_in">print</span>(<span class="hljs-string">"valeur à l'index [<span class="hljs-subst">\(index)</span>] -&gt; <span class="hljs-subst">\(valeur)</span>"</span>)
}</code></pre>
<blockquote>
<p>Depuis Swift 2.2, les notations <code>--</code> et <code>++</code> sont dépréciées, donc plus de i++ dans les boucles 😩. Ce qui explique aussi que les boucles For C-Style sont aussi dépréciées. Ex:<code>for var i = 0; i &lt; 3; i++</code>. Pour ce genre de boucle il faut utiliser la notation <code>(0...3)</code>.</p>
</blockquote>
<h2 id="fonctions"><a href="#fonctions" class="phenomic-HeadingAnchor">#</a>Fonctions</h2>
<p>Un script sans fonction c&#x27;est comme une raclette sans Saint-Nectaire. Beaucoup
de débutants le font mais une fois qu&#x27;on y a gouté, il est impossible s&#x27;en
passer !</p>
<p>Donc voici la syntaxe <del>d&#x27;un Saint-Nectaire</del>... d&#x27;une fonction :</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunctionName</span><span class="hljs-params">(myStringInput:String,myIntInput:Int)</span></span>-&gt;<span class="hljs-type">Int</span>{

    <span class="hljs-comment">// Votre code</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// Retour</span>
}</code></pre>
<p>En réalité, les fonctions sont un cas particulier d&#x27;utilisation d&#x27;une notion
introduite par Swift qu&#x27;ils appellent les <em>closures</em>. Pour les amateurs de
<em>Block</em> (Objective C, C++14) et  <strong>Lambdas</strong> (C++, Java,...), les closures
seront détaillées dans un prochain article.</p>
<h2 id="le-mot-de-la-fin"><a href="#le-mot-de-la-fin" class="phenomic-HeadingAnchor">#</a>Le mot de la fin</h2>
<p>Avec tout ça vous devriez déjà vous amuser un peu !
Pour information, les scripts Swift peuvent <strong>utiliser <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/">Foundation</a></strong>
sur Linux ou OS X , le framework de base des OS d&#x27;Apple bien connu des
développeurs OS X/iOS. Il permet le traitement des fichiers, des <code>String</code> et
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/">bien plus</a>.</p>
]]></description><link>http://putaindecode.io/fr/articles/swift/hello/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/swift/hello/</guid><pubDate>Tue, 01 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Vers les CSS modules]]></title><description><![CDATA[<blockquote>
<p>Je crois que même avant que je sache exactement ce qu&#x27;était le CSS, j&#x27;avais
déjà entendu quelqu&#x27;un me dire &quot;Je HAIS le CSS&quot;. Cette phrase était souvent dite
par un de mes amis du back-end, et souvent pour de très bonnes raisons. Cet
article n&#x27;essaiera pas de défendre ni de vous faire aimer le CSS, mais comme les
outils de développement front-end évoluent rapidement, je trouve intéressant
d&#x27;expliquer les nouvelles façons d&#x27;écrire le CSS.</p>
</blockquote>
<h2 id="retour-aux-bases"><a href="#retour-aux-bases" class="phenomic-HeadingAnchor">#</a>Retour aux bases</h2>
<p>D&#x27;abord, pour comprendre quel sont les problèmes que les nouveaux outils tentent
de résoudre, un petit rappel sur ce qu&#x27;est le CSS : <em>Cascading Style Sheets</em> ou
<em>Feuilles de style en cascade</em>.</p>
<p>Une feuille de style ? C&#x27;est facile ! C&#x27;est un bout de code qui lie des &quot;styles&quot;
à du HTML.
En cascade ? Et bien, quelques fois un élément HTML peut correspondre à
plusieurs styles, et &quot;en cascade&quot; est le groupe de règles qui permet de
déterminer lequel appliquer.</p>
<p>Voici du code CSS basique : nous voulons que nos titres h1 soient rouges.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Ici, nous lions la <strong><em>règle (ou déclaration)</em></strong> <code>color: red</code> au <strong><em>sélecteur</em></strong>
&quot;h1&quot;. Un sélecteur peut contenir plusieurs règles dans son bloc de déclarations.</p>
<blockquote>
<p>Et les dernières lueurs de bonheur s&#x27;éteignent alors que nous entrons dans
l&#x27;enfer de la cascade</p>
</blockquote>
<h2 id="le-truc-qui-cascade"><a href="#le-truc-qui-cascade" class="phenomic-HeadingAnchor">#</a>Le truc qui cascade</h2>
<p>La cascade est pour moi un désastre qui rend le CSS très compliqué à maintenir
si on ne suit pas de lignes directrices ou on n&#x27;utilise pas d&#x27;outils pour
l&#x27;écrire. Je vais vous montrer quelques exemples simples pour vous expliquer les
principaux concepts de la cascade, mais gardez en tête que la plupart des
applications web contiennent de nos jours beaucoup de code, aggravant les effets
de la cascade.</p>
<p>La nécessité d&#x27;avoir un système comme la cascade vient du fait que le CSS permet
à plusieurs règles de style de s&#x27;appliquer à un même élément, ces dernières
pouvant même venir de plusieurs origines (du site, mais aussi du navigateur ou
encore même de l&#x27;utilisateur). Il faut donc pouvoir définir dans ce cas-là
quelle est la règle qui au final sera appliquée. Pour cela, la cascade donne à
chacune un poids, calculé selon un certain nombre de critères, et applique la
règle la plus lourde. Cela peut paraitre simple au premier abord, mais les
critères de calcul de poids ne le sont pas du tout.</p>
<p>Les règles qui sont les plus légères dans la cascade ne sont pas vraiment un
problème, mais il faut les connaitre afin de s&#x27;éviter des surprises :</p>
<h3 id="les-valeurs-par-dfaut-du-navigateur"><a href="#les-valeurs-par-dfaut-du-navigateur" class="phenomic-HeadingAnchor">#</a>Les valeurs par défaut du navigateur</h3>
<p>Voici le haut de la cascade. Ce sont les règles qui font qu&#x27;un titre h1 est gros
même si on ne l&#x27;a pas spécifié.</p>
<h3 id="lhritage-des-parents"><a href="#lhritage-des-parents" class="phenomic-HeadingAnchor">#</a>L&#x27;héritage des parents</h3>
<p>Ensuite, les règles sont héritées depuis les éléments HTML parents. Si on
reprend notre élément h1, si une règle <code>color: blue</code> est définie sur l&#x27;élément
<code>body</code>, le titre va en hériter, et sera donc bleu.</p>
<p>Ceci étant dit, on entre maintenant dans un niveau plus douloureux de la
cascade.</p>
<h3 id="lordre-des-rgles"><a href="#lordre-des-rgles" class="phenomic-HeadingAnchor">#</a>L&#x27;ordre des règles</h3>
<p>La position d&#x27;une règle par rapport aux autres va influer sur son poids.
Deux règles auraient pu avoir le même poids si elles étaient à la même position
mais, au final, c&#x27;est la dernière qui sera la plus lourde et sera donc
appliquée.
<strong><em>La dernière.</em></strong>
Quand il s&#x27;agit de code assez simple, cela peut être facilement
compréhensible :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Facile, n&#x27;est-ce pas ? Le titre sera bleu ! Mais s&#x27;il y a une règle <code>color: red</code> dans un fichier CSS nommé <em>foo.css</em>, et une règle <code>color: blue</code> dans un
autre fichier nommé <em>bar.css</em>, que le fichier <em>foo.css</em> met plus de temps que le
fichier <em>bar.css</em> à charger, mais que le tag HTML référençant <em>foo.css</em> est
avant celui de <em>bar.css</em>, quelle règle est appliquée ? Eh bien, c&#x27;est plus
compliqué à savoir. <em>(indice : le temps de chargement n&#x27;est pas pris en compte)</em></p>
<h3 id="la-spcificit-des-slecteurs"><a href="#la-spcificit-des-slecteurs" class="phenomic-HeadingAnchor">#</a>La spécificité des sélecteurs</h3>
<p>Ce critère est un niveau de complexité au-dessus des autres, <a href="https://specificity.keegan.st">si bien que des
personnes en ont fait des calculettes pour le
simplifier</a>. Je ne vais pas rentrer dans les
détails, mais il faut savoir que le poids d&#x27;un sélecteur est égal à la somme des
poids de tous les sélecteurs le composant.
Et que tous les sélecteurs n&#x27;ont pas le même poids.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.title</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Ici, le premier sélecteur pèse 10 parce qu&#x27;il contient un sélecteur de classe
CSS, qui pèse lui-même 10. Le deuxième sélecteur quant à lui pèse 3, parce qu&#x27;il
contient trois sélecteurs de tag, pesant chacun 1. Et donc, comme 10 &gt; 3, le
titre h1 sera rouge !</p>
<h3 id="les-styles-inline"><a href="#les-styles-inline" class="phenomic-HeadingAnchor">#</a>Les styles inline</h3>
<p>Les règles qui sont dans l&#x27;attribut “style” d&#x27;un élément HTML sont plus lourdes
que n&#x27;importe quel sélecteur défini précédemment. Et donc voici un titre bleu :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<h3 id="importance"><a href="#importance" class="phenomic-HeadingAnchor">#</a>Importance</h3>
<p>Et enfin le dernier critère, le God Mode, le broyeur de styles, le mot-clé
<strong><em>!important.</em></strong> Quand on veut VRAIMENT que le titre soit rouge :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>Et comme toute la cascade est à propos de poids, si deux règles sont marquées
comme !important, le reste des critères est toujours pris en compte pour
calculer laquelle est la plus lourde, et donc appliquée.</p>
<p><strong>…Et on ne peut pas faire plus compliqué que ça.</strong> Maintenant, imaginez des
milliers et des milliers de sélecteurs et règles cascadant les uns sur les
autres pour définir le style d&#x27;un site, et vous comprendrez l&#x27;enfer que peut
être le CSS. Ainsi, des développeurs CSS ont imaginé différentes méthodologies
et outils pour éviter ce cauchemar !</p>
<h2 id="lvolution-des-outils"><a href="#lvolution-des-outils" class="phenomic-HeadingAnchor">#</a>L&#x27;évolution des outils</h2>
<p>Maintenant, je vais vous présenter comment ma façon d&#x27;écrire du CSS a évolué au
fil du temps. Ne vous attendez pas à une chronologie complète de tous les
outils inventés depuis la création du CSS en 1996 (j&#x27;avais 6 ans !) mais plutôt
une explication de comment je me suis débrouillé avec la cascade dans ma courte
expérience personnelle.</p>
<h3 id="pr-processeurs"><a href="#pr-processeurs" class="phenomic-HeadingAnchor">#</a>Pré-processeurs</h3>
<p>J&#x27;ai commencé à developper des applications web en 2012, en plein âge d&#x27;or <a href="/fr/articles/css/preprocesseurs/">des
pré-processeurs</a>. Ils
étaient apparus quelques années auparavant, comme le CSS lui-même n&#x27;était pas
suffisamment adapté pour construire des sites complexes. Les pré-processeurs
sont des compilateurs qui génèrent du code CSS à partir de languages légèrement
différents, comme <a href="http://sass-lang.com">Sass</a> ou <a href="http://lesscss.org">LESS</a>.
Ces nouveaux languages permettent de créer des variables par exemple, ou
d&#x27;imbriquer des sélecteurs, entre autres merveilleuses nouvelles
fonctionnalités.</p>
<p>On peut transformer ce vieux code CSS compliqué à maintenir :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#E5E5E5</span>;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<p>en cette bien <em>meilleure</em> version :</p>
<pre><code class="hljs language-scss"><span class="hljs-variable">$textColor</span>: <span class="hljs-number">#333333</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: lighten(<span class="hljs-variable">$textColor</span>, <span class="hljs-number">90%</span>);

  <span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>
  }
}</code></pre>
<p>Avec ces nouveaux outils, et pour éviter aux règles d&#x27;entrer en collision dans
la cascade, nous avons commencé à imbriquer nos sélecteurs et à répliquer toute
notre structure HTML dans le code de notre pré-processeur favori. Notre CSS se
retrouva donc avec des sélecteurs très long et lourds qui étaient associés
uniquement avec un element HTML précis, comme ce dernier :</p>
<blockquote>
<p>.searchPage .sideBar .refinements.default .category .star input</p>
</blockquote>
<p>Et ça a plutôt bien marché au début ! Mais ces sélecteurs n&#x27;étaient pas les plus
performants, et la structure du HTML étant répliquée, n&#x27;importe quel changement
dans cette dernière doit être répercuté dans les styles. Donc je suis passé à
autre chose.</p>
<h3 id="mthodologies-css"><a href="#mthodologies-css" class="phenomic-HeadingAnchor">#</a>Méthodologies CSS</h3>
<p>À ce moment, quelques nouvelles guidelines CSS ont commencé a attirer mon
attention. On pouvait les utiliser avec les pré-processeurs, et avaient pour but
d&#x27;éviter les collisions dans la cascade (tout comme l&#x27;imbrication des
sélecteurs) avec un certain nombre de règles, comme sur le nommage des
sélecteurs.</p>
<p>Ces méthodologies sont arrivées au moment ou je commençais à découper mes
développements en composants. L&#x27;imbrication des sélecteurs ne marchait pas très
bien avec ces derniers, vu que le but est de créer des bouts de code
réutilisables partout dans la web app, comme un bouton par exemple. La
méthodologie que j&#x27;utilise (toujours aujourd&#x27;hui) est appelée <a href="/fr/articles/css/bem/">BEM, pour Block
Element Modifier</a>, mais il y en a
d&#x27;autres avec le même but : chaque élément HTML de mes composants doit avoir une
classe CSS qui lui est unique. De cette façon, pas besoin d&#x27;imbrication, et pas
de collision de la cascade !</p>
<p>Et ce code de pré-processeur :</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>

  img {
    border: <span class="hljs-number">1px</span> solid black;
  }
}</code></pre>
<p>se transforme en :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor
}

<span class="hljs-selector-class">.Title-icon</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}</code></pre>
<p>Évidement, le code HTML doit être mis à jour avec les nouvelles classes, mais
les sélecteurs sont maintenant courts et compréhensibles. Et ceci, sans aucune
chance de collision de cascade.</p>
<p>Maintenant, pour pouvoir mieux expliquer un dernier outil, celui qui je pense va
résoudre tous nos problèmes, il faut que je vous montre une autre approche pour
contourner les problèmes de la cascade :</p>
<h3 id="frameworks-css"><a href="#frameworks-css" class="phenomic-HeadingAnchor">#</a>Frameworks CSS</h3>
<p>Ici, pour éviter à nos règles CSS d&#x27;entrer en collision, nous… n&#x27;en écrivons
plus !
Les frameworks CSS sont des styles déjà écrits qu&#x27;on peut utiliser avec des
classes CSS spécifiques. Il y a deux approches ici :</p>
<ul>
<li>
<p>Les frameworks de styles &quot;finaux&quot; comme <a href="http://getbootstrap.com">Bootstrap</a>.
Il suffit d&#x27;ajouter la classe <code>btn</code> sur un élément HTML et… tada ! C&#x27;est
maintenant un magnifique bouton. Certaines variables sont modifiables pour
transformer le look global du framework.</p>
</li>
<li>
<p>Les frameworks de styles &quot;utilitaires&quot; comme <a href="http://tachyons.io">Tachyons</a>.
Ici, il n&#x27;y a pas de styles pré-définis, mais plein de classes utilitaires
sont disponibles, comme <code>pam</code> pour donner un <em>medium padding</em> à un élément,
ou encore <code>ba</code> pour lui donner une <em>border all</em> tout autour.</p>
</li>
</ul>
<p>Les frameworks utilitaires sont assez intéressants, du fait que le fichier CSS
final fera autour de 10kB et jamais plus, même si le site grandit ! Mais il y
aura beaucoup de classes peu compréhensibles dans le code HTML. C&#x27;est comparable
aux styles inline, avec une optimization de poids final, comme <code>ba</code> est plus
court que <em>“border-style: solid; border-width: 1px;”</em></p>
<p>Ces frameworks nous évitent tout tracas avec la cascade ! Mais je n&#x27;aimais pas
le fait d&#x27;utiliser un framework, ainsi qu&#x27;avoir beaucoup de classes non
compréhensibles dans mon code HTML. Cependant, la totale réutilisabilité et
modularité des styles, sans problèmes de cascade, sont impressionnants.</p>
<p>Cela nous amène donc à cet outil génial, forgé directement avec la meilleure
magie JavaScript :</p>
<h3 id="css-modules"><a href="#css-modules" class="phenomic-HeadingAnchor">#</a>CSS Modules</h3>
<p>Ce concept a d&#x27;abord pris forme suite à une simple observation : de nos jours,
le CSS est compilé à partir d&#x27;autres languages pour permettre une écriture plus
facile, et pour cette même raison le HTML est aussi généré grâce à des outils de
templating en JavaScript. Mais les sélecteurs CSS, le lien entre les éléments et
les styles, ceux-la même auxquels le codeur doit faire très attention pour
éviter qu&#x27;ils n&#x27;entrent en collision, n&#x27;ont pas d&#x27;outils du tout.</p>
<p>Et <a href="https://github.com/css-modules/css-modules">CSS Modules</a> fut créé. La
première fonctionnalité intéressante est la génération automatique des noms de
classes CSS. Plus d&#x27;inquiétude sur leur unicité, on peut les nommer comme on
veut, au final ceux générés dans le HTML seront uniques. Promis. Cela nous
permet de réécrire ce code CSS en BEM, et HTML :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>en ce code CSS et template JavaScript :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName</span> {
  <span class="hljs-attribute">color</span>: $textColor
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span></code></pre>
<p>Une fois compilé, ce code générera quelque chose comme ça :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"styleName__abc5436"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>Une casc-quoi ? Je ne sais pas ce que c&#x27;est ! ❤️</p>
<p>La deuxième fonctionnalité géniale, directement inspirée par les frameworks CSS
modulaires comme Tachyons, est la composition des styles. De la même façon qu&#x27;en
ajoutant plusieurs classes utilitaires sur son élément HTML, CSS Modules nous
permet de composer nos classes à partir de styles communs. Laissez-moi vous
montrer :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.bigTitle}</span>&gt;&lt;/h1&gt;
 &lt;h2 class=<span class="hljs-subst">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span></code></pre>
<p>va générer :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle__def6547</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle__1638bcd</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js">&lt;h1 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 bigTitle__def6547"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;h2 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 mediumTitle__1638bcd"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre>
<p>Et ceci, messieurs-dames, est plutôt fantastique. Les styles sont modularisables
et composables, et ce sans classes incompréhensibles mais directement dans les
feuilles de style. Et les collisions de sélecteurs et règles ne sont plus qu&#x27;un
mauvais souvenir.</p>
<p>Et c&#x27;est ainsi que j&#x27;ai expérimenté avec le CSS et sa cascade jusque-là.
J&#x27;espère que les mois et les années à venir vont me surprendre avec de meilleurs
outils et / ou méthodologies, et je serais heureux de les apprendre et les
essayer 👍</p>
]]></description><link>http://putaindecode.io/fr/articles/css/modules/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/modules/</guid><pubDate>Tue, 23 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Toward CSS modules]]></title><description><![CDATA[<blockquote>
<p>I think that even before I ever knew what it was, I already heard someone
telling me “Oh god, I HATE CSS”. This sentence is often said by one of my
backender friends, and often for very good reasons. This post isn’t going to
defend nor make you embrace CSS , but as front-end tooling is quickly improving,
I find it interesting to explain the new ways of writing it.</p>
</blockquote>
<h2 id="back-to-basics"><a href="#back-to-basics" class="phenomic-HeadingAnchor">#</a>Back to basics</h2>
<p>First, to understand what are the problems that the new tools are attempting to
solve, a small reminder of what CSS is: <em>Cascading Style Sheets</em>.</p>
<p>A style sheet ? Boy, that’s easy ! It’s some code that maps some  “styles” to
HTML elements. Cascading ? Well, sometimes more than one (or no) style can match
for an HTML element, and “cascading” is the set of rules that exist to determine
which one to apply.</p>
<p>Let’s see some basic CSS code: we want our h1 titles to be red.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Here, we map the <strong><em>rule (or declaration)</em></strong> “color: red” to the <strong><em>selector</em></strong>
“h1”. A selector can contain multiples rules in its declaration block.</p>
<blockquote>
<p>And now the delight dies as we enter the cascade hell.</p>
</blockquote>
<h2 id="the-cascading-thing"><a href="#the-cascading-thing" class="phenomic-HeadingAnchor">#</a>The cascading thing</h2>
<p>The cascade is for me the disaster that makes CSS un-maintainable without
guidelines nor tools when writing it. I’ll show you some examples explaining the
main concepts of the cascade, but they will be quite simple, whereas most web
app nowadays have huge codebases, making the cascade effects bigger.</p>
<p>The need for such a system like the cascade comes from the fact that CSS allows
multiple rules to be applied on the same element, even from different origins
(the website, but also the browser or even from the user). It is therefore
necessary to define what is the rule that ultimately will be applied in this
case.
The cascade gives each rule a weight, calculated from several criteria, and
apply the heaviest on the element.
I could appear simple at first, but the calculations
criteria are not, at all.</p>
<p>The rules that have the lightest cascade weight are not really an issue, but we
have to keep them in mind to avoid surprises:</p>
<h3 id="browser-defaults"><a href="#browser-defaults" class="phenomic-HeadingAnchor">#</a>Browser defaults</h3>
<p>Here is the top of the cascade. These are the rules that makes a h1 title big
even if it isn&#x27;t specified.</p>
<h3 id="parent-inheritance"><a href="#parent-inheritance" class="phenomic-HeadingAnchor">#</a>Parent inheritance</h3>
<p>Then, the rules are inherited from the parents HTML elements. Back to our h1
element, if there is a “color: blue” rule on the body element, the title will
inherit it, and will therefore be blue.</p>
<p>That being said, we now enter a more painful level of cascade weight.</p>
<h3 id="rule-order"><a href="#rule-order" class="phenomic-HeadingAnchor">#</a>Rule order</h3>
<p>The position of a rule compared with others will have an influence on its
weight. Thus, if two rules were to have the same weight if on the same position,
it finally will be the latest that will be the heaviest, and so applied. <strong><em>The
latest.</em></strong> With some quite simple code, it can be easy to understand:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Easy, right ? The h1 will be blue ! But if there is a “color: red” rule in one
CSS file named <em>foo.css</em>, a “color: blue” rule in another file named <em>bar.css</em>,
that the <em>foo.css</em> loading takes more time than <em>bar.css</em>, but that the
<em>foo.css</em> HTML tag is before the <em>bar.css</em> one, which rule is applied ? Well,
it’s quite harder to know. <em>(hint: the loading time is not taken into account)</em></p>
<h3 id="selector-specificity"><a href="#selector-specificity" class="phenomic-HeadingAnchor">#</a>Selector specificity</h3>
<p>This one is a level of complexity higher, <a href="https://specificity.keegan.st">some people even made calculators to
simplify it</a>. I will not enter into much details,
but know that the weight of a selector is equal to the sum of all the weights of
the selectors composing it. And that all selectors does’t weigh the same.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.title</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>In this example, the first selector’s weight is 10 because it only contains a
CSS class selector which weigh 10. The second selector’s weight is 3, because it
contains three tag selectors, weighing each 1. So, as 10 &gt; 3, the h1 title will
be red !</p>
<h3 id="inline-styles"><a href="#inline-styles" class="phenomic-HeadingAnchor">#</a>Inline styles</h3>
<p>The rules that are in the “style” attribute on a HTML element are heavier than
any selector previously defined. Here is a blue title:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<h3 id="importance"><a href="#importance" class="phenomic-HeadingAnchor">#</a>Importance</h3>
<p>And last but not least, the God Mode, the crusher of all styles, the
<strong><em>!important</em></strong> keyword. When we REALLY want our title to be red:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>As all this cascade is about weight, if two rules are marked as !important, the
rest of the criteria is still taken into account to calculate which one is the
heavier, and so applied.</p>
<p><strong>…And that is as bad as it gets.</strong> Now, imagine thousands and thousands of
selectors cascading over themselves to style a website, and you’ll understand
the hell CSS can be. So, some fellow CSS developers imagined several
methodologies and tools to prevent this nightmare to happen !</p>
<h2 id="tooling-evolution"><a href="#tooling-evolution" class="phenomic-HeadingAnchor">#</a>Tooling evolution</h2>
<p>Now I’ll present to you how my way of writing CSS evolved over time. Do not
expect a complete timeline of all the tools invented since the first release of
CSS in 1996 (I was 6 years old !), but a description of how I worked with (or
around) the cascade in my short personal experience.</p>
<h3 id="pre-processors"><a href="#pre-processors" class="phenomic-HeadingAnchor">#</a>Pre-processors</h3>
<p>I began developing web applications in 2012, in the golden age of the
pre-processors. They already had appeared a few years back, as CSS itself wasn’t
enough to build complex websites. Pre-processors are compilers that generate CSS
from slightly different languages, like <a href="http://sass-lang.com">Sass</a> or
<a href="http://lesscss.org">LESS</a>. These new languages added some fantastic new
features as variables or nesting, among other wonders.</p>
<p>We could transform some old and un-easy to maintain CSS:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#E5E5E5</span>;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<p>into this much <em>better</em> version:</p>
<pre><code class="hljs language-scss"><span class="hljs-variable">$textColor</span>: <span class="hljs-number">#333333</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: lighten(<span class="hljs-variable">$textColor</span>, <span class="hljs-number">90%</span>);

  <span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>
  }
}</code></pre>
<p>With these new tools, and to prevent rules to collide in the cascade, we started
nesting and replicating the whole HTML structure into our Sass or LESS code. Our
CSS ended up with super long and heavy selectors matching only and exactly our
element, like this one:</p>
<blockquote>
<p>.searchPage .sideBar .refinements.default .category .star input</p>
</blockquote>
<p>And this worked pretty well for a time ! But these selectors weren’t the more
efficient, and the HTML structure being doubled, any change in it must be passed
on the styles. So I moved on.</p>
<h3 id="css-methodologies"><a href="#css-methodologies" class="phenomic-HeadingAnchor">#</a>CSS Methodologies</h3>
<p>By this time, some new CSS writing guidelines began to drew my attention. They
weren’t exclusive with pre-processors, and aimed to avoid cascade collision
(just like nesting) with some rules, like on the selector naming.</p>
<p>These methodologies came by the time I started to split my developments into
components. The nesting didn’t work well with these, as the purpose was to
create bits of code usable everywhere in my web app, like a button for example.
The one I use (still today) is named <a href="https://en.bem.info/method/">BEM, for Block Element
Modifier</a>, but there are others with the same aim:
each HTML element of my component has to have an unique CSS class. This way, no
nesting is needed, and no cascade collision !</p>
<p>And this pre-processed code:</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>

  img {
    border: <span class="hljs-number">1px</span> solid black;
  }
}</code></pre>
<p>was transformed into:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor
}

<span class="hljs-selector-class">.Title-icon</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}</code></pre>
<p>Obviously, the HTML code needed to be updated with the new classes, but the
selectors are now short and self-explanatory ! Without any chance of cascade
collision.</p>
<p>Now, and to better explain a final tool, the one I think will solve all our
problems (for now), I must show you another approach of this “working around”
the cascade:</p>
<h3 id="css-frameworks"><a href="#css-frameworks" class="phenomic-HeadingAnchor">#</a>CSS Frameworks</h3>
<p>Here, to prevent our CSS to collide, we… stop writing our own ! CSS frameworks
are already written styles that we can use with specific CSS classes. There is
two different approaches here:</p>
<ul>
<li>
<p>“Final” styles framework as <a href="http://getbootstrap.com">Bootstrap</a>: a simple
<em>“btn”</em> class on a HTML element and… tada ! Now it is a magnificent button.
Besides, some variables are available to customize the frameworks’ look.
Utility styles framework, like <a href="http://tachyons.io">Tachyons</a>. Here, there
aren’t any pre-defined style, but a lot of utility CSS classes are available,
like <em>“pam”</em> to make an element have a <em>medium padding</em>, or <em>“ba”</em> to make it
have a <em>border all</em> around it.</p>
</li>
<li>
<p>The second one is quite interesting, as our final CSS file will only weigh
10kB and never more, even if the  website grows ! But the HTML will have a lot
of gibberish classes.
It’s comparable with having all the styles inline, with a
weight optimization comparable with minification, as <em>“ba”</em> is shorter than
<em>“border-style: solid; border-width: 1px;”</em>.</p>
</li>
</ul>
<p>These frameworks will keep us from complex CSS cascade calculations ! But I
quite didn’t like the fact to use a framework, and to have a lot of quite
unreadable CSS classes in my HTML. But the full re-usability and modularity of
the styles, without any cascade problems, are awesome.</p>
<p>This bring us to this amazing tool, directly forged with the best JavaScript
magic:</p>
<h3 id="css-modules"><a href="#css-modules" class="phenomic-HeadingAnchor">#</a>CSS Modules</h3>
<p>This concept first took shape from a simple observation: nowadays, the CSS code
is compiled from other languages to make its writing way easier, and for the
same reason HTML code is mainly generated with JavaScript templating tools. But
the CSS selectors, the link between the elements and the styles, the ones for
which the coder really needs to cogitate to prevent them to collide, are not
tooled at all.</p>
<p>And so <a href="https://github.com/css-modules/css-modules">CSS Modules</a> was created.
The first awesome feature is the CSS class names automatic generation. No more
worries about their uniqueness, we can name them as we want, the final one
generated on the HTML element will be unique. Promise. This allows to rewrite
this previous CSS BEM and HTML code:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>into this CSS and JS template code:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName</span> {
  <span class="hljs-attribute">color</span>: $textColor
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span></code></pre>
<p>And when compiled, this code will generate something like this !</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"styleName__abc5436"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>A casc-what ? I don’t know what this is ! ❤️</p>
<p>The second main feature, which is directly inspired by modular CSS frameworks
like Tachyons, is the styles composition. Just like it allowed to style HTML
elements with some common utility classes, CSS modules allows to compose our
classes with common styles. Let me show you !</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.bigTitle}</span>&gt;&lt;/h1&gt;
 &lt;h2 class=<span class="hljs-subst">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span></code></pre>
<p>will compile into:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle__def6547</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle__1638bcd</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js">&lt;h1 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 bigTitle__def6547"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;h2 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 mediumTitle__1638bcd"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre>
<p>And that, Sir, is pretty awesome. Styles are composable and modularizable, and
not with a lot of gibberish utility classes but directly in the stylesheet. And
styles colliding are just an old nightmare.</p>
<p>That’s how I’ve been playing around with CSS and its cascade until now. I expect
the months and years to come to surprise me with new and better tools or
methodologies, and I’ll be happy to learn and test them 👍.</p>
]]></description><link>http://putaindecode.io/en/articles/css/modules/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/css/modules/</guid><pubDate>Tue, 23 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction à Grid Layout]]></title><description><![CDATA[<p>La mise en page d&#x27;un site ou d&#x27;une application est toujours quelque chose de
complexe et fastidieux à développer/maintenir. Pour cela, de nombreux designs
sont élaborés à partir d&#x27;une grille. En effet, l&#x27;objectif de la grille est de
servir de base pour placer les différents éléments et de faire en sorte qu&#x27;ils
soient alignés et espacés uniformément. Le problème de CSS est qu&#x27;il rencontre
beaucoup de lacunes pour mettre en place cette logique.</p>
<p>L&#x27;arrivée du module <code>Flexbox</code> a commencé à bien faciliter les choses. Toutefois,
ce module n&#x27;est pas adapté à toutes les situations et il est bien plus pertinent
sur du layout de composants.</p>
<p>C&#x27;est pour cette raison qu&#x27;a été développé le module <code>Grid Layout</code>, plus
puissant et orienté mise en page.</p>
<h2 id="tat-des-lieux"><a href="#tat-des-lieux" class="phenomic-HeadingAnchor">#</a>État des lieux</h2>
<p>Parlons des choses qui fâchent dès le début. À l&#x27;heure actuelle la dernière
révision date du <a href="http://www.w3.org/TR/css-grid-1/">17 septembre 2015</a> et la
spécification en est toujours à l&#x27;état de <em>working draft</em>.</p>
<p>La compatibilité des <a href="http://caniuse.com/#feat=css-grid">navigateurs est quelque peu
limitée</a>. Excepté Internet Explorer 10+ (Edge
également), il est nécessaire d&#x27;activer le flag <code>layout.css.grid.enabled</code> dans
Firefox et <code>experimental Web Platform features</code> pour Chrome pour activer le
support du module.</p>
<p>Autant dire qu&#x27;une utilisation en production est relativement prématurée, quand
bien même cela ne doit pas nous empêcher d&#x27;expérimenter ce module.</p>
<h2 id="grid"><a href="#grid" class="phenomic-HeadingAnchor">#</a>Grid</h2>
<p>La notion de Grid n&#x27;est pas nouvelle, de multiples frameworks/librairies
utilisent déjà la mise en page en <code>Grid</code> :</p>
<ul>
<li><a href="https://github.com/suitcss/components-grid">SUIT CSS components-grid</a></li>
<li><a href="http://foundation.zurb.com/docs/components/grid.html">Zurb Foundation</a></li>
<li><a href="http://960.gs/">960</a></li>
<li><a href="https://github.com/cssrecipes/grid">cssrecipes Grid</a></li>
</ul>
<p>Toutes ces solutions se basent soit sur du <code>inline-block</code>, soit plus récemment
sur <code>Flexbox</code>. Même si elles sont relativement élégantes, elles nécessitent
quand même quelques petits hacks ou tricks pour réussir à faire quelque chose de
cohérent (hello, <code>font-size: 0</code>, gouttière, <code>calc</code> avec marge négative, etc.).
La raison est simple : les techniques utilisées ne sont pas adaptées pour un
système complet de <code>Grid</code>.</p>
<h2 id="thinking-in-grid"><a href="#thinking-in-grid" class="phenomic-HeadingAnchor">#</a>Thinking in Grid</h2>
<p>De façon à pouvoir présenter une partie de la spécification, nous allons partir
sur cette mise en page :</p>
<p><img src="maquette.png" alt="Maquette Grid Layout"></p>
<p>Avant de commencer à présenter les différentes propriétés, réfléchissons au
concept de <code>Grid</code>.</p>
<h3 id="grid-lines"><a href="#grid-lines" class="phenomic-HeadingAnchor">#</a>Grid lines</h3>
<p>Si on applique cette notion à notre maquette, voici ce qu&#x27;on obtient :</p>
<p><img src="grid-line.png" alt="Caniuse Grid Layout"></p>
<p>Concrètement, cela consiste à découper notre interface de façon à pouvoir en
extraire une grille et ainsi virtualiser la position et l&#x27;espace pris pour
chaque élément.</p>
<p>On va donc pouvoir extrapoler notre UI en lignes (<code>rows</code>), en colonnes
(<code>columns</code>), en cellules (<code>cells</code>) et en zones (<code>areas</code>).</p>
<p>Cette dernière notion (<code>areas</code>) est peut-être nouvelle dans la théorie, mais va
s&#x27;avérer très utile dans la pratique pour la suite.</p>
<h2 id="grid-layout"><a href="#grid-layout" class="phenomic-HeadingAnchor">#</a>Grid Layout</h2>
<p>On dispose de suffisamment d&#x27;informations sur notre interface pour démarrer
(enfin) notre intégration.</p>
<p>Voici le markup que l&#x27;on va utiliser pour notre maquette.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Layout"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Header"</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Aside"</span>&gt;</span>Aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Main"</span>&gt;</span>
    Main
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Footer"</span>&gt;</span>Footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Dans un premier temps, nous allons &quot;configurer&quot; notre <code>Grid</code>:</p>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.Layout</span> {
  <span class="hljs-comment">/*
   * On déclare un nouveau contexte dans le parent
   * qui devient alors un grid-container
   * tous les enfants deviennent des grid-items
   */</span>
   <span class="hljs-attribute">display</span>: grid;

  <span class="hljs-comment">/* Configuration de notre canvas */</span>

  <span class="hljs-comment">/*
   * On définit le nombre de colonnes :
   * - la première fera 200px de large
   * - la deuxième fera 10px de large
   * - la troisième prendra tout l'espace restant
   */</span>
   <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1</span>fr;

  <span class="hljs-comment">/*
   * Cette fois-ci au tour des lignes :
   * - la première fera 70px de haut
   * - la deuxième fera 10px de haut
   * - la troisième ligne s'adaptera à la hauteur de son contenu
   * - la quatrième fera 50px de haut
   */</span>
   <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">70px</span> <span class="hljs-number">10px</span> auto <span class="hljs-number">10px</span> <span class="hljs-number">50px</span>;

  <span class="hljs-comment">/*
   * On peut utiliser grid qui est le raccourci
   * des deux propriétés précédentes
   */</span>
   <span class="hljs-attribute">grid</span>: <span class="hljs-number">200px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1</span>fr / <span class="hljs-number">70px</span> <span class="hljs-number">10px</span> auto <span class="hljs-number">10px</span> <span class="hljs-number">50px</span>;
}</code></pre>
<p>Notre <code>Grid</code> est prête, passons au positionnement de nos éléments.</p>
<h2 id="grid-area"><a href="#grid-area" class="phenomic-HeadingAnchor">#</a>grid-area</h2>
<p>Pour notre exemple nous allons utiliser la méthode la plus originale du module à
savoir les <code>areas</code>. L&#x27;interêt de cette méthode est de pouvoir contrôler tant en
terme d&#x27;espace occupé que de positionnement les différentes zones (<code>areas</code>) de
notre grille. On pourrait définir la forme des valeurs de <code>grid-template-areas</code>
comme de l&#x27;<code>ASCII art</code>.</p>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.Layout</span> {
  <span class="hljs-comment">/**
   * 1. Header s'affichera sur 3 colonnes
   * 2. On utilisera le symbole . pour définir un élément
   *    virtuel et ainsi l'utiliser pour définir les gouttières
   * 3. Aside s'affichera sur 1 colonne et 3 lignes
   */</span>
  <span class="hljs-attribute">grid-template-areas</span>:
   <span class="hljs-string">"Header Header Header"</span>  <span class="hljs-comment">/* 1 */</span>
   <span class="hljs-string">".        .      .   "</span>  <span class="hljs-comment">/* 2 */</span>
   <span class="hljs-string">"Aside    .     Main "</span>  <span class="hljs-comment">/* 3 */</span>
   <span class="hljs-string">"Aside    .      .   "</span>  <span class="hljs-comment">/* 3 */</span>
   <span class="hljs-string">"Aside    .    Footer"</span>; <span class="hljs-comment">/* 3 */</span>
}

<span class="hljs-comment">/**
 * 1. Il est donc nécessaire de nommer chaque élément
 *    pour le contrôler dans notre area
 */</span>

<span class="hljs-selector-class">.Header</span> {
  <span class="hljs-attribute">grid-area</span>: Header; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Main</span> {
  <span class="hljs-attribute">grid-area</span>: Main; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Aside</span> {
  <span class="hljs-attribute">grid-area</span>: Aside; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Footer</span> {
  <span class="hljs-attribute">grid-area</span>: Footer; <span class="hljs-comment">/* 1 */</span>
}</code></pre>
<p>Notre intégration est terminée, on constate qu&#x27;avec très peu d&#x27;HTML et de CSS,
on arrive déjà à quelque chose d&#x27;intéressant. Il devient alors très facile de
manipuler et déplacer nos différents éléments en fonction du contexte de notre
application (mobile first, responsive, etc.).</p>
<h2 id="et-cest-pas-fini-"><a href="#et-cest-pas-fini-" class="phenomic-HeadingAnchor">#</a>Et c&#x27;est pas fini !</h2>
<p><code>Grid-Layout</code> dispose d&#x27;une quantité assez impressionnante de propriétés, il
embarque pratiquement toutes les propriétés introduites par <code>Flexbox</code>
(<code>align-items</code>, <code>order</code>, <code>justify-content</code> etc..).</p>
<p>De nouvelles fonctions font leur apparition comme <code>repeat</code> (permet d&#x27;appliquer
des motifs de répétition), mais aussi de nouvelles unités tels que
<code>xfr</code> (fraction de l&#x27;espace restant), <code>min-content</code> (se rapporte à l&#x27;élément le
plus petit), <code>max-content</code> (se rapporte à l&#x27;élément le plus grand). La notion de
<code>subgrid</code> est également présente pour l&#x27;imbrication de grilles.</p>
<p>Il est d&#x27;ailleurs tout à fait possible d&#x27;intégrer une même interface de
plusieurs manières différentes. Si l&#x27;on reprend notre exemple, nous somme partis
sur les propriétés utilisant les <code>areas</code>, mais on aurait très bien pu utiliser
<code>grid-row</code> et <code>grid-column</code> qui s&#x27;appliquent non pas sur le parent mais sur les
enfants. Cette solution peut s&#x27;avérer très pratique pour des systèmes de grilles
classiques.</p>
<p><code>Grid Layout</code> est un module très puissant et très complet. En le combinant avec
<code>Flexbox</code>, on dispose de suffisament d&#x27;outils pour travailler sur des mises en
pages complexes. Reste plus qu&#x27;aux navigateurs à rapidement valider/intégrer/supporter
cette nouvelle spécification.</p>
]]></description><link>http://putaindecode.io/fr/articles/css/grilles/grid-layout/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/grilles/grid-layout/</guid><pubDate>Tue, 05 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les Proxy]]></title><description><![CDATA[<h2 id="proxies-origin"><a href="#proxies-origin" class="phenomic-HeadingAnchor">#</a>Proxies Origin</h2>
<h3 id="what-the-dom"><a href="#what-the-dom" class="phenomic-HeadingAnchor">#</a>What the DOM?</h3>
<p>ES5 avait laissé un petit trou nommé
<em><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.8">&quot;host objects&quot;</a></em>
afin de donner un &quot;cadre légal&quot; aux trucs bizarres qui peuvent arriver dans le
DOM. Par exemple, certaines collections sont dites
<a href="https://dom.spec.whatwg.org/#concept-collection-live">&quot;live&quot;</a> et même si on ne
touche pas l&#x27;objet directement, on se rend compte que la collection a été
modifiée.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> childNodes = <span class="hljs-built_in">document</span>.body.childNodes;
<span class="hljs-built_in">console</span>.log(childNodes.length); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))
<span class="hljs-comment">// Personne n'a touché explicitement l'objet dans la variable divs, pourtant :</span>
<span class="hljs-built_in">console</span>.log(childNodes.length); <span class="hljs-comment">// 1, wat!</span></code></pre>
<p>Ce genre de comportement n&#x27;est pas explicable par la sémantique d&#x27;ES5 (à moins
d&#x27;accepter des gros problèmes de performances qui consisteraient à ce que le
DOM garde une référence vers toutes les collections live et les mette à jour
régulièrement, ou des getter partout, etc.). La
<a href="https://heycam.github.io/webidl/">spec WebIDL</a> qui fait le lien entre les
objets décrits dans les spec W3C et la sémantique ECMAScript se contentait d&#x27;un
&quot;c&#x27;est un <em>host object</em>, allé, salut les gars les filles !&quot; (en fait, c&#x27;était
pire que ça :
<a href="http://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html">la spec de
l&#x27;époque</a>
était absurde tant elle manquait de détails, mais je vous fais la version de
Noël).</p>
<p>Mais ce genre d&#x27;explication n&#x27;est pas vraiment acceptable. Et si un navigateur
a un bug, comment je polyfille le comportement correct, hein ?</p>
<p>Les proxies peuvent aider.</p>
<h3 id="quest-il-arriv--mon-objet-"><a href="#quest-il-arriv--mon-objet-" class="phenomic-HeadingAnchor">#</a>Qu&#x27;est-il arrivé à mon objet ?</h3>
<p>Avant que la planète JS ne s&#x27;amourache des
<a href="https://facebook.github.io/immutable-js/">structures des données immutables</a>,
on créait des objets et des fois, on les passait à du code qui les modifiait et
on se demandait bien quand/comment l&#x27;objet en question en était arrivé dans cet
état. Depuis ES5, on peut logger dans des <em>getters</em> et <em>setters</em>, mais on ne
peut pas savoir quand on s&#x27;est pris un <code>delete</code> ou un
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze</a> ;
on peut constater le résultat, mais c&#x27;est dur de remonter à la source.</p>
<p>Les proxies peuvent aider.</p>
<h3 id="laisse-mon-objet-tranquille-"><a href="#laisse-mon-objet-tranquille-" class="phenomic-HeadingAnchor">#</a>Laisse mon objet tranquille !</h3>
<p>La sémantique des objets tel qu&#x27;on les utilise permet à différents scripts
d&#x27;agir sur les mêmes objets, mais d&#x27;une manière qui ne permet pas forcément
toujours un contrôle fin. Par exemple, si je donne accès à la référence d&#x27;un
objet à quelqu&#x27;un, il possède cette référence pour toujours et dans la foulée
tous les droits associés (donc modifier l&#x27;objet arbitrairement souvent) ; il
n&#x27;est pas possible de <strong>révoquer</strong> l&#x27;accès dans le temps. Ce script a aussi
accès à toutes les propriétés de l&#x27;objet, même si on voudrait n&#x27;en partager
que certaines ; il n&#x27;est pas facile <strong>d&#x27;atténuer</strong> les droits à un objet (sans
créer de nouveaux objets et de se lancer dans des synchronisations coûteuses).</p>
<h2 id="les-proxies-comment-a-marche"><a href="#les-proxies-comment-a-marche" class="phenomic-HeadingAnchor">#</a>Les proxies, comment ça marche</h2>
<p>Un <strong>proxy</strong> est un nouvel objet (on ne peut pas transformer un objet en un
proxy) qui &quot;emballe&quot; (<em>wrap</em>) un objet existant, la <strong>target</strong> et décrit le
comportement du proxy via un objet appelé le <strong>handler</strong> qui définit les
<em>traps</em> du proxy.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = {a:<span class="hljs-number">1</span>};

<span class="hljs-keyword">const</span> handler = {
    get(target, prop){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"It's a (get) trap!"</span>, prop, target[prop]);
        <span class="hljs-keyword">return</span> target[prop]+<span class="hljs-number">1</span>;
    }
}

<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">console</span>.log(proxy.a);</code></pre>
<p>console output:</p>
<pre><code>It&#x27;s a (get) trap! a 1 // inside the trap
2 // new value modified by the trap
</code></pre>
<h3 id="liste-des-traps"><a href="#liste-des-traps" class="phenomic-HeadingAnchor">#</a>Liste des traps</h3>
<p>L&#x27;exemple ci-dessus montre la trap <code>get</code>. Voici la liste des traps
disponible :</p>
<ul>
<li>
<p>getPrototypeOf</p>
<ul>
<li>pour <code>Object.getPrototypeOf</code></li>
</ul>
</li>
<li>
<p>setPrototypeOf</p>
<ul>
<li>pour <code>Object.setPrototypeOf</code></li>
</ul>
</li>
<li>
<p>isExtensible</p>
<ul>
<li>pour <code>Object.isExtensible</code></li>
</ul>
</li>
<li>
<p>preventExtensions</p>
<ul>
<li>pour <code>Object.preventExtensions</code></li>
</ul>
</li>
<li>
<p>getOwnPropertyDescriptor</p>
<ul>
<li>pour <code>Object.getOwnPropertyDescriptor</code></li>
</ul>
</li>
<li>
<p>defineProperty</p>
<ul>
<li>pour <code>Object.defineProperty</code></li>
</ul>
</li>
<li>
<p>has</p>
<ul>
<li>pour l&#x27;opérateur <code>in</code></li>
</ul>
</li>
<li>
<p>get</p>
<ul>
<li>pour <em>getter</em> une propriété</li>
</ul>
</li>
<li>
<p>set</p>
<ul>
<li>pour <em>setter</em> une propriété</li>
</ul>
</li>
<li>
<p>deleteProperty</p>
<ul>
<li>pour l&#x27;opérateur <code>delete</code></li>
</ul>
</li>
<li>
<p>enumerate</p>
<ul>
<li>pour les <code>for...in</code> et <code>Object.keys</code></li>
</ul>
</li>
<li>
<p>ownKeys</p>
<ul>
<li>pour <code>Object.getOwnPropertyNames</code></li>
</ul>
</li>
<li>
<p>apply</p>
<ul>
<li>pour quand on appelle le proxy comme une fonction.</li>
</ul>
</li>
<li>
<p>construct</p>
<ul>
<li>pour quand on appelle le proxy comme un constructeur (avec <code>new</code>).</li>
</ul>
</li>
</ul>
<p>Le lecteur attentif aura remarqué que cette liste (et les signatures des
fonctions) correspondent à l&#x27;API</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods">Reflect</a></p>
<h2 id="solutions-aux-problmes-prcdents"><a href="#solutions-aux-problmes-prcdents" class="phenomic-HeadingAnchor">#</a>Solutions aux problèmes précédents</h2>
<h3 id="logger-les-oprations"><a href="#logger-les-oprations" class="phenomic-HeadingAnchor">#</a>Logger les opérations</h3>
<p>Vous voulez savoir quand on objet se prend un <code>delete</code> ? Rien de plus
facile !</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({b: <span class="hljs-number">2</span>}, {
    deleteProperty(target, prop){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Wow, someone just deleted'</span>, prop);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(target, prop);
    },
    freeze(target){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Wow, someone just froze the object'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.freeze(target);
    }
})

<span class="hljs-keyword">delete</span> p.b;
<span class="hljs-built_in">Object</span>.freeze(p);</code></pre>
<h3 id="implmenter-des-nodelist-live"><a href="#implmenter-des-nodelist-live" class="phenomic-HeadingAnchor">#</a>Implémenter des NodeList live</h3>
<p>Ici, on prétend réimplémenter une collection DOM <em>live</em>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildNodesLiveCollection</span>(<span class="hljs-params">parent</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, prop</span>)</span>{
            <span class="hljs-keyword">if</span>(prop === <span class="hljs-string">"length"</span>){
                <span class="hljs-comment">// l'astuce qui n'est pas de la triche , c'est qu'on va</span>
                <span class="hljs-comment">// chercher la valeur au moment de l'appel</span>
                <span class="hljs-keyword">return</span> parent.childNodes.length;
            }
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> target[prop];
        }
    })

}


<span class="hljs-keyword">var</span> liveChildNodes = getChildNodesLiveCollection(<span class="hljs-built_in">document</span>.body);
<span class="hljs-built_in">console</span>.log(liveChildNodes.length); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))
<span class="hljs-built_in">console</span>.log(liveChildNodes.length); <span class="hljs-comment">// 1, magie magie !</span></code></pre>
<h3 id="attnuation"><a href="#attnuation" class="phenomic-HeadingAnchor">#</a>Atténuation</h3>
<p>J&#x27;ai un objet avec plein de propriété et je veux en partager une version
atténuée à une bibliothèque en laquelle je n&#x27;ai qu&#x27;une confiance partielle.</p>
<pre><code class="hljs language-js">// On va se faire MitM avec ce HTTP sans 'S' !
import dubiousLib from 'http://dubious-lib.com/main.js';

const myImportantObject = {
    jfkKillerName: '...',
    elvisGeoloc: {
        long: '...',
        lat: '...'
    },
    name: "David Bruant",
    xmasPresentList: [
        "Raspberry Pi B",
        "Nouveau téléphone (mais pas FirefoxOS, parce qu'ils arrêtent les
téls)",
        "Une boîte de Tic Tac"
    ]
}

function makeWhitelistProxy(t, whitelist){
    return new Proxy(t, {
        get(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.get(target, prop);
        },
        set(target, prop, value){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.set(target, prop, value);
        },
        getOwnPropertyDescriptor(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        deleteProperty(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.deleteProperty(target, prop);
        },
        defineProperty(target, prop, desc){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.defineProperty(target, prop, desc);
        },
        has(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.has(target, prop);
        }
    })
}

const attenatedObject = makeWhitelistProxy(
    myImportantObject,
    new Set(["name", "xmasPresentList"])
);

console.log(myImportantObject.name === attenatedObject.name);
console.log(myImportantObject.jfkKillerName); // "..."
console.log(attenatedObject.jfkKillerName);
// error thrown! 'Error: Attempt to access forbidden property'

dubiousLib(attenatedObject);</code></pre>
<p>On peut imaginer d&#x27;autres formes d&#x27;atténuation, comme ne donner accès qu&#x27;en
lecture à l&#x27;objet alors que l&#x27;on garde soi-même un accès en écriture (ce qui
est impossible avec <code>Object.freeze</code>).</p>
<h3 id="rvocation"><a href="#rvocation" class="phenomic-HeadingAnchor">#</a>Révocation</h3>
<p>On peut révoquer l&#x27;accès à un objet en implémentant le <em>pattern</em> &quot;caretaker&quot;</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCaretaker</span>(<span class="hljs-params">t</span>)</span>{
    <span class="hljs-keyword">return</span> {
        revoke(){
            t = <span class="hljs-literal">undefined</span>;
        },
        proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(t, {
            get(target, prop){
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop);
            },
            set(target, prop, value){
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, value);
            }
            <span class="hljs-comment">// flemme d'écrire et vous faire lire les autres traps,</span>
            <span class="hljs-comment">// mais faut toutes les faire ;-)</span>
        })
    }
}

<span class="hljs-keyword">const</span> o = {};
<span class="hljs-keyword">const</span> {revoke, proxy} = makeCaretaker(o);

proxy.a = <span class="hljs-number">12</span>;

<span class="hljs-built_in">console</span>.log(o.a, proxy.a); <span class="hljs-comment">// 12 12</span>

proxy.b = <span class="hljs-number">37</span>;
<span class="hljs-keyword">delete</span> proxy.a;

revoke();

proxy.b; <span class="hljs-comment">// BOOM! TypeError: target is not a non-null object</span></code></pre>
<h4 id="via-un-meta-proxy"><a href="#via-un-meta-proxy" class="phenomic-HeadingAnchor">#</a>...via un meta-proxy</h4>
<p>La petite astuce rigolote avec les proxy, vu que l&#x27;API est dite <em>stratifiée</em>,
c&#x27;est que vu que le handler est un objet, on pourrait en faire un proxy pour
implémenter la révocation plus simplement.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCaretaker</span>(<span class="hljs-params">target</span>)</span>{
    <span class="hljs-keyword">const</span> metaHandler = {
        get(handler, trapName){
            <span class="hljs-keyword">if</span>(!target)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Revoked object!'</span>)
            <span class="hljs-keyword">else</span>
                <span class="hljs-comment">// Le miroir entre les traps et l'API Reflect vient de là ;-)</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>[trapName];
        }
    }

    <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, metaHandler);

    <span class="hljs-keyword">return</span> {
        revoke(){
            target = <span class="hljs-literal">undefined</span>;
        },
        proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)
    };
}

<span class="hljs-keyword">const</span> o = {};
<span class="hljs-keyword">const</span> {revoke, proxy} = makeCaretaker(o);

proxy.a = <span class="hljs-number">12</span>;

<span class="hljs-built_in">console</span>.log(o.a, proxy.a); <span class="hljs-comment">// 12 12</span>

proxy.b = <span class="hljs-number">37</span>;
<span class="hljs-keyword">delete</span> proxy.a;

revoke();

proxy.b; <span class="hljs-comment">// BOOM! TypeError: target is not a non-null object</span></code></pre>
<p>Il fait mal au crâne au début celui-là, mais après relecture, on se sent bien.</p>
<p>Pour des raisons par très intéressantes, les proxy révocables sont fournis
directement via</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable">Proxy.revocable</a>,
donc, pas besoin de se fatiguer à le coder avec toutes les traps ou avec un
meta handler.</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Les proxies sont un outil bas niveau et puissant. Avec de grands pouvoirs
viennent de grandes responsabilités, alors comprenez bien cet outil avant de
vouloir l&#x27;utiliser partout.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/proxy/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/proxy/</guid><pubDate>Fri, 18 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les symboles]]></title><description><![CDATA[<p>Dans sa politique d&#x27;enrichissement des types primitifs, ES6 introduit les
symboles. Chers aux développeurs de nombreux langages, Ruby en tête, les
symboles constituent une étape de plus vers l&#x27;éradication du <em>stringly-typed
programming</em>. En effet, les symboles fournissent un moyen plus robuste de
représenter des identifiants.</p>
<h2 id="crer-un-symbole"><a href="#crer-un-symbole" class="phenomic-HeadingAnchor">#</a>Créer un symbole</h2>
<p>La fonction <code>Symbol()</code> permet de créer de nouveaux symboles :</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Un symbole tout bête</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">typeof</span> mySymbol === <span class="hljs-string">'symbol'</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Un symbole avec une description</span>
<span class="hljs-keyword">const</span> myOtherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"description"</span>);


<span class="hljs-comment">// Chaque symbole est unique</span>
<span class="hljs-keyword">const</span> yetAnotherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"description"</span>);
yetAnotherSymbol === myOtherSymbol; <span class="hljs-comment">// false</span></code></pre>
<p>Chaque symbole créé avec <code>Symbol</code> est unique et immutable. Cela permet
d&#x27;éviter les collisions : on ne peut pas avoir deux symboles identiques par
erreur.</p>
<h2 id="utiliser-les-symboles-pour-limplmentation-dun-enum"><a href="#utiliser-les-symboles-pour-limplmentation-dun-enum" class="phenomic-HeadingAnchor">#</a>Utiliser les symboles pour l&#x27;implémentation d&#x27;un <em>enum</em></h2>
<p>Plutôt que d&#x27;utiliser des chaînes de caractères comme valeurs possible d&#x27;un
<em>enum</em>, on peut utiliser des symboles.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ANIMAL_DOG = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> ANIMAL_CAT = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDescription</span>(<span class="hljs-params">animal</span>) </span>{
  <span class="hljs-keyword">switch</span>(animal) {
    <span class="hljs-keyword">case</span> ANIMAL_DOG:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Loving animal"</span>;
    <span class="hljs-keyword">case</span> ANIMAL_CAT:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Evil, sadistic animal"</span>;
  }
}</code></pre>
<p>De cette manière, on ne risque pas de mélanger accidentellement une chaine de
caractères fournie par l&#x27;utilisateur et la valeur d&#x27;un <em>enum</em>. On est obligé
de passer par une phase de parsing et de vérification.</p>
<h2 id="utiliser-un-symbole-comme-cl"><a href="#utiliser-un-symbole-comme-cl" class="phenomic-HeadingAnchor">#</a>Utiliser un symbole comme clé</h2>
<p>Il est possible d&#x27;employer des symboles comme clés d&#x27;un objet ou d&#x27;une classe.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKey = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"MY_KEY"</span>);

<span class="hljs-keyword">const</span> myMutableObject = {};
myMutableObject[myKey] = <span class="hljs-string">"a value"</span>;

<span class="hljs-comment">// En utilisant les *computed property keys*</span>
<span class="hljs-keyword">const</span> myObj = {
    [myKey]: <span class="hljs-string">"a value"</span>
}</code></pre>
<p>Grâce à l&#x27;unicité des symboles, plus de problèmes de collision entre les clés
d&#x27;un objet. On peut laisser l&#x27;utilisateur étendre des objets sans prendre le
risque d&#x27;avoir des propriétés écrasées par erreur.</p>
<p>Par exemple, l&#x27;itérateur d&#x27;un objet employé par <code>for..of</code> est une propriété
qui a pour clé un symbole, accessible via <code>Symbol.iterator</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myIterableObject = {
  * [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Three"</span>;
  }
}

<span class="hljs-comment">// Affichera One, Two et Three</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> myIterableObject) {
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-comment">// Plantera avec 'TypeError: undefined is not a function'</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> {}) {}</code></pre>
<p>Différents symboles (les <em>well-known symbols</em>) sont disponibles pour indexer
des propriétés qui personnalisent le comportement des objets :
<code>Symbol.iterator</code> pour itérer sur les valeurs d&#x27;un objet, <code>Symbol.hasInstance</code>
pour modifier le retour de <code>instanceof</code>, …</p>
<p>Ces propriétés sont ainsi protégées contre tout accès involontaire.</p>
<h3 id="diffrences-avec-lutilisation-dune-chaine-de-caractres-comme-cl"><a href="#diffrences-avec-lutilisation-dune-chaine-de-caractres-comme-cl" class="phenomic-HeadingAnchor">#</a>Différences avec l&#x27;utilisation d&#x27;une chaine de caractères comme clé</h3>
<p>Les propriétés indexées par des symboles ne sont pas accessibles depuis les
fonctions habituellement utilisées pour itérer sur les propriétés ou les
valeurs.</p>
<h4 id="numration"><a href="#numration" class="phenomic-HeadingAnchor">#</a>Énumération</h4>
<p>Les propriétés indexées par des symboles ne sont pas visitées par <code>for..in</code>,
ni listées par <code>Object.keys</code> ni <code>Object.getOwnPropertyNames</code>. En revanche,
elles sont listées par <code>Object.getOwnPropertySymbols</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myObject = {
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}

<span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject) <span class="hljs-comment">// [ "key" ]</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject) <span class="hljs-comment">// [ Symbol() ]</span></code></pre>
<p>Ainsi, du code utilisant <code>Object.getOwnPropertyNames</code> et s&#x27;attendant à
recevoir des chaînes de caractères ne sera pas cassé par l&#x27;utilisation de
symboles en tant que clés.</p>
<h4 id="jsonstringify"><a href="#jsonstringify" class="phenomic-HeadingAnchor">#</a><code>JSON.stringify</code></h4>
<p>Les propriétés indexées par un symbole sont ignorées par <code>JSON.stringify</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">JSON</span>.stringify({
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}) <span class="hljs-comment">// '{"key":"string-keyed value"}'</span></code></pre>
<h2 id="registre-global-des-symboles"><a href="#registre-global-des-symboles" class="phenomic-HeadingAnchor">#</a>Registre global des symboles</h2>
<p>Un symbole est unique, une fois créé, il est impossible d&#x27;en créér un autre
ayant les mêmes propriétés. Il faut donc que le symbole créé soit accessible
d&#x27;une manière ou d&#x27;une autre pour pouvoir l&#x27;employer. En revanche, il est
possible de créer un symbole dans un registre global accessible de n&#x27;importe
où, grâce à <code>Symbol.for</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Renvoie un symbole, en le créant s'il n'existe pas déjà</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>)

mySymbol === <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Il est possible de récupérer la clé avec laquelle un symbole a été inséré</span>
<span class="hljs-comment">// dans le registre</span>
<span class="hljs-built_in">Symbol</span>.keyFor(mySymbol) <span class="hljs-comment">// 'mySymbol'</span>

<span class="hljs-comment">// Un symbole non créé dans le registre n'est pas disponible</span>
<span class="hljs-built_in">Symbol</span>.keyFor(<span class="hljs-built_in">Symbol</span>()) <span class="hljs-comment">// undefined</span></code></pre>
<p><code>Symbol.for</code> permet donc de partager des symboles partout dans le code, y
compris dans des contextes d&#x27;exécution différents (différentes frames).</p>
<h2 id="support"><a href="#support" class="phenomic-HeadingAnchor">#</a>Support</h2>
<p>Côté navigateur, les symboles sont supportés depuis Chrome 38, Firefox 36,
Opera 25 et Safari 9. Rien chez Internet Explorer. Le support Babel est
limité.</p>
<p>Côté Node.js, le support des symboles est là depuis la version <code>0.12</code>.</p>
<p>Les <em>well-known symbols</em> ne sont pas tous disponibles sur les différentes
plates-formes, leur présence dépendant des fonctionnalités auxquelles ils sont
liés.</p>
<h2 id="pour-rsumer"><a href="#pour-rsumer" class="phenomic-HeadingAnchor">#</a>Pour résumer</h2>
<p>Les symboles fournissent un moyen de créer des tokens uniques, ce qui est bien
plus robuste que l&#x27;utilisation de chaînes de caractères. L&#x27;utilisation des
symboles pour représenter les valeurs d&#x27;un <em>enum</em> permet d&#x27;éviter les
collisions et le mélange avec des données non qualifiées.</p>
<p>En tant que clés d&#x27;un objet, les symboles permettent d&#x27;éviter les collisions
et d&#x27;avoir des <em>méta-propriétés</em> séparées et indépendantes des propriétés
indexées par des clés. Les propriétés indexées par des symboles ne peuvent pas
être lues, modifiées ou listées par erreur, ce qui leur offre un certain degré
de protection contre des manipulations accidentelles.</p>
<h2 id="pour-aller-plus-loin"><a href="#pour-aller-plus-loin" class="phenomic-HeadingAnchor">#</a>Pour aller plus loin</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">La documentation des symboles sur MDN</a></li>
<li><a href="http://www.2ality.com/2014/12/es6-symbols.html">Un article complet sur le fonctionnement des symboles et leur cas
d&#x27;utilisation</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/symbols/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/symbols/</guid><pubDate>Thu, 17 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : symbols]]></title><description><![CDATA[<p>Following its goal of enriching primitive types, ES6 introduces symbols.
Familiar to developers in many langages, especially Ruby, symbols bring us a
step further towards the eradication of <em>stringly-typed programming</em>. Symbols
provide us with a more robust way to encode identifiers.</p>
<h2 id="creating-symbols"><a href="#creating-symbols" class="phenomic-HeadingAnchor">#</a>Creating Symbols</h2>
<p>The <code>Symbol()</code> function lets us create new symbols:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// A simple symbol</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">typeof</span> mySymbol === <span class="hljs-string">'symbol'</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// A symbol with a label</span>
<span class="hljs-keyword">const</span> myOtherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"label"</span>);


<span class="hljs-comment">// Each symbol is unique</span>
<span class="hljs-keyword">const</span> yetAnotherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"label"</span>);
yetAnotherSymbol === myOtherSymbol; <span class="hljs-comment">// false</span></code></pre>
<p>Each symbol created with <code>Symbol</code> is both unique and immutable. This allows to
avoid collisions: it&#x27;s impossible to mistakenly have two identical symbols.</p>
<h2 id="implement-an-enum-with-symbols"><a href="#implement-an-enum-with-symbols" class="phenomic-HeadingAnchor">#</a>Implement an <em>enum</em> with symbols</h2>
<p>Instead of using strings as possible values for an <em>enum</em>, it&#x27;s possible to
use symbols.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ANIMAL_DOG = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> ANIMAL_CAT = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDescription</span>(<span class="hljs-params">animal</span>) </span>{
  <span class="hljs-keyword">switch</span>(animal) {
    <span class="hljs-keyword">case</span> ANIMAL_DOG:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Loving animal"</span>;
    <span class="hljs-keyword">case</span> ANIMAL_CAT:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Evil, sadistic animal"</span>;
  }
}</code></pre>
<p>This way, there is no risk of mistakenly mixing a user-provided string with an
<em>enum</em>. This forces the value through a verifying and parsing stage.</p>
<h2 id="symbols-as-keys"><a href="#symbols-as-keys" class="phenomic-HeadingAnchor">#</a>Symbols as keys</h2>
<p>We can use symbols as a key in an object or in a class.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKey = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"MY_KEY"</span>);

<span class="hljs-keyword">const</span> myMutableObject = {};
myMutableObject[myKey] = <span class="hljs-string">"a value"</span>;

<span class="hljs-comment">// With *computed property keys*</span>
<span class="hljs-keyword">const</span> myObj = {
    [myKey]: <span class="hljs-string">"a value"</span>
}</code></pre>
<p>Due to symbols unicity, no more collisions between the keys of an object.
The user can extend objects without having properties overriden by mistake.</p>
<p>For instance, the iterator on an object (used by <code>for..of</code>), is a property
whose key is a symbol, available through <code>Symbol.iterator</code>.</p>
<p>For instance, an object&#x27;s iterator (used by <code>for..of</code>) is made available as
the property indexed by <code>Symbol.iterator</code>, a symbol devised for this use.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myIterableObject = {
  * [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Three"</span>;
  }
}

<span class="hljs-comment">// Displays One, Two and Three</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> myIterableObject) {
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-comment">// Blows up with 'TypeError: undefined is not a function'</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> {}) {}</code></pre>
<p>Several symbols (called <em>well-known symbols</em>) index behaviour defining
object properties: <code>Symbol.iterator</code> for the iterator on an object&#x27;s
values, <code>Symbol.hasInstance</code> to alter the result of <code>instanceof</code>, …</p>
<p>These properties are therefore protected against tampering.</p>
<h3 id="differences-between-symbol-keys-and-string-keys"><a href="#differences-between-symbol-keys-and-string-keys" class="phenomic-HeadingAnchor">#</a>Differences between symbol keys and string keys</h3>
<p>Properties indexed by symbols are not available from the commonly used key or
values functions.</p>
<h4 id="list-symbol-keys"><a href="#list-symbol-keys" class="phenomic-HeadingAnchor">#</a>List symbol keys</h4>
<p>Properties indexed by symbols are not visited by <code>for..in</code>, nor listed by
<code>Object.keys</code>, or <code>Object.getOwnPropertyNames</code>. However, they are listed by
<code>Object.getOwnPropertySymbols</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myObject = {
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}

<span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject) <span class="hljs-comment">// [ "key" ]</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject) <span class="hljs-comment">// [ Symbol() ]</span></code></pre>
<p>This way, a piece of code written with <code>Object.getOwnPropertyNames</code> -- and
expecting strings -- won&#x27;t be broken by the use of symbols as keys.</p>
<h4 id="jsonstringify"><a href="#jsonstringify" class="phenomic-HeadingAnchor">#</a><code>JSON.stringify</code></h4>
<p>Symbol-indexed properties are ignored by <code>JSON.stringify</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">JSON</span>.stringify({
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}) <span class="hljs-comment">// '{"key":"string-keyed value"}'</span></code></pre>
<h2 id="global-symbol-registry"><a href="#global-symbol-registry" class="phenomic-HeadingAnchor">#</a>Global symbol registry</h2>
<p>Symbols being unique, one cannot create a new symbol that is equal to an
already existing one. To be useful, a symbol must be somehow accessible. It&#x27;s
also possible to create a symbol in a global registry with <code>Symbol.for</code>, to
make it available from anywhere.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Returns a symbol, creating it if it doesn't already exist</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>)

mySymbol === <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// It's possible to get the key indexing a symbol in the registry</span>
<span class="hljs-built_in">Symbol</span>.keyFor(mySymbol) <span class="hljs-comment">// 'mySymbol'</span>

<span class="hljs-comment">// Symbols not created in the registry are not available in it</span>
<span class="hljs-built_in">Symbol</span>.keyFor(<span class="hljs-built_in">Symbol</span>()) <span class="hljs-comment">// undefined</span></code></pre>
<p><code>Symbol.for</code> allows to share symbols everywhere in the code, including
different execution contexts (different frames).</p>
<h2 id="support"><a href="#support" class="phenomic-HeadingAnchor">#</a>Support</h2>
<p>In browsers, symbols are supported since Chrome 38, Firefox 36, Opera 25 and
Safari 9. Nothing in Internet Explorer. Babel support is limited.</p>
<p>In Node.js, symbols are supported since version <code>0.12</code>.</p>
<p>Some <em>well-known symbols</em> are not available on all platforms. This depends on
implemented features support.</p>
<h2 id="round-up"><a href="#round-up" class="phenomic-HeadingAnchor">#</a>Round up</h2>
<p>Symbols are a way to create unique tokens, which is way more robust than
using strings. Using symbols to implement <em>enums</em> prevents collisions and
unwanted mix-up with unqualified data.</p>
<p>Lastly, symbols as object keys prevent collisions and lets us have
<em>meta-properties</em> cleanly separated from regular, string-indexed properties.
Properties indexed with symbols can&#x27;t be read, modified or listed by mistake.
This offers some protection against tampering.</p>
<h2 id="further-reading"><a href="#further-reading" class="phenomic-HeadingAnchor">#</a>Further reading</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN documentation on symbols</a></li>
<li><a href="http://www.2ality.com/2014/12/es6-symbols.html">Thorough article on how symbols work and how they can be used</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/symbols/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/symbols/</guid><pubDate>Thu, 17 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : for..of loop]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>With the arrival of new iterable objects, ECMAScript had to create new ways to read through them.
In the unique concern of maintaining the backward compatibility, ES6 had to const his <code>for..in</code> loop untouched.</p>
<blockquote>
<p>But then, how to create a copycat of this same loop with improved capabilities ?</p>
</blockquote>
<p>Solution is quite simple: &quot;Welcome to the <code>of</code> keyword!&quot;</p>
<p>But before I tell you more, and to fully understand the usefulness of this new keyword, const review the existing.</p>
<h2 id="the-good-ol-forin"><a href="#the-good-ol-forin" class="phenomic-HeadingAnchor">#</a>The good ol&#x27; <code>for..in</code></h2>
<p>All self-respecting <em>JavaScript enthousiast</em> already knows the famous <code>for..in</code> loop
whose first value is to iterate over the different keys of an object or an array.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>The <code>for..in</code> loop, despite its ease of use hide some pitfalls:</p>
<ul>
<li>
<p>When itarating over an array, index value is parsed to string : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc..
This behaviour can lead to potential error when index is used in computation.</p>
</li>
<li>
<p>The loop iterate across all the table keys, but also over each of its properties.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>];
arr.oups = <span class="hljs-string">'baz'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + arr[key] ); <span class="hljs-comment">// '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'</span>
}</code></pre>
</li>
<li>
<p>Iteration order over a given object properties may vary across depending on the code executing environment.</p>
</li>
</ul>
<h2 id="the-alternative-foreach-method"><a href="#the-alternative-foreach-method" class="phenomic-HeadingAnchor">#</a>The alternative <code>.forEach()</code> method</h2>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.prototype.forEach()</code></a>
loop allow a more secure iteration, but bring other downsides as:</p>
<ul>
<li>Impossibility to halt the loop with the traditional <code>break;</code> and <code>return;</code> statements.</li>
<li>Array only dedicated method.</li>
</ul>
<h2 id="forof-to-the-rescue"><a href="#forof-to-the-rescue" class="phenomic-HeadingAnchor">#</a><code>for..of</code> to the rescue</h2>
<p>ECMA consortium has so decided to proceed with establishment of a new enhanced version of the <code>for..in</code> loop.
Thus was born the <code>for..of</code> loop which, from now on, will coexist with the previous one allowing to maintain
the backward compatibility with former version of the standard.</p>
<p>The principal is the same : run across any type of <em>iterable object</em>.</p>
<p>In its simplest form, the <code>for..of</code> loop therefore allow to iterate over all values of a table keys.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>The <code>for..of</code> loop can also iterate over more complex types like:</p>
<h3 id="strings"><a href="#strings" class="phenomic-HeadingAnchor">#</a><em>Strings</em></h3>
<p>In this case, each character is evaluated as a Unicode entity.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="nodelist"><a href="#nodelist" class="phenomic-HeadingAnchor">#</a><em>NodeList</em></h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// Note: This will only work in platforms that have</span>
<span class="hljs-comment">// implemented NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// this code add a "read" class to each &lt;p&gt; markup</span>
<span class="hljs-comment">// contained in each &lt;article&gt; markup</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="maps"><a href="#maps" class="phenomic-HeadingAnchor">#</a><em>Maps</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="sets"><a href="#sets" class="phenomic-HeadingAnchor">#</a><em>Sets</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="generators"><a href="#generators" class="phenomic-HeadingAnchor">#</a><em>Generators</em></h3>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>What about traditional object ?</p>
</blockquote>
<p>Suprisingly, objects can&#x27;t be directly browsed by this brand new loop.
Fortunately a workaround exists such as
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="in-a-nutshell"><a href="#in-a-nutshell" class="phenomic-HeadingAnchor">#</a>In a nutshell</h2>
<p><code>for..of</code> comes to address <code>for..in</code> loop gaps and allow
a simplified iteration over <em>iterable objects</em> such as:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">String</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Maps &amp; WeakMaps</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a></li>
</ul>
<p>Furthermore, <code>for..of</code> as of now resolve pitfalls such as unpredictable iteration order or
automated coercion of index to string.</p>
<h2 id="to-go-further"><a href="#to-go-further" class="phenomic-HeadingAnchor">#</a>To go further</h2>
<p><code>for..of</code> loop is another added arrow to ES6 bow that
allows to run through, in a native way, the brand new <em>iterable objects</em> of the language.</p>
<p>For information about this feature :</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">MDN Documentation</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">The post of Jason Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">The post of Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">ECMA-262 Specification</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : la boucle for..of]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>Avec l&#x27;arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de
s&#x27;enrichir de
nouvelles façons de parcourir ces derniers. Dans l&#x27;unique souci de maintenir la
rétro-compatibilité
avec l&#x27;existant, l&#x27;ES6 se devait de garder la boucle <code>for..in</code> intacte.</p>
<blockquote>
<p>Mais alors, comment créer une variante de cette même boucle avec des capacités
améliorées ?</p>
</blockquote>
<p>La solution est simple : &quot;Bienvenue au mot-clé <code>of</code> !&quot;</p>
<p>Mais avant d&#x27;en dire plus, et pour comprendre l&#x27;utilité de ce nouveau mot-clé,
revoyons un peu l&#x27;existant.</p>
<h2 id="le-bon-vieux-forin"><a href="#le-bon-vieux-forin" class="phenomic-HeadingAnchor">#</a>Le bon vieux <code>for..in</code></h2>
<p>Tout <em>JavaScript enthusiast</em> qui se respecte connaissait déjà la fameuse boucle
<code>for..in</code>
dont l&#x27;utilité première est d&#x27;itérer sur les différentes clés d&#x27;un objet ou d&#x27;un
tableau.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>La boucle <code>for..in</code>, malgré son apparente simplicité d&#x27;utilisation, cache
certains pièges :</p>
<ul>
<li>
<p>Lors de l&#x27;itération sur un tableau la valeur de l&#x27;index est convertie en
chaîne
de caractères : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc. Cela peut potentiellement poser problème
lors de
l&#x27;utilisation de l&#x27;index dans des opérations de calcul.</p>
</li>
<li>
<p>La boucle itère sur l&#x27;ensemble des clés du tableau, mais aussi sur chacune de
ses propriétés.</p>
<pre><code>&#x60;&#x60;&#x60;js
const arr = [&#x27;foo&#x27;, &#x27;bar&#x27;];
arr.oups = &#x27;baz&#x27;;

for ( const key in arr ) {
  console.log( key + &#x27;-&gt;&#x27; + arr[key] ); // &#x27;0-&gt;foo&#x27;, &#x27;1-&gt;bar&#x27;, &#x27;oups-&gt;baz&#x27;
}
&#x60;&#x60;&#x60;
</code></pre>
</li>
<li>
<p>L&#x27;ordre d&#x27;itération sur l&#x27;ensemble des clés d&#x27;un objet peut varier selon
l&#x27;environnement d&#x27;éxecution du code.</p>
</li>
</ul>
<h2 id="la-methode-alternative-foreach"><a href="#la-methode-alternative-foreach" class="phenomic-HeadingAnchor">#</a>La methode alternative <code>.forEach()</code></h2>
<p>La boucle
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach"><code>Array.prototype.forEach()</code></a>
permet une itération plus sécurisée, mais présente certains autres inconvénients
tels que :</p>
<ul>
<li>L&#x27;impossibilité d&#x27;interrompre la boucle avec les instructions traditionnelles
<code>break;</code> et <code>return;</code></li>
<li>Il s&#x27;agit d&#x27;une méthode réservée aux tableaux.</li>
</ul>
<h2 id="forof--la-rescousse"><a href="#forof--la-rescousse" class="phenomic-HeadingAnchor">#</a><code>for..of</code> à la rescousse</h2>
<p>Le consortium ECMA a donc décidé de procéder à la création d&#x27;une nouvelle
version améliorée
de la boucle <code>for..in</code>. Ainsi naquit la boucle <code>for..of</code> qui coexistera
désormais avec la précédente,
permettant de maintenir la rétro-compatibilité avec les versions antérieures de
la norme.</p>
<p>Le principe est le même : parcourir n&#x27;importe quel type <em>d&#x27;objet itérable</em>.</p>
<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d&#x27;itérer sur
l&#x27;ensemble des valeurs des clés d&#x27;un tableau.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>La boucle <code>for..of</code> peut aussi itérer sur des types plus complexes. Examinons
cela de plus près.</p>
<h3 id="les-strings"><a href="#les-strings" class="phenomic-HeadingAnchor">#</a>Les <em>Strings</em></h3>
<p>Dans ce cas, chaque caractère est traité comme une entité Unicode.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="les-nodelist"><a href="#les-nodelist" class="phenomic-HeadingAnchor">#</a>Les <em>NodeList</em></h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// Note: cela ne fonctionnera que sur les environnements</span>
<span class="hljs-comment">// implémentant NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// ce code ajoute une class "read" à toutes les balises &lt;p&gt;</span>
<span class="hljs-comment">// contenues dans la(les) balises &lt;article&gt;</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="les-maps"><a href="#les-maps" class="phenomic-HeadingAnchor">#</a>Les <em>Maps</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="les-sets"><a href="#les-sets" class="phenomic-HeadingAnchor">#</a>Les <em>Sets</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="les-generators"><a href="#les-generators" class="phenomic-HeadingAnchor">#</a>Les <em>Generators</em></h3>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>Et les objets traditionnels dans tout ça ?</p>
</blockquote>
<p>Étonnamment, les objets ne peuvent pas être parcourus avec cette nouvelle
boucle sauf s&#x27;ils définissent le symbole <code>Symbol.iterator</code>. Heureusement,
il existe une solution de contournement par l&#x27;utilisation de
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a>
ou encore
d&#x27;<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/values"><code>Object.values()</code></a>
et
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/entries"><code>Object.entries()</code></a>
(ajouts ECMAScript7).</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>Exemple définissant un itérateur :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> iterableObj = {
  *[<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span>* <span class="hljs-built_in">Object</span>.entries(obj);
  }
};

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [key, val] <span class="hljs-keyword">of</span> iterableObj ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + val); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="en-rsum"><a href="#en-rsum" class="phenomic-HeadingAnchor">#</a>En résumé</h2>
<p><code>for..of</code> vient compléter les lacunes de <code>for..in</code> et permet
une itération simplifiée sur les <em>objets itérables</em> tels que :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String">String</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/">Maps &amp; WeakMaps</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments">arguments</a></li>
</ul>
<p>De plus, <code>for..of</code> résout à présent les pièges tels que l&#x27;ordre d&#x27;itération non
constant ou la coercion
automatique des index en chaîne de caractères.</p>
<h2 id="pour-aller-plus-loin"><a href="#pour-aller-plus-loin" class="phenomic-HeadingAnchor">#</a>Pour aller plus loin</h2>
<p>La boucle <code>for..of</code> est donc une corde de plus à l&#x27;arc de l&#x27;ES6 qui
permet de parcourir, de manière native, les tout nouveaux <em>objets itérables</em> du
langage.</p>
<p>Pour en savoir plus sur ses spécificités :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of">Documentation
MDN</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">Le post de Jason
Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">Le post de Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">Specification
ECMA-262</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Arrow functions]]></title><description><![CDATA[<p>ES2015 brings us some new syntax sugar that will likely make you stop using
<code>Function.prototype.bind()</code>.</p>
<p>Arrow functions are just a function shorthand using the <code>=&gt;</code> syntax.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Arrow functions are syntactically similar to the related feature that exists in
other languages like CoffeeScript, Java (8+), C#…</p>
<p>They support both expression and statement bodies.
In our example above, we have seen a classic statement.
But for simple function, we can use an simple expression, to make things shorter.
That means that the previous example can be also written like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Note that when you have only one argument, you can omit parenthesis around it.
So we can also wrote the example like this</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>And you can also wrap the body in parenthesis if you want to make a multiline expression</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// that can be multilines, you can imagine some JSX here ;)</span>
)</code></pre>
<p>So this examples are all the same :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>In practice you will use this small functions in method like Array
reduce/filter/map etc.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="arrow-functions-dont-have-a-this"><a href="#arrow-functions-dont-have-a-this" class="phenomic-HeadingAnchor">#</a>Arrow functions don’t have a <code>this</code></h2>
<p>Yes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.
So that means the <code>this</code> you might use use in the body of an arrow function refer to the parent scope:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Someone = {
  name: “MoOx”,
  friends: [], <span class="hljs-comment">// he got no friends atm :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` is not the function of the forEach !</span>
    )
  }
}</code></pre>
<p>By reading this code, you might understand that you are likely to stop using
<code>bind()</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> “react”
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stuff</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  <span class="hljs-comment">// old way</span>
  onClick(e) {
    <span class="hljs-keyword">this</span>.setState({ omg: <span class="hljs-literal">false</span> })
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        { /* old way */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.onClick.bind</span>(<span class="hljs-attr">this</span>) }&gt;</span>
          Old binded call
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* LOOK MA', NO BIND ! */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.onClick(e) }&gt;
          I don’t need `bind` anymore !
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* Simpler way */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;
          Hell yeah
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<h2 id="note-about-expression-body-and-object"><a href="#note-about-expression-body-and-object" class="phenomic-HeadingAnchor">#</a>Note about expression body and Object</h2>
<p>If you want to return an object you might be surprised to get <code>undefined</code>
with this code:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}</code></pre>
<p>Indeed the above snippet could be translated into ES5 this way:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> aFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
  key:         <span class="hljs-comment">// Defines a label named `key`</span>
    obj.value  <span class="hljs-comment">// Gets `obj.value`</span>
               <span class="hljs-comment">// Implicit returns `undefined`</span>
}</code></pre>
<p>Keep in mind that in this context, a brace is to start a statement body, not an
object.
So you will need this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>But wait, there is a trick: a stupid couple of parenthesis.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works!</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">compatibility table</a>.
You will see that arrow functions are already supported by most browsers but you
might need <a href="http://babeljs.io">Babel</a> to use it today.</p>
<p>You will probably use this more and more.
Even if <code>function</code> keyword is not dead, arrow functions <code>=&gt;</code> are probably
going to be a thing !</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les fonctions fléchées]]></title><description><![CDATA[<p>ES2015 nous apporte encore du sucre syntaxique qui risque très probablement de
vous faire oublier <code>Function.prototype.bind()</code>.</p>
<p>Les fonctions fléchées offrent une syntaxe raccourcie des fonctions en utilisant
la syntaxe <code>=&gt;</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Les fonctions fléchées sont syntaxiquement similaires à ce qu&#x27;on trouve déjà dans
d&#x27;autres langages comme CoffeeScript, Java (8+), C#…</p>
<p>Elles supportent les expressions ou les blocs en tant que corps de fonction.
Dans notre exemple précédent, nous avons utilisé un corps classique.
Pour de simples fonctions, nous pouvons utiliser des expressions, le but étant
d&#x27;avoir quelque chose de concis.
Notre exemple précédent peut ainsi s&#x27;écrire de la sorte :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Notez que lorsque l&#x27;on a qu&#x27;un argument dans notre fonction, on peut omettre les
parenthèses. Notre exemple peut donc aussi s&#x27;écrire ainsi :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Si notre expression mérite d&#x27;être sur plusieurs lignes, on peut aussi utiliser des
parenthèses :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX</span>
)</code></pre>
<p>Les exemples suivants sont donc tous les mêmes :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>Dans la pratique, vous utiliserez souvent cette syntaxe pour des petites méthodes
comme par exemple lors de l&#x27;utilisation des fonctions de tableau
reduce/filter/map, etc.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="les-fonctions-flches-nont-pas-de-this"><a href="#les-fonctions-flches-nont-pas-de-this" class="phenomic-HeadingAnchor">#</a>Les fonctions fléchées n&#x27;ont pas de <code>this</code></h2>
<p>Oui, vous avez bien lu : à l&#x27;inverse des fonctions normales, les fonctions
fléchées partagent le même <code>this</code> lexical que leur scope parent.
Du coup, le <code>this</code> que vous pourrez utiliser dans votre corps de fonction
fléchée est celui du code parent :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Someone = {
  name: “MoOx”,
  friends: [], <span class="hljs-comment">// Malheureusement, il n'a pas d'amis :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` ne réfère pas à la fonction fléchée du forEach !</span>
    )
  }
}</code></pre>
<p>En lisant ce code, vous avez peut être compris qu&#x27;il peut être possible de ne
plus avoir besoin du <code>bind()</code> aussi souvent que ça pouvait être le cas :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> “react”
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stuff</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  <span class="hljs-comment">// à l'ancienne</span>
  onClick(e) {
    <span class="hljs-keyword">this</span>.setState({ omg: <span class="hljs-literal">false</span> })
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        { /* à l'ancienne */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.onClick.bind</span>(<span class="hljs-attr">this</span>) }&gt;</span>
          Old binded call
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* REGARDE MAMAN, JE BIND RIEN */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.onClick(e) }&gt;
          I don’t need `bind` anymore !
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* Encore plus simplement */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;
          Hell yeah
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<h2 id="note-sur-les-expressions-et-les-objets"><a href="#note-sur-les-expressions-et-les-objets" class="phenomic-HeadingAnchor">#</a>Note sur les expressions et les objets</h2>
<p>Si vous voulez retourner un objet, vous serez surement supris de ne pas obtenir
le résultat attendu avec ce code :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}
<span class="hljs-built_in">console</span>.log(aFn()) <span class="hljs-comment">// undefined</span></code></pre>
<p>En effet, l&#x27;exemple ci-dessus pourrait être traduit en ES5 de la manière suivante :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> aFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
  key:         <span class="hljs-comment">// Defines a label named `key`</span>
    obj.value  <span class="hljs-comment">// Gets `obj.value`</span>
               <span class="hljs-comment">// Implicit returns `undefined`</span>
}</code></pre>
<p>Gardez en tête que dans ce contexte, une accolade ouvre un corps de fonction,
pas un objet.
Vous devrez donc faire comme ceci :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>Mais attendez, avec une simple astuce, on s&#x27;en sort avec un couple de
parenthèses :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works !</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Regardez
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">la table de compatibilité</a>.
C&#x27;est plutôt bien supporté par la plupart des navigateurs, mais vous risquez
sûrement d&#x27;avoir à utiliser <a href="http://babeljs.io">Babel</a> afin d&#x27;être tranquille.</p>
<p>Vous verrez que vous utiliserez les fonctions fléchées de plus en plus.
Même si le mot clé <code>function</code> n&#x27;est pas mort, les fonctions fléchées ont un
avenir certain !</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES2016 (?): fonctions asynchrones (async/await)]]></title><description><![CDATA[<p>Aujourd&#x27;hui, une fonctionnalité peut-être abusivement taggée &quot;ES6&quot; puisqu&#x27;elle ne
fait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).
La <a href="https://tc39.github.io/ecmascript-asyncawait/">spécification</a> est encore au
stade 3 (candidate) à l&#x27;heure de cet article. Mais il ne fait plus aucun doute
qu&#x27;elle (ou une variante) fera partie de la spécification ES2016.</p>
<h2 id="fonctions-asynchrones"><a href="#fonctions-asynchrones" class="phenomic-HeadingAnchor">#</a>Fonctions asynchrones</h2>
<p>Pour les traitements asynchrones, vous connaissez déjà
<a href="/fr/articles/js/es2015/promises/">les promesses</a> qui ont
évidemment remplacé les callbacks dans votre code. Si vous n&#x27;avez pas déjà fait
la bascule vers les promesses (ne serait-ce que pour la propagation d&#x27;erreur),
<a href="/fr/articles/js/es2015/generators/">les générateurs</a> ont
dû finir de vous convaincre grâce aux <a href="/fr/articles/js/es2015/generators/#use-case-co-routines">coroutines</a>.</p>
<p>Nous allons voir aujourd&#x27;hui une nouvelle manière de traiter les fonctions
asynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d&#x27;elles.</p>
<h2 id="exemple-de-traitement-asynchrone-promise"><a href="#exemple-de-traitement-asynchrone-promise" class="phenomic-HeadingAnchor">#</a>Exemple de traitement asynchrone : Promise</h2>
<p>Partons du programme suivant exécuté le
6 décembre dernier dont l&#x27;API est basée sur les promesses :</p>
<ul>
<li>Il récupère tous les utilisateurs prénommés Nicolas</li>
<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> usersP = getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-comment">// On récupère le champ "email" de tous les utilisateurs</span>
  <span class="hljs-keyword">const</span> emailsP = usersP.then((users) =&gt; users.map(u =&gt; u.email))
  <span class="hljs-comment">// Pour chaque email…</span>
  <span class="hljs-keyword">const</span> sentP = emailsP.then((emails) =&gt; emails.map((email) =&gt; {
    <span class="hljs-comment">// … on envoie un mail</span>
    <span class="hljs-keyword">return</span> sendMail(email, <span class="hljs-string">'Bonne fête'</span>)
  }))
  <span class="hljs-comment">// On attend que tous les envois soient résolus</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
  .then(() =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>))
  .catch(() =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>))</code></pre>
<h2 id="nouveaux-mot-cls-async-et-await"><a href="#nouveaux-mot-cls-async-et-await" class="phenomic-HeadingAnchor">#</a>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>
<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// …</span>
}</code></pre>
<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le
mot-clé <code>await</code> devient disponible. Lorsqu&#x27;il est utilisé en préfixe d&#x27;une
promesse, l&#x27;évaluation de l&#x27;expression est &quot;mise en pause&quot; jusqu&#x27;à la résolution
(ou le rejet) de la promesse :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> aPromise
  <span class="hljs-comment">// on n'arrivera à cette ligne que lorsque "aPromise" sera résolue</span>
}</code></pre>
<p>Évidemment, l&#x27;expression a alors pour valeur celle de résolution de la
promesse, et en cas d&#x27;erreur l&#x27;expression va lever (<code>throw</code>) une erreur :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> aPromise
    <span class="hljs-comment">// Ici "aPromise" est résolue avec la valeur "result"</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// Ici "aPromise" est rejetée avec l'erreur "err"</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// cette ligne n'est atteinte qu'après résolution/rejet</span>
}</code></pre>
<p>Concrètement, si vous vous souvenez de l&#x27;article sur les générateurs et de la
partie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et
<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>
<h2 id="notre-premier-exemple-avec-les-fonctions-asynchrones"><a href="#notre-premier-exemple-avec-les-fonctions-asynchrones" class="phenomic-HeadingAnchor">#</a>Notre premier exemple, avec les fonctions asynchrones</h2>
<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-keyword">const</span> emails = users.map(u =&gt; u.email)
  <span class="hljs-keyword">const</span> sentP = emails.map((email) =&gt; sendMail(email, <span class="hljs-string">'Bonne fête'</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

<span class="hljs-comment">// Attention, on ne peut pas utiliser "await" hors d'une fonction "async"</span>
<span class="hljs-comment">// il faut donc "wrapper" notre code autour d'une fonction asynchrone</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>)
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>)
  }
}

main()</code></pre>
<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus
habituel.</p>
<h2 id="attention-au-pige-de-lexcution-en-srie"><a href="#attention-au-pige-de-lexcution-en-srie" class="phenomic-HeadingAnchor">#</a>Attention au piège de l&#x27;exécution en série !</h2>
<p>Prenons l&#x27;exemple de requêtes qu&#x27;on exécute en concurrence avant d&#x27;utiliser
leurs résultats :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD</span>
<span class="hljs-keyword">const</span> resultP = <span class="hljs-built_in">Promise</span>.all([xP, yP]).then(sum)</code></pre>
<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs
retours attendus avant de passer à la suite.</p>
<p>Si on le traduit bêtement ainsi, on perd l&#x27;aspect concurrentiel :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> getX() <span class="hljs-comment">// Requête Ajax…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> getY() <span class="hljs-comment">// Requête BDD…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])</code></pre>
<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l&#x27;action</strong> et le
moment où l&#x27;on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières
de résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax démarrée…</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD démarrée…</span>

<span class="hljs-comment">// Version 1 :</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> xP <span class="hljs-comment">// …requête Ajax terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> yP <span class="hljs-comment">// …requête BDD terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])

<span class="hljs-comment">// Version 2 avec un tableau :</span>
<span class="hljs-keyword">const</span> vars = [<span class="hljs-keyword">await</span> xP, <span class="hljs-keyword">await</span> yP]
<span class="hljs-keyword">const</span> result = sum(vars)

<span class="hljs-comment">// Version 3 avec Promise.all :</span>
<span class="hljs-keyword">const</span> vars = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([xP, yP])
<span class="hljs-keyword">const</span> result = sum(vars)</code></pre>
<h2 id="et-aujourdhui"><a href="#et-aujourdhui" class="phenomic-HeadingAnchor">#</a>Et aujourd&#x27;hui ?</h2>
<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un
code basé sur les générateurs : il vous suffira d&#x27;ajouter les plugins Babel
<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à
inclure <code>babel-polyfill</code> en fichier d&#x27;entrée).</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Grâce aux fonctions asynchrones, la refactorisation d&#x27;un code bloquant vers un
code non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le
processus mais on n&#x27;était pas débarassé des callbacks. Là, à deux mot-clés près,
c&#x27;est exactement la même chose !</p>
<p>D&#x27;un certain côté, c&#x27;est un retour en arrière : l&#x27;asynchrone mène aux promesses,
qui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il
s&#x27;agira de trouver le bon équilibre, je ne suis pas convaincu d&#x27;abandonner mes
<code>.then</code> tout de suite, mais il est certain que c&#x27;est une véritable avancée
pour ce langage : la courbe d&#x27;apprentissage des traitements asynchrones va être
drastiquement aplanie ;)</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2016/async-await/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2016/async-await/</guid><pubDate>Mon, 14 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les nouvelles méthodes d'Array]]></title><description><![CDATA[<p><del>ES6</del>  ES2015 enrichit les objets de la bibiliothèque standard de nouvelles fonctionnalités.
Voici les nouveautés que l&#x27;on va trouver dans <code>Array</code>.</p>
<h2 id="arrayfrom"><a href="#arrayfrom" class="phenomic-HeadingAnchor">#</a>Array.from()</h2>
<p>Parmi les nouvelles méthodes ajoutées à Array, <code>Array.from()</code> est peut-être celle que vous allez utiliser le plus souvent. Elle va nous permettre de créer un tableau à partir d&#x27;un itérable ou d&#x27;un objet qui ressemble à un tableau comme une NodeList, ou encore <code>arguments</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySeletorAll(<span class="hljs-string">'div'</span>))
nodes.forEach(node =&gt; <span class="hljs-built_in">console</span>.log(node))</code></pre>
<h2 id="arrayof"><a href="#arrayof" class="phenomic-HeadingAnchor">#</a>Array.of()</h2>
<p>Cette méthode va permettre de créer un tableau à partir des arguments reçus.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.of(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)
<span class="hljs-built_in">console</span>.log(arr.join(<span class="hljs-string">" "</span>)) <span class="hljs-comment">// "hello world"</span></code></pre>
<h2 id="arrayprototypekeys--arrayprototypeentries"><a href="#arrayprototypekeys--arrayprototypeentries" class="phenomic-HeadingAnchor">#</a>Array.prototype.keys() &amp; Array.prototype.entries()</h2>
<p>On retrouve aussi ces méthodes sur d&#x27;autres itérables comme Map ou Set.
<code>Array.prototype.keys()</code> va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau passées en paramètre :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr =  [...Array(<span class="hljs-number">3</span>).keys()]
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [0,1,2]</span></code></pre>
<p><code>Array.prototype.entries()</code> quant à lui va renvoyer un tableau composé des paires clé/valeur :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>]
<span class="hljs-built_in">console</span>.log(arr.entries()) <span class="hljs-comment">// [[0, "hello"], [1, "world"]]</span></code></pre>
<h2 id="arrayprototypefind"><a href="#arrayprototypefind" class="phenomic-HeadingAnchor">#</a>Array.prototype.find()</h2>
<p>Cette méthode va permettre de renvoyer une valeur contenue dans le tableau si celle-ci vérifie
la condition définie par la fonction de prédicat passée en paramètre. On retrouve le même principe qu&#x27;avec <code>filter</code>, <code>some</code> et <code>every</code>. Si aucune valeur ne
valide la fonction de prédicat, alors la méthode renverra <code>undefined</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [{id:<span class="hljs-number">1</span>, label:<span class="hljs-string">"hello"</span>}, {id:<span class="hljs-number">2</span>, name: <span class="hljs-string">"world"</span>}]
<span class="hljs-keyword">const</span> found = arr.find(item =&gt; item.id === <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> notfound = arr.find(item =&gt; item.id === <span class="hljs-number">3</span>)
<span class="hljs-built_in">console</span>.log(found, notfound) <span class="hljs-comment">// {id:2, name: "worl"}, undefined</span></code></pre>
<p>À noter qu&#x27;il existe aussi <code>Array.prototype.findIndex()</code> qui renverra non pas l&#x27;objet, mais l&#x27;index de l&#x27;objet qui validera la fonction de prédicat.</p>
<h2 id="arrayprototypefill"><a href="#arrayprototypefill" class="phenomic-HeadingAnchor">#</a>Array.prototype.fill()</h2>
<p>Cette méthode va permettre de remplir un tableau avec une valeur passée en paramètre. Il est toutefois possible de définir un index de début et un index de fin (comme avec slice par exemple) si l&#x27;on ne souhaite remplacer qu&#x27;une partie du tableau.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).fill(<span class="hljs-number">1</span>)
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [1,1,1]</span></code></pre>
<h2 id="arrayprototypecopywithin"><a href="#arrayprototypecopywithin" class="phenomic-HeadingAnchor">#</a>Array.prototype.copyWithin()</h2>
<p>Cette méthode va permettre de renvoyer un nouveau tableau en remplaçant une partie du tableau par une séquence de ce dernier. Pour cela, on va indiquer à partir de quel index on souhaite démarrer la copie de la séquence, ainsi que l&#x27;index de début et de fin de la séquence que l&#x27;on souhaite voir répétée.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>,<span class="hljs-string">"alice"</span>, <span class="hljs-string">"my"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"is"</span> <span class="hljs-string">"bob"</span>]
<span class="hljs-built_in">console</span>.log(arr.copyWithin(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]) <span class="hljs-comment">//  "hello","bob", "my", "name", "is" "bob"]</span></code></pre>
<p>Certaines méthodes ne paraissent pas forcément super utiles alors n&#x27;hésitez à utiliser les commentaires pour partager des exemples d&#x27;utilisation plus intéressants 😛</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</guid><pubDate>Sun, 13 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : paramètres rest et opérateur spread]]></title><description><![CDATA[<p>Identiques en apparence et en syntaxe, ils permettent d&#x27;effectuer plus
simplement des opérations complexes sur les tableaux, ou tout autre objet
itérable.</p>
<h2 id="les-paramtres-rest"><a href="#les-paramtres-rest" class="phenomic-HeadingAnchor">#</a>Les paramètres rest</h2>
<p>Avez-vous déjà eu l&#x27;occasion d&#x27;utiliser l&#x27;horrible variable magique <code>arguments</code> ?
Disponible au sein de chaque fonction, elle permet d&#x27;en récupérer, comme son
nom l&#x27;indique, les arguments. Si l&#x27;objet récupéré est similaire à un <code>Array</code>,
il ne dispose d&#x27;aucune des propriétés ou des méthodes de celui-ci, à
l&#x27;exception de <code>length</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">separator</span>) </span>{
  <span class="hljs-comment">// conversion nécessaire en objet de type Array</span>
  <span class="hljs-keyword">var</span> words = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> words.join(separator)
}

myFunction(<span class="hljs-string">"-"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>) <span class="hljs-comment">// "foo-bar"</span></code></pre>
<p>Les paramètres rest vous permettent de récupérer un véritable <code>Array</code> à l&#x27;aide
du simple préfixe <code>...</code> appliqué sur le <strong>dernier</strong> argument de votre fonction.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">separator, ...words</span>) </span>{
  <span class="hljs-keyword">return</span> words.join(separator)
}

myFunction(<span class="hljs-string">"-"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>) <span class="hljs-comment">// "foo-bar"</span></code></pre>
<p>Il vous sera en revanche impossible de lui attribuer une <a href="/fr/articles/js/es2015/defaults/">valeur par défaut</a>.</p>
<h2 id="loprateur-spread"><a href="#loprateur-spread" class="phenomic-HeadingAnchor">#</a>L&#x27;opérateur spread</h2>
<p>Aussi appelé opérateur de décomposition, il permet de développer un objet
itérable (comme un <code>Array</code>) lorsqu&#x27;on a besoin de plusieurs arguments.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">1991</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(...myArray) <span class="hljs-comment">// object Date - équivaut à: new Date(1991, 8, 1)</span>

<span class="hljs-keyword">const</span> myString = <span class="hljs-string">"foo bar"</span>
<span class="hljs-comment">// les objets String étant itérables</span>
[...myString] <span class="hljs-comment">// ["f", "o", "o", " ", "b", "a", "r"]</span></code></pre>
<p>À noter que contrairement aux paramètres rest, l&#x27;opérateur spread peut être
mélangé aux autres arguments d&#x27;une fonction.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">8</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1991</span>, ...myArray, <span class="hljs-number">12</span>) <span class="hljs-comment">// object Date - équivaut à: new Date(1991, 8, 1, 12)</span></code></pre>
<p>Les possibilités offertes par cette nouveauté sont très nombreuses. Voici
quelques usages un peu plus avancés pour stimuler votre inspiration :</p>
<h4 id="viter-lutilisation-de-apply"><a href="#viter-lutilisation-de-apply" class="phenomic-HeadingAnchor">#</a>Éviter l&#x27;utilisation de .apply()</h4>
<pre><code class="hljs language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>])

<span class="hljs-comment">// ES6 / ES2015</span>
<span class="hljs-built_in">console</span>.log(...[<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>]) <span class="hljs-comment">// même résultat</span></code></pre>
<h4 id="concatner-plusieurs-itrables"><a href="#concatner-plusieurs-itrables" class="phenomic-HeadingAnchor">#</a>Concaténer plusieurs itérables</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> stronglyTyped = [<span class="hljs-string">"scala"</span>, <span class="hljs-string">"haskell"</span>]

<span class="hljs-comment">// ES5</span>
[<span class="hljs-string">"go"</span>, <span class="hljs-string">"rust"</span>].concat(stronglyTyped) <span class="hljs-comment">// ["go", "rust", "scala", "haskell"]</span>

<span class="hljs-comment">// ES6 / ES2015</span>
[<span class="hljs-string">"go"</span>, <span class="hljs-string">"rust"</span>, ...stronglyTyped] <span class="hljs-comment">// ["go", "rust", "scala", "haskell"]</span></code></pre>
<h4 id="dstructurer-dans-un-tableau"><a href="#dstructurer-dans-un-tableau" class="phenomic-HeadingAnchor">#</a>Déstructurer dans un tableau</h4>
<p>Si vous n&#x27;avez pas encore connaissance des possibilités offertes par le
destructuring, je vous invite à lire ce <a href="/fr/articles/js/es2015/destructuring/">précédent article</a>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"baz"</span>]

<span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">const</span> first = words[<span class="hljs-number">0</span>] <span class="hljs-comment">// "foo"</span>
<span class="hljs-keyword">const</span> rest = words.slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// ["bar", "baz"]</span>

<span class="hljs-comment">// ES6 / ES2015</span>
<span class="hljs-keyword">const</span> [first, ...rest] = words <span class="hljs-comment">// même résulat</span></code></pre>
<h4 id="itrer-sur-le-rsultat-dun-queryselectorall"><a href="#itrer-sur-le-rsultat-dun-queryselectorall" class="phenomic-HeadingAnchor">#</a>Itérer sur le résultat d&#x27;un .querySelectorAll()</h4>
<pre><code class="hljs language-js">[...document.querySelectorAll(<span class="hljs-string">'div'</span>)] <span class="hljs-comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></code></pre>
<h2 id="en-rsum"><a href="#en-rsum" class="phenomic-HeadingAnchor">#</a>En résumé</h2>
<p>Comme vous avez pu le constater par vous-même, les cas d&#x27;utilisation des
paramètres rest et de l&#x27;opérateur spread sont légion.</p>
<p><a href="http://kangax.github.io/compat-table/es6/#spread_(...)_operator">Gérés</a>
correctement par Babel et Traceur, ils vous permettront de rendre votre code
plus concis en évitant bien souvent l&#x27;écriture de boucles inutiles.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/rest-spread/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/rest-spread/</guid><pubDate>Sat, 12 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les Maps & WeakMaps]]></title><description><![CDATA[<h2 id="maps"><a href="#maps" class="phenomic-HeadingAnchor">#</a>Maps</h2>
<p>Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c&#x27;est que n&#x27;importe quelle valeur peut être utilisée comme clé.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
myMap.set(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>)
myMap.get(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// 1</span></code></pre>
<p>Pour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [ <span class="hljs-number">1</span>, <span class="hljs-string">"foo"</span> ],
  [ <span class="hljs-built_in">window</span>, <span class="hljs-string">"bar"</span> ],
])</code></pre>
<p>Pour tester si une clé est présente, on peut utiliser la méthode <code>has</code> :</p>
<pre><code class="hljs language-javascript">map.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span></code></pre>
<p>On peut itérer sur les entrées d&#x27;une map à l&#x27;aide de <code>forEach</code> :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [ <span class="hljs-number">1</span>, <span class="hljs-string">"foo"</span> ],
  [ <span class="hljs-built_in">window</span>, <span class="hljs-string">"bar"</span> ],
])

myMap.forEach((value, key) =&gt; {
	<span class="hljs-comment">// do something</span>
})</code></pre>
<p>On peut aussi itérer à l&#x27;aide du <code>for … of</code> :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) {
  <span class="hljs-built_in">console</span>.log(key, value)
}</code></pre>
<p>Ainsi que convertir la map en tableau à l&#x27;aide du spread, puisqu&#x27;une map est itérable :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myEntries = [...myMap] <span class="hljs-comment">// […[key, value]]</span>
<span class="hljs-keyword">const</span> myEntries = [...myMap.entries()] <span class="hljs-comment">// alternativement</span></code></pre>
<p>On peut aussi récupérer des itérables par clés et valeurs :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKeys = [...myMap.keys()]
<span class="hljs-keyword">const</span> myValues = [...myMap.values()]</code></pre>
<p>Particularité, la valeur <code>NaN</code>, qui en JS n&#x27;est pas égale à elle même, est bien gérée :</p>
<pre><code class="hljs language-javascript">myMap.set(<span class="hljs-literal">NaN</span>, <span class="hljs-number">1</span>)
myMap.get(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// 1</span></code></pre>
<p>Une utilisation possible des Maps est la fonction <code>dedupe</code> pour éliminer les doublons d&#x27;un array :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> dedupe = (array) =&gt; {
  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Map</span>(array.map((item) =&gt; [item, <span class="hljs-literal">true</span>])).keys()]
}

dedupe([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment">// [1, 2, 3, 4]</span></code></pre>
<h2 id="weakmaps"><a href="#weakmaps" class="phenomic-HeadingAnchor">#</a>WeakMaps</h2>
<p>Les WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs &quot;oubliées&quot;. Le garbage collector ne tient donc pas compte des weak maps.</p>
<p>Les WeakMaps ne possèdent pas de méthodes d&#x27;itération et n&#x27;acceptent pas de valeurs primitives comme clés.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()
myWeakMap.set(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// TypeError</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()
myWeakMap.set(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>)
(() =&gt; {
  <span class="hljs-keyword">const</span> object = {}
  myWeakMap.set(object, <span class="hljs-number">2</span>)
})()
<span class="hljs-comment">// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible</span>
<span class="hljs-comment">// seule la clé `window` persiste.</span></code></pre>
<p>Un usage possible est le stockage d&#x27;informations lié à une instance de classe, permettant de &quot;cacher&quot; cette information de l&#x27;instance :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> callbacks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleEventEmitter</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    callbacks.set(<span class="hljs-keyword">this</span>, [])
  }
  addEventListener(callback) {
    callbacks.set(<span class="hljs-keyword">this</span>, callbacks.get(<span class="hljs-keyword">this</span>).concat(callback))
  }
  removeEventListener(callback) {
    callbacks.set(<span class="hljs-keyword">this</span>, callbacks.get(<span class="hljs-keyword">this</span>)
      .filter((func) =&gt; func !== callback))
  }
  triggerEvent(...args) {
    callbacks.get(<span class="hljs-keyword">this</span>).forEach((func) =&gt; func(...args))
  }
}</code></pre>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/</guid><pubDate>Fri, 11 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : iterators and generators]]></title><description><![CDATA[<p>ES2015 brings a lot of syntax sugar but not a lot of new real features.
Generators are a new feature to generate iterators that follow the
<a href="/en/articles/js/es2015/iterators/">iterator protocol</a>.
They allow to take control of the execution of a function from the outside.</p>
<h2 id="idle-function"><a href="#idle-function" class="phenomic-HeadingAnchor">#</a>Idle function</h2>
<p>A function followed by an asterisk (<code>function*</code>) is never executed directly
and instead calling it will return an iterator.
A generator is able to pause itself (and will do that by default).
It&#x27;s also capable of continue where it was paused: the iterator returned is an
object that contains a <code>next</code> method which allows (when you call it) to
continue the execution of the generator where it was paused.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// The execution is paused, and is waiting to be continued</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// The execution will now continue and will log "World"</span></code></pre>
<p>Note that this is not <strong>blocking</strong> code: the function is paused, the execution
can continue later, but meanwhile, the <em>event-loop</em> is still running.</p>
<h2 id="emitting-new-values-with-yield"><a href="#emitting-new-values-with-yield" class="phenomic-HeadingAnchor">#</a>Emitting new values with <code>yield</code></h2>
<p>Following the <a href="/en/articles/js/es2015/iterators/">iterator protocol</a>, the
<code>next()</code> method will returns an object with 2 properties :</p>
<ul>
<li><code>done</code> is equal to <code>true</code> when generator has finished its job exécution</li>
<li><code>value</code> is the value emitted by the generator when it become idle</li>
</ul>
<p>How to emit a value ? The keyword <code>yield</code> is made for this:
it will returns a value and idle the execution of the function.
The thing is: you are going to use yield multiple times in the same function.
Otherwise a generator does not make sense, and a simple function with <code>return</code>
is enough.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note: if our generator <code>return</code>s a value, it will be affected to the <code>value</code>
of the last iteration.</p>
<h3 id="use-case-infinite-lists"><a href="#use-case-infinite-lists" class="phenomic-HeadingAnchor">#</a><em>Use case</em> : infinite lists</h3>
<p>At this stage, the first interesting use case is to handle an infinite list.
We can loop on a list that do not have a precise length.
Here is an example with the Fibonacci sequence to get all results lower than
100 :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note : The <code>for … of</code> will be explained in another article.</p>
<h2 id="sending-value-to-the-generator"><a href="#sending-value-to-the-generator" class="phenomic-HeadingAnchor">#</a>Sending value to the generator</h2>
<p>We have seen that <code>yield</code> allows to emit a value from the generator.
The opposite is possible too : <code>next</code> accepts a value that will be returned by
<code>yield</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// the first next() will "start" the generator</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// the first value will be undefined</span>
  <span class="hljs-comment">// x = the argument of the other next() call</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// value of the second iteration : x + 1</span>
  <span class="hljs-comment">// y = third call of next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// value of the last iteration : y</span>
  <span class="hljs-comment">// the fourth call and the others will return { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le générateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le générateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le générateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>This might sound not really useful, but keep in mind that you can send any type
of data to <code>next()</code> : a function, an object, another iterator...
Possiblities are limitless ! Let&#x27;s take a look to an example using promises.</p>
<h3 id="use-case-co-routines"><a href="#use-case-co-routines" class="phenomic-HeadingAnchor">#</a><em>Use case</em> : co-routines</h3>
<p>The code of the generator itself cannot be async: call to <code>yield</code> follow each
others synchronously.
The main controller can still be free to call <code>next()</code> when it wants to.</p>
<p>So we have functions that we can play and pause whenever we want.
What if our generator emitted a promise? In order to tell when it&#x27;s time to
continue.
What if the controller, when it knows it got a promise wait for it to be
resolved in order to send back the value to the generator?
This way, the generator will be able to run synchronous code in an non blocking
way when handling async operations :</p>
<pre><code class="hljs language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request…"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work…"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save…"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request… Work… Save… OK.</span></code></pre>
<p>How cool is that? This is clearly the most interesting use case for us and is
actually pretty simple :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// pause…</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// That's the part to detect the last return</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// this is a generator of promise, we we wait for the resolution</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// promise is resolved so we can send back the value to the generator</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// this value is returned by the</span>
      <span class="hljs-comment">// same "yield" which emitted the promise, how convenient is that?</span>

      <span class="hljs-comment">// NEXXXTTTT</span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next()
  <span class="hljs-comment">// we continue the execution until the next "yield"</span>
  <span class="hljs-comment">// the generator will be paused again until the next call to "iter.next"</span>

  <span class="hljs-comment">// We run the first iteration it and return it</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a href="#more-more-more" class="phenomic-HeadingAnchor">#</a>More! more! more!</h2>
<h3 id="error-handling"><a href="#error-handling" class="phenomic-HeadingAnchor">#</a>Error handling</h3>
<p>Errors, like everything, can be emitted in both directions.
The generator can <code>throw</code> (the code is synchronous) :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>The controller can also emit an error inside with the <code>throw</code> method of the
iterator :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note: you need to keep in mind that the first <code>next</code> is used to unlock
the execution of the generator, until the first <code>yield</code>, evaluate the emitted
expression, and send it in the <code>next()</code>, and pause the function.
That&#x27;s the second <code>yield</code> that will continue <strong>from the <code>yield 1</code></strong>.
This is a part not really intuitive that can be hard to understand.</p>
<h3 id="delegation"><a href="#delegation" class="phenomic-HeadingAnchor">#</a>Delegation</h3>
<p>The <code>yield*</code> operator allow to emit value from another iterator :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>That works with all <a href="/en/articles/js/es2015/iterators/"><em>iterables</em></a> :
for example <code>yield * [1, 2, 3]</code> is valid.</p>
<h3 id="anticipated-return"><a href="#anticipated-return" class="phenomic-HeadingAnchor">#</a>Anticipated return</h3>
<p>It&#x27;s possible to end an operation of a generator from the controller using the
<code>return</code> method of the iterator.
Everything will happen like if the generator was ending immediately with the
returned value.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-generators">compatibility table</a>.</p>
<p>Generators bring us a new bundle of feature that allow us to inverse
responsibility : the code that calling the generator can take over the way the
called function will be executed.
They represent a new concept that will probably really change the way we will
code in the incoming months/years :
async function, observables... take their roots in generators.
Understanding generators will helps you to work with those other new features.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : itérateurs et générateurs]]></title><description><![CDATA[<p>Un gros morceau aujourd&#x27;hui : les itérateurs et les fonctions qui les génèrent,
appelées &quot;générateurs&quot;.
ES6/2015 apporte énormément de &quot;sucres syntaxiques&quot;, même s&#x27;ils sont
terriblement pratiques. Les valeurs par défaut, l&#x27;affectation par
déstructuration, les fonctions flêchées…
Tout ça n&#x27;apporte pas de réelle nouvelle fonctionnalité.
C&#x27;est un peu différent pour les générateurs qui vont permettre de prendre le
contrôle sur l&#x27;éxécution d&#x27;une fonction depuis l&#x27;extérieur.</p>
<h2 id="fonction-en-pause"><a href="#fonction-en-pause" class="phenomic-HeadingAnchor">#</a>Fonction &quot;en pause&quot;</h2>
<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par
l&#x27;astérisque n&#x27;est jamais exécutée directement, à la place, elle retourne un
<em>itérateur</em>. Un générateur est donc capable de s&#x27;interrompre (d&#x27;ailleurs, il
l&#x27;est par défaut).
Il est également capable de reprendre là où il s&#x27;était arrêté :
l&#x27;itérateur retourné est un objet exposant une méthode  <code>next</code> qui
lorsqu&#x27;elle est appelée demande au générateur de reprendre là où il en était.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// L'exécution de la fonction est interrompue en attente d'être "débloquée"</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// L'éxécution reprend et on affiche "World"</span></code></pre>
<p>Notez qu&#x27;il ne s&#x27;agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,
son traitement sera repris plus tard, pendant ce temps l&#x27;<em>event-loop</em> continue
sa petite vie.</p>
<h2 id="reprise-du-traitement-et-mission-de-valeur-avec-yield"><a href="#reprise-du-traitement-et-mission-de-valeur-avec-yield" class="phenomic-HeadingAnchor">#</a>Reprise du traitement et émission de valeur avec <code>yield</code></h2>
<p>La méthode <code>next()</code> de l&#x27;itérateur retourne un objet possédant les propriétés
suivantes :</p>
<ul>
<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>
<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>
</ul>
<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir
une valeur et de remettre en pause l&#x27;exécution de la fonction. Le principe étant
qu&#x27;on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement
<code>return</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la
propriété <code>value</code> de la dernière itération.</p>
<h3 id="use-case-listes-infinies"><a href="#use-case-listes-infinies" class="phenomic-HeadingAnchor">#</a><em>Use case</em> : listes infinies</h3>
<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de
longueur non définie à l&#x27;avance. On peut parcourir une suite dont on ne sait pas
à l&#x27;avance <em>combien</em> d&#x27;éléments on veut, par exemple récupérer tous les éléments
de la suite de Fibonacci inférieurs à 100 :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note : l&#x27;opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>
<h2 id="passage-de-valeur-au-gnrateur"><a href="#passage-de-valeur-au-gnrateur" class="phenomic-HeadingAnchor">#</a>Passage de valeur au générateur</h2>
<p>On a vu que <code>yield</code> permettait d&#x27;émettre une valeur depuis le générateur vers
le code contrôleur. Mais le sens inverse est également possible : la méthode
<code>next</code> de l&#x27;itérateur accepte une valeur en paramètre, qui sera alors
retournée par l&#x27;appel correspondant à <code>yield</code>. Exemple :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Le premier appel à next() permet de "démarrer" le générateur</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// la valeur de la première itération sera undefined</span>
  <span class="hljs-comment">// x = le paramètre du second appel à next()</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// valeur de la seconde itération : x + 1</span>
  <span class="hljs-comment">// y = paramètre du troisième appel à next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// valeur de la troisième itération : y</span>
  <span class="hljs-comment">// le 4e appel (et +) à next() retournent { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le générateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le générateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le générateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>
n&#x27;importe quel type de donnée : une fonction, un objet, un autre itérateur… Les
possibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>
<h3 id="use-case-co-routines"><a href="#use-case-co-routines" class="phenomic-HeadingAnchor">#</a><em>Use case</em> : co-routines</h3>
<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à
<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est
libre d&#x27;appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>
<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et
quand elles peuvent reprendre leur traitement. Et si… notre générateur émettait
des promesses ? Histoire d&#x27;expliquer à son code contrôleur <em>quand</em> il est sûr de
reprendre le traitement. Et si ce code contrôleur, voyant qu&#x27;il récupère une
promesse, attendait que cette dernière soit résolue pour transmettre au
générateur en retour la valeur résolue ? Dans ce cas le générateur pourrait
disposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de
traitements asynchrones :</p>
<pre><code class="hljs language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request…"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work…"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save…"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request… Work… Save… OK.</span></code></pre>
<p>Ne serait-ce pas merveilleux ? C&#x27;est le <em><em>use case</em></em> le plus intéressant pour
nous au quotidien, et c&#x27;est assez simple en fait :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// en pause…</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// Le générateur a return'é, fin du game</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// c'est un générateur de promesse, dont on attend la résolution ici</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// La promesse est résolue, on peut repasser sa valeur au générateur</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// cette valeur est return'ée par</span>
      <span class="hljs-comment">// le même "yield" qui a émis la promesse, ça tombe bien :)</span>

      <span class="hljs-comment">// Puis on relance notre boucle, et on continue récursivement</span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next() <span class="hljs-comment">// exécution reprise jusqu'au prochain "yield"</span>
  <span class="hljs-comment">// le générateur est remis en pause jusqu'au prochain appel à "iter.next"</span>

  <span class="hljs-comment">// Première itération de la boucle</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a href="#more-more-more" class="phenomic-HeadingAnchor">#</a>More! more! more!</h2>
<h3 id="gestion-derreur"><a href="#gestion-derreur" class="phenomic-HeadingAnchor">#</a>Gestion d&#x27;erreur</h3>
<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux
directions. Le générateur peut <code>throw</code> vers le code contrôleur (le code est
synchrone) :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>Mais le code contrôleur peut également émettre une erreur vers le générateur
avec la méthode <code>throw</code> de l&#x27;itérateur :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// affiche "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>
l&#x27;exécution du générateur, qui va alors jusqu&#x27;au premier <code>yield</code>, évalue
l&#x27;expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en
pause. C&#x27;est au second <code>yield</code> seulement que l&#x27;exécution reprend <strong>à partir de
<code>yield 1</code></strong>. C&#x27;est une partie que je trouve contre-intuitive et que j&#x27;ai eu du
mal à assimiler.</p>
<h3 id="dlgation"><a href="#dlgation" class="phenomic-HeadingAnchor">#</a>Délégation</h3>
<p>L&#x27;opérateur <code>yield*</code> permet d&#x27;émettre les valeurs d&#x27;un autre itérateur, par
exemple :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>Cela fonction bien sûr avec tous
<a href="/fr/articles/js/es2015/iterators/">les <em>itérables</em></a> :
<code>yield * [1, 2, 3]</code> est valide par exemple.</p>
<h3 id="retour-anticip"><a href="#retour-anticip" class="phenomic-HeadingAnchor">#</a>Retour anticipé</h3>
<p>Il est possible de terminer le traitement d&#x27;un générateur depuis le code
contrôleur avec la méthode <code>return</code> de l&#x27;itérateur. Tout se passera comme si
le générateur se terminait immédiatement avec la valeur de retour fournie.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Un habituel petit coup d&#x27;œil sur <a href="https://kangax.github.io/compat-table/es6/#test-generators">la compatibilité</a> :</p>
<ul>
<li>Les navigateurs modernes (donc pas IE)</li>
<li>IE Edge ≥ 13</li>
<li>Niveau polyfill, c&#x27;est vers Babel ou Traceur qu&#x27;il faudra se tourner</li>
</ul>
<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent
d&#x27;inverser la responsabilité : c&#x27;est le code appelant qui prend le pouvoir sur
la façon dont va s&#x27;exécuter la fonction appelée. Ils représentent le premier pas
vers d&#x27;autres concepts qui bouleverseront probablement votre façon de coder dans
quelques mois/années : fonctions asynchrones, observables… prennent leurs
racines dans les générateurs. Les comprendre permettra de mieux appréhender de
futures fonctionnalités.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Iteration protocol]]></title><description><![CDATA[<p>Imagine something so big, that if you remove it from the language, you will need
to remove lots of others features like spread operator, destructuring,
generators, for of...
This thing is just a protocol: the iterator protocol.</p>
<p>The principle is just a convention in the language which allow to standardise
how we can iterate on some data.</p>
<p>First good news, this protocol is pretty simple to understand and use 2
&quot;interfaces&quot; (quotes are just to warn you that we cannot really call that
<em>Interface</em>, since we don&#x27;t have this &quot;thing&quot; in JavaScript).</p>
<p>The first interface, <strong>Iterator</strong>, allow to an object to produce sequences of
values. An object is an iterator when it implements a <code>next()</code> function
which return an object that contains two properties :</p>
<ul>
<li><code>value</code>: current value of the current execution</li>
<li><code>done</code> : a boolean that indicates whether the iteration is finished or not</li>
</ul>
<p>Successif calls of the <code>next()</code> method of an iterator will allow to get all
the value of an object.
Let&#x27;s see how we can iterate on a simple array <code>[&quot;a&quot;, &quot;b&quot;]</code> :</p>
<pre><code class="hljs language-js">iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>So you will probably now ask &quot;How to get this Iterator?&quot;.
That&#x27;s the second interface,  <strong>Iterable</strong>.
An iterable object implements a particular method which is going to return an
iterator.
This method (called <em>@@iterator</em> in the spec) must be defined using the
Symbol <code>[Symbol.iterator]</code>.
(Symbol will be explained in a dedicated).</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iteratorArray = arr[<span class="hljs-built_in">Symbol</span>.iterator]()
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>Now you know how to use the array iterator implementation.
Not really useful right?
Here is another example to loop on an array following this protocol :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iterator = arr[<span class="hljs-built_in">Symbol</span>.iterator]()

<span class="hljs-keyword">const</span> result = iterator.next()
<span class="hljs-keyword">while</span> (!result.done) {
  <span class="hljs-built_in">console</span>.log(result.value)
  result = iterator.next()
}
<span class="hljs-comment">// 'a'</span>
<span class="hljs-comment">// 'b'</span></code></pre>
<p>Let&#x27;s recap: when an object which implements the iteration protocol is traversed
its <em>@@iterator</em> method is called once and the iterator is returned to be used
to loop an all values.</p>
<h1 id="iterable-consumers"><a href="#iterable-consumers" class="phenomic-HeadingAnchor">#</a>Iterable consumers</h1>
<p>Second good new is that a lots of concept of JavaScript benefits of this
protocol :</p>
<ul>
<li>Some syntaxes expect to get iterables</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// for...of has been precisely made to loop on custom iterables</span>
<span class="hljs-keyword">for</span> (val <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(val)
}

<span class="hljs-comment">// spred operator will use it too</span>
[<span class="hljs-string">'0'</span>, ...arr, <span class="hljs-string">'1'</span>] <span class="hljs-comment">// 0, a, b, 1</span>

<span class="hljs-comment">// yield also needs an iterator</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">yield</span>* arr
}
gen().next() <span class="hljs-comment">// { value:"a", done:false }</span>

<span class="hljs-comment">// same for destructuring</span>
<span class="hljs-keyword">const</span> [x, y] = arr <span class="hljs-comment">// x = 'a',  y = "b"</span></code></pre>
<ul>
<li>Some APIs acccepts iterables</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// Set and Weakset accepts iterables</span>
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)
set.has(<span class="hljs-string">"b"</span>) <span class="hljs-comment">// true</span>
<span class="hljs-comment">// same for Map and WeakMap</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr.entries()) <span class="hljs-comment">// Not that a (weak)map needs a [key, value] combo</span>
map.get(<span class="hljs-number">0</span>) <span class="hljs-comment">// 'a'</span>


<span class="hljs-comment">// MOAR APIs</span>

<span class="hljs-built_in">Array</span>.from(iterable) <span class="hljs-comment">// tunr anything into an array !</span>
<span class="hljs-built_in">Promise</span>.all(iterableCollectionDePromises) <span class="hljs-comment">// any iterable that will contains a set of Promises</span>
<span class="hljs-built_in">Promise</span>.race(iterableCollectionDePromises) <span class="hljs-comment">// same</span></code></pre>
<h1 id="built-in-iterable"><a href="#built-in-iterable" class="phenomic-HeadingAnchor">#</a>Built-in Iterable</h1>
<p>Third good news: a lot&#x27;s of objects already implement this protocol :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// obviously, arrays</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"l"</span>]
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> arr) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// strings too</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">"lol"</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> str) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// Map and Set (BUT NOT WeakMap and WeakSet)</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">'l'</span>, <span class="hljs-number">1</span>).set(<span class="hljs-string">'o'</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// ["l", 1]</span>
  <span class="hljs-comment">// ["o", 2]</span>
}
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>().add(<span class="hljs-string">'l'</span>).add(<span class="hljs-string">'o'</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
}

<span class="hljs-comment">// TypedArray that you use EVERY SINGLE DAYS</span>
<span class="hljs-keyword">const</span> int16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(<span class="hljs-number">2</span>)
int16[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> int16) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 42</span>
  <span class="hljs-comment">// 0</span>
}

<span class="hljs-comment">// Even the special `argument` object</span>
<span class="hljs-comment">// (that you will probably stop to use in es6, thanks to spread operator)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
    <span class="hljs-built_in">console</span>.log(v)
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
    <span class="hljs-comment">// 'l'</span>
  }
}
test(<span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'l'</span>)

<span class="hljs-comment">// NodeList returned by DOM APIs</span>
<span class="hljs-keyword">const</span> matches = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>)
<span class="hljs-keyword">for</span> (m <span class="hljs-keyword">of</span> matches) {
  <span class="hljs-built_in">console</span>.log(m)
  <span class="hljs-comment">// &lt;div id="topSection"&gt;</span>
  <span class="hljs-comment">// &lt;div id="brandLogo"&gt;</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Another detail: Array, TypedArray, Map, Set are iterables but also define
methods which also return iterables (...Are you still with us ?) :</p>
<ul>
<li>entries() returns a set of key/values</li>
<li>keys() returns keys</li>
<li>values() returns values</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (cleVals <span class="hljs-keyword">of</span> arr.entries()) {
  <span class="hljs-built_in">console</span>.log(cleVals)
  <span class="hljs-comment">// [0, "l"]</span>
  <span class="hljs-comment">// [1, "o"]</span>
  <span class="hljs-comment">// [2, "l"]</span>
}</code></pre>
<p>Important note: <code>Object</code> is not an iterable (but we might get in ES2016
entries(), keys() and values() on <code>Object</code>
(<a href="https://github.com/tc39/proposal-object-values-entries">spec proposal</a>).</p>
<h1 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h1>
<p>We have seen that a lots of interesting syntaxes and features use the iterable
protocol, so we hope that you will use all of that in your libraries.
That&#x27;s important to rely on commons patterns so we can reach an agreement.</p>
<p>Libraries can do that by :</p>
<ul>
<li>offering data that implements this protocol</li>
<li>use this protocol directly (eg: for a sorting algorithm)</li>
</ul>
<h1 id="one-last-thing"><a href="#one-last-thing" class="phenomic-HeadingAnchor">#</a>One last thing...</h1>
<p>The following post will allow you to deep dive into this subject :</p>
<ul>
<li><a href="http://www.2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocols</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 in depth : iterators and the for of loop</a></li>
<li><a href="https://ponyfoo.com/articles/es6-iterators-in-depth">ES6 iterators in depth</a></li>
</ul>
<p>The practice remains the best way to train yourself, so take a look to
<a href="http://es6katas.org/">ES6 Katas</a> which has been made for that.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/iterators/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/iterators/</guid><pubDate>Wed, 09 Dec 2015 00:00:00 GMT</pubDate></item></channel></rss>