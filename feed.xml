<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[putaindecode.io]]></title><description><![CDATA[putaindecode.io]]></description><link>http://putaindecode.io</link><generator>RSS for Node</generator><lastBuildDate>Tue, 19 Apr 2016 07:46:57 GMT</lastBuildDate><atom:link href="http://putaindecode.io/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[D√©ploiement continu avec Travis-CI (et GitHub Pages)]]></title><description><![CDATA[<p>On va partir comme √ßa : on a un projet sur git et tous les commits dans la
branche <code>master</code> provoqueront une mise en production automatique une fois les
tests valid√©s.</p>
<p>Les autres commits sur les autres branches et pull/merge requests joueront juste
les tests pour notifier l&#x27;√©tat. Quand m√™me.</p>
<h2 id="cest-qui-travis"><a href="#cest-qui-travis" class="phenomic-HeadingAnchor">#</a>C&#x27;est qui Travis?</h2>
<p><a href="https://travis-ci.com/">Travis-CI</a> est un service en ligne qui permet de tester
et d√©ployer ses applications de mani√®re automatis√©e.</p>
<p>Ce service payant propose une solution gratuite √† tous les projets open source,
ce qui est assez cool. Cette version est disponible sur
<a href="https://travis-ci.org/">travis-ci.org</a>.
Il existe bien entendu plein d&#x27;autres services similaires, mais Travis-CI √©tant
tr√®s r√©pandu dans la communaut√© open source, on le prendra pour notre exemple.</p>
<h2 id="configuration-de-travis-ci"><a href="#configuration-de-travis-ci" class="phenomic-HeadingAnchor">#</a>Configuration de Travis-CI</h2>
<p>Travis-CI fonctionne avec un fichier de configuration assez simple. Il n&#x27;y a
qu&#x27;√† voir <a href="https://github.com/putaindecode/putaindecode.io/blob/master/.travis.yml">le
n√¥tre</a>.</p>
<p>Voici ci-dessous une version minimale pour faire tourner un projet node par
exemple :</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">language:</span> node_js</code></pre>
<p>Oui, c&#x27;est tout. Selon le language et/ou les fichiers pr√©sents,
Travis-CI va choisir la commande de test par d√©faut.
Avec node par exemple, ce sera <code>npm test</code> si un package.json est pr√©sent.
Si un <a href="/fr/articles/make/">Makefile</a> est de la partie, Travis-CI va ex√©cuter
<code>make test</code>.</p>
<p>Voici un fichier plus complet avec quelques exemples et trucs bons √† savoir.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">language:</span> node_js

<span class="hljs-attr">node_js:</span>
<span class="hljs-bullet">  -</span> <span class="hljs-string">'5'</span>
<span class="hljs-bullet">  -</span> ‚Äò<span class="hljs-number">4</span>‚Äô

<span class="hljs-comment"># √©choue d√®s qu'une erreur intervient</span>
<span class="hljs-attr">matrix:</span>
<span class="hljs-attr">  fast_finish:</span> <span class="hljs-literal">true</span>

<span class="hljs-comment"># met en cache node_modules, √† noter que dans ce genre d‚Äôutilisation pour des</span>
<span class="hljs-comment"># librairies open source consomm√©es via npm, il ne faudra pas oublier</span>
<span class="hljs-comment"># npm prune utilis√© ci-apr√®s, histoire de ne pas lancer des tests avec</span>
<span class="hljs-comment"># des paquets encore en cache mais non pr√©sents dans le package.json</span>
<span class="hljs-attr">cache:</span>
<span class="hljs-attr">  directories:</span>
<span class="hljs-bullet">    -</span> node_modules

<span class="hljs-attr">before_install:</span>
<span class="hljs-bullet">  -</span> npm prune

<span class="hljs-comment"># ici on peut mettre des commandes √† utiliser avec le script</span>
<span class="hljs-attr">before_script:</span>
  <span class="hljs-comment"># certains runners comme karma, testem ou testling peuvent avoir</span>
  <span class="hljs-comment"># besoin d'un √©cran pour fonctionner, voici l'astuce :)</span>
<span class="hljs-bullet">  -</span> export DISPLAY=:<span class="hljs-number">99.0</span>
<span class="hljs-bullet">  -</span> sh -e /etc/init.d/xvfb start

<span class="hljs-comment"># si on veut utiliser autre chose que la commande par d√©faut</span>
<span class="hljs-attr">script:</span> npm run test-with-coverage

<span class="hljs-comment"># voici un exemple de ce que l‚Äôon peut faire apr√®s les tests :</span>
<span class="hljs-comment"># on peut lancer une t√¢che qui va envoyer les informations de</span>
<span class="hljs-comment"># pourcentage de couverture de code √† un service tiers.</span>
<span class="hljs-comment"># (eg: http://coveralls.io/, https://codecov.io/)</span>
<span class="hljs-attr">after_success:</span> <span class="hljs-string">'npm run coverage'</span>

<span class="hljs-comment"># partie int√©ressante : ici on ne va d√©ployer que les commits sur la</span>
<span class="hljs-comment"># branche master uniquement pour une version de node</span>
<span class="hljs-comment"># (car sinon on d√©ploierait plusieurs fois‚Ä¶)</span>
<span class="hljs-attr">deploy:</span>
<span class="hljs-attr">  skip_cleanup:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">  provider:</span> script
<span class="hljs-attr">  script:</span> ./scripts/deploy.sh
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    branch:</span> master
<span class="hljs-attr">    node:</span> <span class="hljs-string">'5'</span>

<span class="hljs-comment"># variables d'env</span>
<span class="hljs-attr">env:</span>
<span class="hljs-attr">  global:</span>
<span class="hljs-bullet">    -</span> NODE_ENV=production</code></pre>
<h2 id="exemple-concret"><a href="#exemple-concret" class="phenomic-HeadingAnchor">#</a>Exemple concret</h2>
<p>On va prendre un petit projet simple en JavaScript qu‚Äôon va d√©ployer sur GitHub
Pages.
Il va donc nous falloir un token GitHub qu‚Äôon va encrypter via un utilitaire
sp√©cifique afin de ne pas publier cela √† la vue de tous.</p>
<h3 id="gnrer-un-token-github-encrypt-sur-travis-ci"><a href="#gnrer-un-token-github-encrypt-sur-travis-ci" class="phenomic-HeadingAnchor">#</a>G√©n√©rer un token GitHub encrypt√© sur Travis-CI</h3>
<p>Le plus simple est d‚Äôutiliser l&#x27;interface GitHub pour <a href="https://github.com/settings/tokens/new">ajouter un
token</a>.</p>
<h4 id="encryption-du-token"><a href="#encryption-du-token" class="phenomic-HeadingAnchor">#</a>Encryption du token</h4>
<p>Maintenant, nous allons encrypter ce token. Vous avez 2 possibilit√©s :</p>
<ul>
<li>soit installer le paquet node <code>travis-encrypt</code></li>
<li>soit installer la gem ruby <code>travis</code> (qui embarque la commande <code>encrypt</code>)</li>
</ul>
<h5 id="via-la-gem-ruby-travis"><a href="#via-la-gem-ruby-travis" class="phenomic-HeadingAnchor">#</a>Via la gem Ruby <code>travis</code></h5>
<pre><code class="hljs language-console">$ sudo gem install travis
$ travis encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>
<h5 id="via-le-paquet-node-travis-encrypt"><a href="#via-le-paquet-node-travis-encrypt" class="phenomic-HeadingAnchor">#</a>Via le paquet Node <code>travis-encrypt</code></h5>
<pre><code class="hljs language-bash">$ npm i -g travis-encrypt
$ travis-encrypt --add --repo {YOU/YOUR_REPO} GH_TOKEN={YOUR_TOKEN}</code></pre>
<p>Les 2 commandes devraient ajouter automatiquement le token encrypt√© dans votre
<code>.travis.yml</code> dans la section <code>env.global</code>.</p>
<pre><code class="hljs language-yml"><span class="hljs-comment"># ‚Ä¶</span>

<span class="hljs-attr">env:</span>
<span class="hljs-attr">  global:</span>
<span class="hljs-bullet">    -</span> NODE_ENV=production
    <span class="hljs-comment"># Ajouter un petit commentaire pour indiquer que c‚Äôest votre token GitHub</span>
    <span class="hljs-comment"># GITHUB_TOKEN</span>
    <span class="hljs-comment"># cela permettra, si vous avez d‚Äôautres variables encrypt√©es et</span>
que vous devez
    <span class="hljs-comment"># changer de token pour X raison(s), de savoir lequel supprimer</span>
<span class="hljs-attr">    - secure:</span> vqhHD....ROxGPQo= <span class="hljs-comment"># VOTRE TOKEN DOIT ETRE PAR LA</span>

    <span class="hljs-comment"># ici vous pouvez d√©finir en plus d'autres variables non encrypt√©es</span>
    <span class="hljs-comment"># qui seront r√©utilsables par la suite</span></code></pre>
<h3 id="utilisation-du-token-encrypt"><a href="#utilisation-du-token-encrypt" class="phenomic-HeadingAnchor">#</a>Utilisation du token encrypt√©</h3>
<h4 id="utilisation-dans-un-script"><a href="#utilisation-dans-un-script" class="phenomic-HeadingAnchor">#</a>Utilisation dans un script</h4>
<p>Imaginons que vous ayez un projet √† deployer sur GitHub Pages (exemple : vous
g√©n√©rez un site statique avec <a href="https://phenomic.io/">Phenomic</a>, le g√©n√©rateur
de site statique qu&#x27;on utilise).
Vous aller devoir g√©n√©rer votre projet, puis ensuite pousser le dossier g√©n√©r√©
sur votre branche <code>gh-pages</code>.</p>
<h4 id="utiliser-la-tche-de-dploiement-seulement-si-ncessaire"><a href="#utiliser-la-tche-de-dploiement-seulement-si-ncessaire" class="phenomic-HeadingAnchor">#</a>Utiliser la t√¢che de d√©ploiement seulement si n√©cessaire</h4>
<p>Travis-CI poss√®de une √©tape qui s&#x27;ex√©cute apr√®s le succ√®s des tests afin de
pouvoir faire un deploiement.</p>
<p><a href="https://docs.travis-ci.com/user/deployment/">https://docs.travis-ci.com/user/deployment/</a></p>
<p>Dans notre cas, on va choisir un provider tr√®s simple : un script bash.</p>
<p><strong>Par d√©faut, ceci sera execut√© pour tous les commits, sur toutes les
branches.</strong></p>
<p>On va donc devoir ajuster un peu le tir, car par exemple les commits sur
<code>gh-pages</code> ne doivent rien faire (d√©j√† pour √©viter la boucle infinie).
Il en sera de m√™me pour les commits sur d&#x27;autres branches de travail ainsi que
les pull/merge requests, comme on l‚Äôa vu dans le pr√©c√©dent exemple.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">deploy:</span>

  <span class="hljs-comment"># tr√®s important, on garde notre build, sans √ßa, nos fichiers build√©s</span>
  <span class="hljs-comment"># sont supprim√©s.</span>
<span class="hljs-attr">  skip_cleanup:</span> <span class="hljs-literal">true</span>

<span class="hljs-attr">  provider:</span> script
<span class="hljs-attr">  script:</span> ./scripts/deploy.sh

  <span class="hljs-comment"># ici on pose notre restriction</span>
<span class="hljs-attr">  on:</span>
<span class="hljs-attr">    branch:</span> master
<span class="hljs-attr">    node:</span> <span class="hljs-string">'5'</span></code></pre>
<h4 id="crire-notre-fameux-scriptsdeploysh"><a href="#crire-notre-fameux-scriptsdeploysh" class="phenomic-HeadingAnchor">#</a>√âcrire notre fameux <code>scripts/deploy.sh</code></h4>
<p>Dans le cas d‚Äôun d√©ploiement de dossier sur une branche <code>gh-pages</code>, on peut
faire de mani√®re assez simple avec le script suivant :</p>
<pre><code class="hljs language-sh"><span class="hljs-meta">#!/usr/bin/env bash
</span>
<span class="hljs-comment"># on lit GIT_DEPLOY_REPO ou si y‚Äòa pas on tente le package.json repository field</span>
<span class="hljs-comment"># (il faut une string et pas un objet dans ce cas)</span>
GIT_DEPLOY_REPO=${GIT_DEPLOY_REPO:-$(node <span class="hljs-_">-e</span>
<span class="hljs-string">'process.stdout.write(require("./package.json").repository)'</span>)}

<span class="hljs-comment"># on se d√©place dans le dossier de build</span>
<span class="hljs-built_in">cd</span> dist &amp;&amp; \
<span class="hljs-comment"># on repart sur un repo git vierge, pas besoin de versionner quelque chose qui</span>
<span class="hljs-comment"># se build</span>
$(npm bin)/rimraf .git
git init &amp;&amp; \
<span class="hljs-comment"># il faut quelques infos pour que git soit content</span>
git config user.name <span class="hljs-string">"Travis CI"</span> &amp;&amp; \
git config user.email <span class="hljs-string">"github@travis-ci.org"</span> &amp;&amp; \
<span class="hljs-comment"># on met tout dans git et on commit</span>
git add . &amp;&amp; \
git commit -m <span class="hljs-string">"Deploy to GitHub Pages"</span> &amp;&amp; \
<span class="hljs-comment"># puis on force push sur gh-pages</span>
git push --force <span class="hljs-string">"<span class="hljs-variable">${GIT_DEPLOY_REPO}</span>"</span> master:gh-pages</code></pre>
<h2 id="ya-plus-qu-"><a href="#ya-plus-qu-" class="phenomic-HeadingAnchor">#</a>Y&#x27;a plus qu&#x27;√† !</h2>
<p>Et voil√† ! On pousse un commit sur <code>master</code> et la magie devrait op√©rer !</p>
<p><em>Note: pour commiter sans d√©clencher un build sur Travis-CI, il suffit d&#x27;ajouter
<code>[ci skip]</code> dans votre message de commit. Pratique quand on modifie juste un
README par exemple.</em></p>
<p>Cette m√©thode est celle que nous utilisons pour g√©n√©rer et deployer notre site
statique. Et cela permet, par exemple, si quelqu&#x27;un corrige une typo depuis
l&#x27;interface en ligne de GitHub, de n&#x27;avoir rien d&#x27;autre √† faire que de &quot;merger&quot;
la correction
(et pour rappel : vous pouvez <strong>modifier</strong> n&#x27;importe quel article via le lien
situ√© plus bas).</p>
<p>Travis ex√©cutera nos tests, g√©n√®rera notre site si les tests sont bons et mettra
√ßa en production. Les mises en prod&#x27; le vendredi √† 19h45 ? M√™me pas peur.</p>
]]></description><link>http://putaindecode.io/fr/articles/ci/travis-ci/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/ci/travis-ci/</guid><pubDate>Tue, 19 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Angular 1.5 : un pas de plus vers les web-components]]></title><description><![CDATA[<p>Ce post a √©t√© √©crit √† la lumi√®re du
<a href="https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15">changelog d&#x27;Angular 1.5.0 rc1</a>.<br>
Toutes information est succeptible d&#x27;√©voluer au cours des publications de
nouvelles versions du framework.</p>
<h2 id="le-petit-nouveau--component"><a href="#le-petit-nouveau--component" class="phenomic-HeadingAnchor">#</a>Le petit nouveau : <code>.component()</code></h2>
<p>Avec l&#x27;arriv√©e imminente de la version 2, Angular commence lentement √† pr√©parer la
transition et apporte de nombreux changements √† la v1 pour tenter de
combler l&#x27;√©cart entre les deux et rendre les changements moins p√©nibles.</p>
<p>On voit donc progressivement apparaitre de nouvelles fonctionnalit√©s comme :</p>
<ul>
<li><del>un <a href="https://angular.github.io/router/">nouveau router</a> ?</del> </li>
<li>la possibilit√© d&#x27;<a href="https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests">annuler une resource</a></li>
<li>les transclusions multiples</li>
<li>la compilation paresseuse des transclusions</li>
</ul>
<p>Mais le point qui nous int√©resse particuli√®rement ici n&#x27;est autre que
le nouveau <em>helper</em> permettant la d√©claration de similis
<a href="https://fr.wikipedia.org/wiki/Composants_web">composants web</a>, aka web-components.</p>
<p>Les habitu√©s connaissaient d√©j√† <a href="https://docs.angularjs.org/api/ng/service/$compile"><code>angular.directive()</code></a>,
un <em>helper</em> permettant la d√©claration de composants r√©utilisables.
<code>angular.directive()</code> s&#x27;est donc enrichi au cours des ann√©es en faisant un atout
incontournable du framework de par sa flexibilit√© et sa simplicit√©.</p>
<p>Mais toutes ces possibilit√©s de d√©claration n&#x27;√©taient plus vraiment en phase avec
les sp√©cifications du W3C, <code>angular.component()</code> se pr√©sente donc un retour aux sources.</p>
<h2 id="de-directive--component"><a href="#de-directive--component" class="phenomic-HeadingAnchor">#</a>De <code>.directive()</code> √† <code>.component()</code></h2>
<p>Pour comprendre √† quoi on arrive, il faut savoir de quoi on est parti.
De toute √©vidence vous ne pourrez pas transformer toutes vos vieilles directives
en composants web, du moins, pas sans compromis.</p>
<p>Pour rappel une directive Angular est d√©finie par un objet JavaScript pouvant comporter
les attributs suivants :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> directiveObj = {
  template          : <span class="hljs-string">'&lt;div&gt;&lt;/div&gt;'</span>,
  transclude        : <span class="hljs-literal">false</span>,
  restrict          : <span class="hljs-string">'EA'</span>,
  scope             : <span class="hljs-literal">false</span>,
  bindToController  : <span class="hljs-literal">false</span>,
  controller        : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ },
  controllerAs      : <span class="hljs-string">'stringIdentifier'</span>,
}</code></pre>
<h3 id="restriction--la-forme-lmentaire"><a href="#restriction--la-forme-lmentaire" class="phenomic-HeadingAnchor">#</a>Restriction √† la forme √©l√©mentaire</h3>
<p>Ceux qui utilisent les directives Angular de mani√®re r√©guli√®re ne sont pas sans savoir
qu&#x27;il est possible de les instancier de 4 mani√®res diff√©rentes dans son HTML en
modifiant l&#x27;attribut <code>restrict</code> :</p>
<ul>
<li>comme un √©l√©ment avec <code>restrict : &#x27;E&#x27;</code></li>
<li>comme un attribut avec <code>restrict : &#x27;A&#x27;</code></li>
<li>comme une classe avec <code>restrict : &#x27;C&#x27;</code> (d√©conseill√©)</li>
<li>comme un commentaire avec <code>restrict : &#x27;M&#x27;</code> (fortement d√©conseill√©)</li>
</ul>
<p>On peut aussi autoriser l&#x27;utilisation mixe en combinant les lettres : <code>restrict : &#x27;EAC&#x27;</code></p>
<p><code>restrict</code> n&#x27;est donc plus configurable et est restreint <em>(sans mauvais jeu de mot)</em>
√† la forme <code>&#x27;E&#x27;</code> en faisant un composant de fa√ßon claire.</p>
<h3 id="isolement-du-scope"><a href="#isolement-du-scope" class="phenomic-HeadingAnchor">#</a>Isolement du scope</h3>
<p>Contrairement √† <code>.directive()</code>, <code>.component()</code> force l&#x27;isolement du scope,
ainsi on colle √† la specification : le composant web est agnostique du contexte.</p>
<p>l&#x27;attribut <code>scope</code> est donc forc√© √† <code>{}</code> et n&#x27;est plus configurable.</p>
<h3 id="passage-de-paramtres-via-bindings"><a href="#passage-de-paramtres-via-bindings" class="phenomic-HeadingAnchor">#</a>Passage de param√®tres via <code>bindings</code></h3>
<p>La propri√©t√© <code>scope</code> n&#x27;√©tant plus disponible <code>component</code>. Il faut √† pr√©sent utiliser la propri√©t√© <code>bindings</code>. La syntaxe de celle-ci est √©quivalent √† celle de la propri√©t√© <code>scope</code>. Mais les √©l√©ments pass√©s sont automatiquement attach√©s √† l&#x27;instance du contr√¥leur li√© au <code>component</code>.</p>
<p>Notons, que s&#x27;il reste possible d&#x27;utiliser la syntaxe <code>=</code> (two-way data binding), celle-ci est d√©conseill√©e au profit de la syntaxe <code>&lt;</code> (one-way data binding).</p>
<h3 id="utilisation-force-de-controlleras"><a href="#utilisation-force-de-controlleras" class="phenomic-HeadingAnchor">#</a>Utilisation <em>forc√©e</em> de <code>controllerAs</code></h3>
<p>D√©j√† pr√©sent√© comme une <em><a href="https://toddmotto.com/digging-into-angulars-controller-as-syntax/">best practice</a></em>,
<code>controllerAs</code> fait son chemin de mani√®re √©vidente jusqu&#x27;au nouveau <em>helper</em>
<code>.component()</code> son utilisation va de pair avec celle de <code>bindings</code>.</p>
<p>L&#x27;attribut, qui prend une chaine de caract√®res pour valeur, est √† pr√©sent facultatif.
S&#x27;il est omit le controller est automatiquement aliass√© par l&#x27;objet <code>$ctrl</code>.</p>
<h2 id="exemple-de-migration"><a href="#exemple-de-migration" class="phenomic-HeadingAnchor">#</a>Exemple de migration</h2>
<p>Prenons l&#x27;exemple d&#x27;une directive simple et transformons la en composant Angular pour
mettre en √©vidence l&#x27;ensemble des changements :</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">hello-world</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"World"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">hello-world</span>&gt;</span></code></pre>
<p>La syntaxe <em>directive</em> :</p>
<pre><code class="hljs language-js">angular.directive(<span class="hljs-string">'helloWorld'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorld</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    restrict          : <span class="hljs-string">'E'</span>,
    scope             : {},
    bindToController  : {
      name : <span class="hljs-string">'@'</span>
    },
    controller        : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorldCtrl</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.logName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
      }
    },
    controllerAs      : <span class="hljs-string">'hw'</span>,
    template          : <span class="hljs-string">'&lt;div&gt;&lt;span ng-click="hw.logName()"&gt;Hello {{hw.name}}!&lt;/span&gt;&lt;/div&gt;'</span>
  }
});</code></pre>
<p>La syntaxe <em>component</em> :</p>
<pre><code class="hljs language-js">angular.component(<span class="hljs-string">'helloWorld'</span>, {
  bindings: {
    name: <span class="hljs-string">'@'</span>
  },
  controller : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorldCtrl</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.logName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
  },
  template : <span class="hljs-string">'&lt;div&gt;&lt;span ng-click="$ctrl.logName()"&gt;Hi {{$ctrl.name}}!&lt;/span&gt;&lt;/div&gt;'</span>
});</code></pre>
<p>Les changements sont l√©gers mais permettent une lecture am√©lior√©e des attributs.
Le composant est donc une version simplifi√©e de la directive, plus en phase avec
la logique d&#x27;Angular 2.</p>
<p>Ce nouveau <em>helper</em> permet donc l&#x27;introduction progressive des <em>web-components</em> au
sein d&#x27;Angular en vue de leur int√©gration et utilisation active dans la version 2.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/angular/components/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/angular/components/</guid><pubDate>Tue, 12 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Hello Swift]]></title><description><![CDATA[<blockquote>
<p>Le <strong>Swift</strong> est un langage de programmation pr√©sent√© en <strong>2014</strong> par
<strong>Apple</strong>. Il a √©t√© cr√©√© pour simplifier le d√©veloppement d&#x27;applications pour
les environnements d&#x27;Apple (iOS, OS X, tvOS, watchOS), car les nouveaux
d√©veloppeurs,  non habitu√©s √† <code>Objective C</code>, trouvent souvent celui-ci  trop dur
√† appr√©hender. En 2015, Apple pr√©sente <strong>Swift 2.0</strong>, une version finalis√©e et
stable du langage. <strong>Swift</strong> est <strong>open-source</strong> depuis novembre 2015.</p>
</blockquote>
<h2 id="le-playground"><a href="#le-playground" class="phenomic-HeadingAnchor">#</a>Le playground</h2>
<p>Avec Swift, Apple a introduit un nouveau moyen de s&#x27;amuser avec du code : le
<strong>playground</strong>. C&#x27;est √† mi-chemin entre le script <code>python</code> et le <code>main de C</code>.
Vous pouvez y √©crire des <code>fonctions</code>, y d√©finir des <code>classes</code>, mais aussi y
ex√©cuter du code en direct. Tout ceci est vraiment pratique pour <strong>tester des
algorithmes</strong>, des animations ou plus simplement <strong>apprendre √† maitriser le
langage</strong>. Les <code>playgrounds</code> servent √† prototyper plus qu‚Äô√† √©crire de vrais
outils.</p>
<p>Gr√¢ce √† un partenariat entre Apple et IBM,  vous pouvez faire du <strong>Swift sur
votre navigateur</strong> avec Bluemix. La plate-forme de cloud coding d&#x27;IBM
<a href="https://swiftlang.ng.bluemix.net">swiftlang.ng.bluemix.net</a> offre ainsi un
<strong><code>playground</code> en ligne</strong> pour apprendre et vous entrainer en <strong>Swift</strong>. Donc
plus de limitation due √† l&#x27;OS pour apprendre !</p>
<p>Sur OS X vous pouvez utiliser les <code>playground</code> avec Xcode, l&#x27;IDE d&#x27;Apple. Pour
cr√©er un  <strong><code>playground</code></strong>,  vous ouvrez Xcode et <code>File‚ÜíNew‚ÜíPlayground</code>(ou
<kbd>‚å•</kbd> + <kbd>‚áß</kbd> + <kbd>‚åò</kbd> + <kbd>N</kbd>). Vous nommez votre
<code>playground</code> et choisissez une plate-forme pour utiliser des frameworks
sp√©cifiques pour chaque environnement (iOS ou OS X).</p>
<p><img src="./playground.jpg" alt="Playground"></p>
<p>Enfin, Swift peut √™tre utilis√© comme langage de script, en cr√©ant un fichier
<code>.swift</code>, √† ex√©cuter dans le terminal avec <code>swift [file].swift</code>. Cette m√©thode
offre peu de confort, car m√™me en ouvrant le fichier sur Xcode vous n&#x27;aurez pas
l&#x27;autocompl√©tion. Mais si vous √™tes un mordu de <strong>Linux</strong>, sachez qu&#x27;il existe
un compilateur Swift Linux fourni par Apple sur la <a href="https://swift.org/download/#linux">page d√©di√©e sur
swift.org</a>.</p>
<h2 id="les-variables"><a href="#les-variables" class="phenomic-HeadingAnchor">#</a>Les variables</h2>
<p>Les variables peuvent √™tre constantes ou non. Le pr√©compilateur d&#x27;Xcode est
assez strict avec la notion de constante. Si vous d√©clarez une variable non
constante mais que vous ne la modifiez nulle part, il vous proposera toujours de
la passer en constante.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Exemple de variables/constantes</span>
<span class="hljs-keyword">var</span> aVariable:<span class="hljs-type">Type</span> = something <span class="hljs-comment">// variable (mutable)</span>
<span class="hljs-keyword">let</span> aConstant:<span class="hljs-type">Type</span> = somethingElse <span class="hljs-comment">// constante</span></code></pre>
<p>Swift est un langage typ√©, mais le type peut √™tre implicite lors de la
d√©claration. Swift typera alors la variable automatiquement.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> explicitString:<span class="hljs-type">String</span> = <span class="hljs-string">"Mario"</span>
<span class="hljs-keyword">let</span> implicitString = <span class="hljs-string">"Luigi"</span> <span class="hljs-comment">// This is a string too</span></code></pre>
<p>Par d√©faut, les variables ne peuvent pas √™tre nulles. Pour qu&#x27;une variable soit
dite <em>optionelle</em>, il faut d√©clarer une variable explicite en ajoutant un <code>?</code> √†
son type.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Ce code ne compile pas :</span>
<span class="hljs-keyword">var</span> implicitString = <span class="hljs-string">"Luigi"</span>
name = <span class="hljs-literal">nil</span> <span class="hljs-comment">// Error : Nil cannot be assigned to type 'String'</span>

<span class="hljs-comment">// Mais celui-ci, si</span>
<span class="hljs-keyword">let</span> explicitOptionalString:<span class="hljs-type">String</span>? = <span class="hljs-string">"Mario"</span>
explicitOptionalString = <span class="hljs-literal">nil</span> <span class="hljs-comment">// Ol√© üíÉ</span></code></pre>
<h2 id="affichage"><a href="#affichage" class="phenomic-HeadingAnchor">#</a>Affichage</h2>
<p>La fonction <code>print()</code> sert √† afficher une cha√Æne de caract√®res dans la console
pour un script ou une application. Pour afficher des variables dans des cha√Ænes
de caract√®res, on utilise cette syntaxe <code>\(maVariable)</code>. Exemple :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> age:<span class="hljs-type">Int</span> = <span class="hljs-number">32</span>
<span class="hljs-keyword">let</span> name:<span class="hljs-type">String</span> = <span class="hljs-string">"Luigi"</span>
<span class="hljs-keyword">let</span> point:<span class="hljs-type">Float</span> = <span class="hljs-number">43.4</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(name)</span> have <span class="hljs-subst">\(age)</span> and <span class="hljs-subst">\(point)</span> points"</span>)

<span class="hljs-comment">// Ou</span>
<span class="hljs-keyword">let</span> toPrint:<span class="hljs-type">String</span> = <span class="hljs-string">"<span class="hljs-subst">\(name)</span> have <span class="hljs-subst">\(age)</span> and <span class="hljs-subst">\(point)</span> points"</span>
<span class="hljs-built_in">print</span>(toPrint)</code></pre>
<h2 id="conditions--boucles"><a href="#conditions--boucles" class="phenomic-HeadingAnchor">#</a>Conditions &amp; boucles</h2>
<p>Un langage sans condition √ßa sert pas √† grand-chose, donc voici la syntaxe :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">if</span> (a &gt; x) || (a &lt; y) { <span class="hljs-comment">// Si a est plus grand que x ou plus petit que y</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a &gt; x OR a &lt; y "</span>) <span class="hljs-comment">// j'affiche</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a &lt; z { <span class="hljs-comment">// Sinon si ...</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a &lt; z"</span>)
} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// Sinon</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"y &lt;= a &lt;= x"</span>)
}</code></pre>
<p>Quelques exemples de boucles <code>while</code> et <code>for</code> :</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// While</span>
<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">10</span> { <span class="hljs-comment">// Tant que i &lt; 10 j'affiche</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"i = <span class="hljs-subst">\(i)</span>"</span>)
    i+=<span class="hljs-number">1</span> <span class="hljs-comment">// incr√©mente i de 1</span>
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>...<span class="hljs-number">10</span>) { <span class="hljs-comment">// pour i de 0 √† 10</span>
	<span class="hljs-built_in">print</span>(i)
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>...<span class="hljs-number">10</span>).<span class="hljs-built_in">reverse</span>() { <span class="hljs-comment">// pour i de 1 √† 10 en moonwalk</span>
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.<span class="hljs-built_in">stride</span>(to: <span class="hljs-number">10</span>, by: <span class="hljs-number">2</span>) { <span class="hljs-comment">// pour i de 0 √† 10 par saut de 2 (10 non compris)</span>
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-comment">// autre notation de For utilisant des Ranges</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">3</span>{
    <span class="hljs-built_in">print</span>(i)
}

<span class="hljs-comment">// For-In : Pour mes √©l√©ments d'un Array</span>
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> myCollection {
    element.doSomething()
}

<span class="hljs-comment">// For-In : en enumurant la boucle</span>
<span class="hljs-keyword">for</span> (index,valeur) <span class="hljs-keyword">in</span> myCollection.<span class="hljs-built_in">enumerate</span>(){
	<span class="hljs-built_in">print</span>(<span class="hljs-string">"valeur √† l'index [<span class="hljs-subst">\(index)</span>] -&gt; <span class="hljs-subst">\(valeur)</span>"</span>)
}</code></pre>
<blockquote>
<p>Depuis Swift 2.2, les notations <code>--</code> et <code>++</code> sont d√©pr√©ci√©es, donc plus de i++ dans les boucles üò©. Ce qui explique aussi que les boucles For C-Style sont aussi d√©pr√©ci√©es. Ex:<code>for var i = 0; i &lt; 3; i++</code>. Pour ce genre de boucle il faut utiliser la notation <code>(0...3)</code>.</p>
</blockquote>
<h2 id="fonctions"><a href="#fonctions" class="phenomic-HeadingAnchor">#</a>Fonctions</h2>
<p>Un script sans fonction c&#x27;est comme une raclette sans Saint-Nectaire. Beaucoup
de d√©butants le font mais une fois qu&#x27;on y a gout√©, il est impossible s&#x27;en
passer !</p>
<p>Donc voici la syntaxe <del>d&#x27;un Saint-Nectaire</del>... d&#x27;une fonction :</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunctionName</span><span class="hljs-params">(myStringInput:String,myIntInput:Int)</span></span>-&gt;<span class="hljs-type">Int</span>{

    <span class="hljs-comment">// Votre code</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// Retour</span>
}</code></pre>
<p>En r√©alit√©, les fonctions sont un cas particulier d&#x27;utilisation d&#x27;une notion
introduite par Swift qu&#x27;ils appellent les <em>closures</em>. Pour les amateurs de
<em>Block</em> (Objective C, C++14) et  <strong>Lambdas</strong> (C++, Java,...), les closures
seront d√©taill√©es dans un prochain article.</p>
<h2 id="le-mot-de-la-fin"><a href="#le-mot-de-la-fin" class="phenomic-HeadingAnchor">#</a>Le mot de la fin</h2>
<p>Avec tout √ßa vous devriez d√©j√† vous amuser un peu !
Pour information, les scripts Swift peuvent <strong>utiliser <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/">Foundation</a></strong>
sur Linux ou OS X , le framework de base des OS d&#x27;Apple bien connu des
d√©veloppeurs OS X/iOS. Il permet le traitement des fichiers, des <code>String</code> et
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/ObjC_classic/">bien plus</a>.</p>
]]></description><link>http://putaindecode.io/fr/articles/swift/hello/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/swift/hello/</guid><pubDate>Tue, 01 Mar 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Vers les CSS modules]]></title><description><![CDATA[<blockquote>
<p>Je crois que m√™me avant que je sache exactement ce qu&#x27;√©tait le CSS, j&#x27;avais
d√©j√† entendu quelqu&#x27;un me dire &quot;Je HAIS le CSS&quot;. Cette phrase √©tait souvent dite
par un de mes amis du back-end, et souvent pour de tr√®s bonnes raisons. Cet
article n&#x27;essaiera pas de d√©fendre ni de vous faire aimer le CSS, mais comme les
outils de d√©veloppement front-end √©voluent rapidement, je trouve int√©ressant
d&#x27;expliquer les nouvelles fa√ßons d&#x27;√©crire le CSS.</p>
</blockquote>
<h2 id="retour-aux-bases"><a href="#retour-aux-bases" class="phenomic-HeadingAnchor">#</a>Retour aux bases</h2>
<p>D&#x27;abord, pour comprendre quel sont les probl√®mes que les nouveaux outils tentent
de r√©soudre, un petit rappel sur ce qu&#x27;est le CSS : <em>Cascading Style Sheets</em> ou
<em>Feuilles de style en cascade</em>.</p>
<p>Une feuille de style ? C&#x27;est facile ! C&#x27;est un bout de code qui lie des &quot;styles&quot;
√† du HTML.
En cascade ? Et bien, quelques fois un √©l√©ment HTML peut correspondre √†
plusieurs styles, et &quot;en cascade&quot; est le groupe de r√®gles qui permet de
d√©terminer lequel appliquer.</p>
<p>Voici du code CSS basique : nous voulons que nos titres h1 soient rouges.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Ici, nous lions la <strong><em>r√®gle (ou d√©claration)</em></strong> <code>color: red</code> au <strong><em>s√©lecteur</em></strong>
&quot;h1&quot;. Un s√©lecteur peut contenir plusieurs r√®gles dans son bloc de d√©clarations.</p>
<blockquote>
<p>Et les derni√®res lueurs de bonheur s&#x27;√©teignent alors que nous entrons dans
l&#x27;enfer de la cascade</p>
</blockquote>
<h2 id="le-truc-qui-cascade"><a href="#le-truc-qui-cascade" class="phenomic-HeadingAnchor">#</a>Le truc qui cascade</h2>
<p>La cascade est pour moi un d√©sastre qui rend le CSS tr√®s compliqu√© √† maintenir
si on ne suit pas de lignes directrices ou on n&#x27;utilise pas d&#x27;outils pour
l&#x27;√©crire. Je vais vous montrer quelques exemples simples pour vous expliquer les
principaux concepts de la cascade, mais gardez en t√™te que la plupart des
applications web contiennent de nos jours beaucoup de code, aggravant les effets
de la cascade.</p>
<p>La n√©cessit√© d&#x27;avoir un syst√®me comme la cascade vient du fait que le CSS permet
√† plusieurs r√®gles de style de s&#x27;appliquer √† un m√™me √©l√©ment, ces derni√®res
pouvant m√™me venir de plusieurs origines (du site, mais aussi du navigateur ou
encore m√™me de l&#x27;utilisateur). Il faut donc pouvoir d√©finir dans ce cas-l√†
quelle est la r√®gle qui au final sera appliqu√©e. Pour cela, la cascade donne √†
chacune un poids, calcul√© selon un certain nombre de crit√®res, et applique la
r√®gle la plus lourde. Cela peut paraitre simple au premier abord, mais les
crit√®res de calcul de poids ne le sont pas du tout.</p>
<p>Les r√®gles qui sont les plus l√©g√®res dans la cascade ne sont pas vraiment un
probl√®me, mais il faut les connaitre afin de s&#x27;√©viter des surprises :</p>
<h3 id="les-valeurs-par-dfaut-du-navigateur"><a href="#les-valeurs-par-dfaut-du-navigateur" class="phenomic-HeadingAnchor">#</a>Les valeurs par d√©faut du navigateur</h3>
<p>Voici le haut de la cascade. Ce sont les r√®gles qui font qu&#x27;un titre h1 est gros
m√™me si on ne l&#x27;a pas sp√©cifi√©.</p>
<h3 id="lhritage-des-parents"><a href="#lhritage-des-parents" class="phenomic-HeadingAnchor">#</a>L&#x27;h√©ritage des parents</h3>
<p>Ensuite, les r√®gles sont h√©rit√©es depuis les √©l√©ments HTML parents. Si on
reprend notre √©l√©ment h1, si une r√®gle <code>color: blue</code> est d√©finie sur l&#x27;√©l√©ment
<code>body</code>, le titre va en h√©riter, et sera donc bleu.</p>
<p>Ceci √©tant dit, on entre maintenant dans un niveau plus douloureux de la
cascade.</p>
<h3 id="lordre-des-rgles"><a href="#lordre-des-rgles" class="phenomic-HeadingAnchor">#</a>L&#x27;ordre des r√®gles</h3>
<p>La position d&#x27;une r√®gle par rapport aux autres va influer sur son poids.
Deux r√®gles auraient pu avoir le m√™me poids si elles √©taient √† la m√™me position
mais, au final, c&#x27;est la derni√®re qui sera la plus lourde et sera donc
appliqu√©e.
<strong><em>La derni√®re.</em></strong>
Quand il s&#x27;agit de code assez simple, cela peut √™tre facilement
compr√©hensible :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Facile, n&#x27;est-ce pas ? Le titre sera bleu ! Mais s&#x27;il y a une r√®gle <code>color: red</code> dans un fichier CSS nomm√© <em>foo.css</em>, et une r√®gle <code>color: blue</code> dans un
autre fichier nomm√© <em>bar.css</em>, que le fichier <em>foo.css</em> met plus de temps que le
fichier <em>bar.css</em> √† charger, mais que le tag HTML r√©f√©ren√ßant <em>foo.css</em> est
avant celui de <em>bar.css</em>, quelle r√®gle est appliqu√©e ? Eh bien, c&#x27;est plus
compliqu√© √† savoir. <em>(indice : le temps de chargement n&#x27;est pas pris en compte)</em></p>
<h3 id="la-spcificit-des-slecteurs"><a href="#la-spcificit-des-slecteurs" class="phenomic-HeadingAnchor">#</a>La sp√©cificit√© des s√©lecteurs</h3>
<p>Ce crit√®re est un niveau de complexit√© au-dessus des autres, <a href="https://specificity.keegan.st">si bien que des
personnes en ont fait des calculettes pour le
simplifier</a>. Je ne vais pas rentrer dans les
d√©tails, mais il faut savoir que le poids d&#x27;un s√©lecteur est √©gal √† la somme des
poids de tous les s√©lecteurs le composant.
Et que tous les s√©lecteurs n&#x27;ont pas le m√™me poids.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.title</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Ici, le premier s√©lecteur p√®se 10 parce qu&#x27;il contient un s√©lecteur de classe
CSS, qui p√®se lui-m√™me 10. Le deuxi√®me s√©lecteur quant √† lui p√®se 3, parce qu&#x27;il
contient trois s√©lecteurs de tag, pesant chacun 1. Et donc, comme 10 &gt; 3, le
titre h1 sera rouge !</p>
<h3 id="les-styles-inline"><a href="#les-styles-inline" class="phenomic-HeadingAnchor">#</a>Les styles inline</h3>
<p>Les r√®gles qui sont dans l&#x27;attribut ‚Äústyle‚Äù d&#x27;un √©l√©ment HTML sont plus lourdes
que n&#x27;importe quel s√©lecteur d√©fini pr√©c√©demment. Et donc voici un titre bleu :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<h3 id="importance"><a href="#importance" class="phenomic-HeadingAnchor">#</a>Importance</h3>
<p>Et enfin le dernier crit√®re, le God Mode, le broyeur de styles, le mot-cl√©
<strong><em>!important.</em></strong> Quand on veut VRAIMENT que le titre soit rouge :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>Et comme toute la cascade est √† propos de poids, si deux r√®gles sont marqu√©es
comme !important, le reste des crit√®res est toujours pris en compte pour
calculer laquelle est la plus lourde, et donc appliqu√©e.</p>
<p><strong>‚Ä¶Et on ne peut pas faire plus compliqu√© que √ßa.</strong> Maintenant, imaginez des
milliers et des milliers de s√©lecteurs et r√®gles cascadant les uns sur les
autres pour d√©finir le style d&#x27;un site, et vous comprendrez l&#x27;enfer que peut
√™tre le CSS. Ainsi, des d√©veloppeurs CSS ont imagin√© diff√©rentes m√©thodologies
et outils pour √©viter ce cauchemar !</p>
<h2 id="lvolution-des-outils"><a href="#lvolution-des-outils" class="phenomic-HeadingAnchor">#</a>L&#x27;√©volution des outils</h2>
<p>Maintenant, je vais vous pr√©senter comment ma fa√ßon d&#x27;√©crire du CSS a √©volu√© au
fil du temps. Ne vous attendez pas √† une chronologie compl√®te de tous les
outils invent√©s depuis la cr√©ation du CSS en 1996 (j&#x27;avais 6 ans !) mais plut√¥t
une explication de comment je me suis d√©brouill√© avec la cascade dans ma courte
exp√©rience personnelle.</p>
<h3 id="pr-processeurs"><a href="#pr-processeurs" class="phenomic-HeadingAnchor">#</a>Pr√©-processeurs</h3>
<p>J&#x27;ai commenc√© √† developper des applications web en 2012, en plein √¢ge d&#x27;or <a href="/fr/articles/css/preprocesseurs/">des
pr√©-processeurs</a>. Ils
√©taient apparus quelques ann√©es auparavant, comme le CSS lui-m√™me n&#x27;√©tait pas
suffisamment adapt√© pour construire des sites complexes. Les pr√©-processeurs
sont des compilateurs qui g√©n√®rent du code CSS √† partir de languages l√©g√®rement
diff√©rents, comme <a href="http://sass-lang.com">Sass</a> ou <a href="http://lesscss.org">LESS</a>.
Ces nouveaux languages permettent de cr√©er des variables par exemple, ou
d&#x27;imbriquer des s√©lecteurs, entre autres merveilleuses nouvelles
fonctionnalit√©s.</p>
<p>On peut transformer ce vieux code CSS compliqu√© √† maintenir :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#E5E5E5</span>;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<p>en cette bien <em>meilleure</em> version :</p>
<pre><code class="hljs language-scss"><span class="hljs-variable">$textColor</span>: <span class="hljs-number">#333333</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: lighten(<span class="hljs-variable">$textColor</span>, <span class="hljs-number">90%</span>);

  <span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>
  }
}</code></pre>
<p>Avec ces nouveaux outils, et pour √©viter aux r√®gles d&#x27;entrer en collision dans
la cascade, nous avons commenc√© √† imbriquer nos s√©lecteurs et √† r√©pliquer toute
notre structure HTML dans le code de notre pr√©-processeur favori. Notre CSS se
retrouva donc avec des s√©lecteurs tr√®s long et lourds qui √©taient associ√©s
uniquement avec un element HTML pr√©cis, comme ce dernier :</p>
<blockquote>
<p>.searchPage¬†.sideBar¬†.refinements.default¬†.category¬†.star input</p>
</blockquote>
<p>Et √ßa a plut√¥t bien march√© au d√©but ! Mais ces s√©lecteurs n&#x27;√©taient pas les plus
performants, et la structure du HTML √©tant r√©pliqu√©e, n&#x27;importe quel changement
dans cette derni√®re doit √™tre r√©percut√© dans les styles. Donc je suis pass√© √†
autre chose.</p>
<h3 id="mthodologies-css"><a href="#mthodologies-css" class="phenomic-HeadingAnchor">#</a>M√©thodologies CSS</h3>
<p>√Ä ce moment, quelques nouvelles guidelines CSS ont commenc√© a attirer mon
attention. On pouvait les utiliser avec les pr√©-processeurs, et avaient pour but
d&#x27;√©viter les collisions dans la cascade (tout comme l&#x27;imbrication des
s√©lecteurs) avec un certain nombre de r√®gles, comme sur le nommage des
s√©lecteurs.</p>
<p>Ces m√©thodologies sont arriv√©es au moment ou je commen√ßais √† d√©couper mes
d√©veloppements en composants. L&#x27;imbrication des s√©lecteurs ne marchait pas tr√®s
bien avec ces derniers, vu que le but est de cr√©er des bouts de code
r√©utilisables partout dans la web app, comme un bouton par exemple. La
m√©thodologie que j&#x27;utilise (toujours aujourd&#x27;hui) est appel√©e <a href="/fr/articles/css/bem/">BEM, pour Block
Element Modifier</a>, mais il y en a
d&#x27;autres avec le m√™me but : chaque √©l√©ment HTML de mes composants doit avoir une
classe CSS qui lui est unique. De cette fa√ßon, pas besoin d&#x27;imbrication, et pas
de collision de la cascade !</p>
<p>Et ce code de pr√©-processeur¬†:</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>

  img {
    border: <span class="hljs-number">1px</span> solid black;
  }
}</code></pre>
<p>se transforme en :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor
}

<span class="hljs-selector-class">.Title-icon</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}</code></pre>
<p>√âvidement, le code HTML doit √™tre mis √† jour avec les nouvelles classes, mais
les s√©lecteurs sont maintenant courts et compr√©hensibles. Et ceci, sans aucune
chance de collision de cascade.</p>
<p>Maintenant, pour pouvoir mieux expliquer un dernier outil, celui qui je pense va
r√©soudre tous nos probl√®mes, il faut que je vous montre une autre approche pour
contourner les probl√®mes de la cascade :</p>
<h3 id="frameworks-css"><a href="#frameworks-css" class="phenomic-HeadingAnchor">#</a>Frameworks CSS</h3>
<p>Ici, pour √©viter √† nos r√®gles CSS d&#x27;entrer en collision, nous‚Ä¶ n&#x27;en √©crivons
plus !
Les frameworks CSS sont des styles d√©j√† √©crits qu&#x27;on peut utiliser avec des
classes CSS sp√©cifiques. Il y a deux approches ici :</p>
<ul>
<li>
<p>Les frameworks de styles &quot;finaux&quot; comme <a href="http://getbootstrap.com">Bootstrap</a>.
Il suffit d&#x27;ajouter la classe <code>btn</code> sur un √©l√©ment HTML et‚Ä¶ tada¬†! C&#x27;est
maintenant un magnifique bouton. Certaines variables sont modifiables pour
transformer le look global du framework.</p>
</li>
<li>
<p>Les frameworks de styles &quot;utilitaires&quot; comme <a href="http://tachyons.io">Tachyons</a>.
Ici, il n&#x27;y a pas de styles pr√©-d√©finis, mais plein de classes utilitaires
sont disponibles, comme <code>pam</code> pour donner un <em>medium padding</em> √† un √©l√©ment,
ou encore <code>ba</code> pour lui donner une <em>border all</em> tout autour.</p>
</li>
</ul>
<p>Les frameworks utilitaires sont assez int√©ressants, du fait que le fichier CSS
final fera autour de 10kB et jamais plus, m√™me si le site grandit ! Mais il y
aura beaucoup de classes peu compr√©hensibles dans le code HTML. C&#x27;est comparable
aux styles inline, avec une optimization de poids final, comme <code>ba</code> est plus
court que <em>‚Äúborder-style: solid; border-width: 1px;‚Äù</em></p>
<p>Ces frameworks nous √©vitent tout tracas avec la cascade ! Mais je n&#x27;aimais pas
le fait d&#x27;utiliser un framework, ainsi qu&#x27;avoir beaucoup de classes non
compr√©hensibles dans mon code HTML. Cependant, la totale r√©utilisabilit√© et
modularit√© des styles, sans probl√®mes de cascade, sont impressionnants.</p>
<p>Cela nous am√®ne donc √† cet outil g√©nial, forg√© directement avec la meilleure
magie JavaScript :</p>
<h3 id="css-modules"><a href="#css-modules" class="phenomic-HeadingAnchor">#</a>CSS Modules</h3>
<p>Ce concept a d&#x27;abord pris forme suite √† une simple observation : de nos jours,
le CSS est compil√© √† partir d&#x27;autres languages pour permettre une √©criture plus
facile, et pour cette m√™me raison le HTML est aussi g√©n√©r√© gr√¢ce √† des outils de
templating en JavaScript. Mais les s√©lecteurs CSS, le lien entre les √©l√©ments et
les styles, ceux-la m√™me auxquels le codeur doit faire tr√®s attention pour
√©viter qu&#x27;ils n&#x27;entrent en collision, n&#x27;ont pas d&#x27;outils du tout.</p>
<p>Et <a href="https://github.com/css-modules/css-modules">CSS Modules</a> fut cr√©√©. La
premi√®re fonctionnalit√© int√©ressante est la g√©n√©ration automatique des noms de
classes CSS. Plus d&#x27;inqui√©tude sur leur unicit√©, on peut les nommer comme on
veut, au final ceux g√©n√©r√©s dans le HTML seront uniques. Promis. Cela nous
permet de r√©√©crire ce code CSS en BEM, et HTML :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>en ce code CSS et template JavaScript :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName</span> {
  <span class="hljs-attribute">color</span>: $textColor
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span></code></pre>
<p>Une fois compil√©, ce code g√©n√©rera quelque chose comme √ßa :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"styleName__abc5436"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>Une casc-quoi ? Je ne sais pas ce que c&#x27;est ! ‚ù§Ô∏è</p>
<p>La deuxi√®me fonctionnalit√© g√©niale, directement inspir√©e par les frameworks CSS
modulaires comme Tachyons, est la composition des styles. De la m√™me fa√ßon qu&#x27;en
ajoutant plusieurs classes utilitaires sur son √©l√©ment HTML, CSS Modules nous
permet de composer nos classes √† partir de styles communs. Laissez-moi vous
montrer :</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.bigTitle}</span>&gt;&lt;/h1&gt;
 &lt;h2 class=<span class="hljs-subst">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span></code></pre>
<p>va g√©n√©rer¬†:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle__def6547</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle__1638bcd</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js">&lt;h1 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 bigTitle__def6547"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;h2 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 mediumTitle__1638bcd"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre>
<p>Et ceci, messieurs-dames, est plut√¥t fantastique. Les styles sont modularisables
et composables, et ce sans classes incompr√©hensibles mais directement dans les
feuilles de style. Et les collisions de s√©lecteurs et r√®gles ne sont plus qu&#x27;un
mauvais souvenir.</p>
<p>Et c&#x27;est ainsi que j&#x27;ai exp√©riment√© avec le CSS et sa cascade jusque-l√†.
J&#x27;esp√®re que les mois et les ann√©es √† venir vont me surprendre avec de meilleurs
outils et / ou m√©thodologies, et je serais heureux de les apprendre et les
essayer üëç</p>
]]></description><link>http://putaindecode.io/fr/articles/css/modules/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/modules/</guid><pubDate>Tue, 23 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Toward CSS modules]]></title><description><![CDATA[<blockquote>
<p>I think that even before I ever knew what it was, I already heard someone
telling me ‚ÄúOh god, I HATE CSS‚Äù. This sentence is often said by one of my
backender friends, and often for very good reasons. This post isn‚Äôt going to
defend nor make you embrace CSS¬†, but as front-end tooling is quickly improving,
I find it interesting to explain the new ways of writing it.</p>
</blockquote>
<h2 id="back-to-basics"><a href="#back-to-basics" class="phenomic-HeadingAnchor">#</a>Back to basics</h2>
<p>First, to understand what are the problems that the new tools are attempting to
solve, a small reminder of what CSS is: <em>Cascading Style Sheets</em>.</p>
<p>A style sheet¬†? Boy, that‚Äôs easy¬†! It‚Äôs some code that maps some  ‚Äústyles‚Äù to
HTML elements. Cascading¬†? Well, sometimes more than one (or no) style can match
for an HTML element, and ‚Äúcascading‚Äù is the set of rules that exist to determine
which one to apply.</p>
<p>Let‚Äôs see some basic CSS code: we want our h1 titles to be red.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<p>Here, we map the <strong><em>rule (or declaration)</em></strong> ‚Äúcolor: red‚Äù to the <strong><em>selector</em></strong>
‚Äúh1‚Äù. A selector can contain multiples rules in its declaration block.</p>
<blockquote>
<p>And now the delight dies as we enter the cascade hell.</p>
</blockquote>
<h2 id="the-cascading-thing"><a href="#the-cascading-thing" class="phenomic-HeadingAnchor">#</a>The cascading thing</h2>
<p>The cascade is for me the disaster that makes CSS un-maintainable without
guidelines nor tools when writing it. I‚Äôll show you some examples explaining the
main concepts of the cascade, but they will be quite simple, whereas most web
app nowadays have huge codebases, making the cascade effects bigger.</p>
<p>The need for such a system like the cascade comes from the fact that CSS allows
multiple rules to be applied on the same element, even from different origins
(the website, but also the browser or even from the user). It is therefore
necessary to define what is the rule that ultimately will be applied in this
case.
The cascade gives each rule a weight, calculated from several criteria, and
apply the heaviest on the element.
I could appear simple at first, but the calculations
criteria are not, at all.</p>
<p>The rules that have the lightest cascade weight are not really an issue, but we
have to keep them in mind to avoid surprises:</p>
<h3 id="browser-defaults"><a href="#browser-defaults" class="phenomic-HeadingAnchor">#</a>Browser defaults</h3>
<p>Here is the top of the cascade. These are the rules that makes a h1 title big
even if it isn&#x27;t specified.</p>
<h3 id="parent-inheritance"><a href="#parent-inheritance" class="phenomic-HeadingAnchor">#</a>Parent inheritance</h3>
<p>Then, the rules are inherited from the parents HTML elements. Back to our h1
element, if there is a ‚Äúcolor: blue‚Äù rule on the body element, the title will
inherit it, and will therefore be blue.</p>
<p>That being said, we now enter a more painful level of cascade weight.</p>
<h3 id="rule-order"><a href="#rule-order" class="phenomic-HeadingAnchor">#</a>Rule order</h3>
<p>The position of a rule compared with others will have an influence on its
weight. Thus, if two rules were to have the same weight if on the same position,
it finally will be the latest that will be the heaviest, and so applied. <strong><em>The
latest.</em></strong> With some quite simple code, it can be easy to understand:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>Easy, right¬†? The h1 will be blue¬†! But if there is a ‚Äúcolor: red‚Äù rule in one
CSS file named <em>foo.css</em>, a ‚Äúcolor: blue‚Äù rule in another file named <em>bar.css</em>,
that the <em>foo.css</em> loading takes more time than <em>bar.css</em>, but that the
<em>foo.css</em> HTML tag is before the <em>bar.css</em> one, which rule is applied¬†? Well,
it‚Äôs quite harder to know. <em>(hint: the loading time is not taken into account)</em></p>
<h3 id="selector-specificity"><a href="#selector-specificity" class="phenomic-HeadingAnchor">#</a>Selector specificity</h3>
<p>This one is a level of complexity higher, <a href="https://specificity.keegan.st">some people even made calculators to
simplify it</a>. I will not enter into much details,
but know that the weight of a selector is equal to the sum of all the weights of
the selectors composing it. And that all selectors does‚Äôt weigh the same.</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.title</span> {
  <span class="hljs-attribute">color</span>: red;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: blue;
}</code></pre>
<p>In this example, the first selector‚Äôs weight is 10 because it only contains a
CSS class selector which weigh 10. The second selector‚Äôs weight is 3, because it
contains three tag selectors, weighing each 1. So, as 10 &gt; 3, the h1 title will
be red¬†!</p>
<h3 id="inline-styles"><a href="#inline-styles" class="phenomic-HeadingAnchor">#</a>Inline styles</h3>
<p>The rules that are in the ‚Äústyle‚Äù attribute on a HTML element are heavier than
any selector previously defined. Here is a blue title:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<h3 id="importance"><a href="#importance" class="phenomic-HeadingAnchor">#</a>Importance</h3>
<p>And last but not least, the God Mode, the crusher of all styles, the
<strong><em>!important</em></strong> keyword. When we REALLY want our title to be red:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: red <span class="hljs-meta">!important</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>As all this cascade is about weight, if two rules are marked as¬†!important, the
rest of the criteria is still taken into account to calculate which one is the
heavier, and so applied.</p>
<p><strong>‚Ä¶And that is as bad as it gets.</strong> Now, imagine thousands and thousands of
selectors cascading over themselves to style a website, and you‚Äôll understand
the hell CSS can be. So, some fellow CSS developers imagined several
methodologies and tools to prevent this nightmare to happen¬†!</p>
<h2 id="tooling-evolution"><a href="#tooling-evolution" class="phenomic-HeadingAnchor">#</a>Tooling evolution</h2>
<p>Now I‚Äôll present to you how my way of writing CSS evolved over time. Do not
expect a complete timeline of all the tools invented since the first release of
CSS in 1996 (I was 6 years old¬†!), but a description of how I worked with (or
around) the cascade in my short personal experience.</p>
<h3 id="pre-processors"><a href="#pre-processors" class="phenomic-HeadingAnchor">#</a>Pre-processors</h3>
<p>I began developing web applications in 2012, in the golden age of the
pre-processors. They already had appeared a few years back, as CSS itself wasn‚Äôt
enough to build complex websites. Pre-processors are compilers that generate CSS
from slightly different languages, like <a href="http://sass-lang.com">Sass</a> or
<a href="http://lesscss.org">LESS</a>. These new languages added some fantastic new
features as variables or nesting, among other wonders.</p>
<p>We could transform some old and un-easy to maintain CSS:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#E5E5E5</span>;
}

<span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<p>into this much <em>better</em> version:</p>
<pre><code class="hljs language-scss"><span class="hljs-variable">$textColor</span>: <span class="hljs-number">#333333</span>;

<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: lighten(<span class="hljs-variable">$textColor</span>, <span class="hljs-number">90%</span>);

  <span class="hljs-selector-tag">h1</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>
  }
}</code></pre>
<p>With these new tools, and to prevent rules to collide in the cascade, we started
nesting and replicating the whole HTML structure into our Sass or LESS code. Our
CSS ended up with super long and heavy selectors matching only and exactly our
element, like this one:</p>
<blockquote>
<p>.searchPage¬†.sideBar¬†.refinements.default¬†.category¬†.star input</p>
</blockquote>
<p>And this worked pretty well for a time¬†! But these selectors weren‚Äôt the more
efficient, and the HTML structure being doubled, any change in it must be passed
on the styles. So I moved on.</p>
<h3 id="css-methodologies"><a href="#css-methodologies" class="phenomic-HeadingAnchor">#</a>CSS Methodologies</h3>
<p>By this time, some new CSS writing guidelines began to drew my attention. They
weren‚Äôt exclusive with pre-processors, and aimed to avoid cascade collision
(just like nesting) with some rules, like on the selector naming.</p>
<p>These methodologies came by the time I started to split my developments into
components. The nesting didn‚Äôt work well with these, as the purpose was to
create bits of code usable everywhere in my web app, like a button for example.
The one I use (still today) is named <a href="https://en.bem.info/method/">BEM, for Block Element
Modifier</a>, but there are others with the same aim:
each HTML element of my component has to have an unique CSS class. This way, no
nesting is needed, and no cascade collision¬†!</p>
<p>And this pre-processed code:</p>
<pre><code class="hljs language-scss"><span class="hljs-selector-tag">h1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$textColor</span>

  img {
    border: <span class="hljs-number">1px</span> solid black;
  }
}</code></pre>
<p>was transformed into:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor
}

<span class="hljs-selector-class">.Title-icon</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}</code></pre>
<p>Obviously, the HTML code needed to be updated with the new classes, but the
selectors are now short and self-explanatory¬†! Without any chance of cascade
collision.</p>
<p>Now, and to better explain a final tool, the one I think will solve all our
problems (for now), I must show you another approach of this ‚Äúworking around‚Äù
the cascade:</p>
<h3 id="css-frameworks"><a href="#css-frameworks" class="phenomic-HeadingAnchor">#</a>CSS Frameworks</h3>
<p>Here, to prevent our CSS to collide, we‚Ä¶ stop writing our own¬†! CSS frameworks
are already written styles that we can use with specific CSS classes. There is
two different approaches here:</p>
<ul>
<li>
<p>‚ÄúFinal‚Äù styles framework as <a href="http://getbootstrap.com">Bootstrap</a>: a simple
<em>‚Äúbtn‚Äù</em> class on a HTML element and‚Ä¶ tada¬†! Now it is a magnificent button.
Besides, some variables are available to customize the frameworks‚Äô look.
Utility styles framework, like <a href="http://tachyons.io">Tachyons</a>. Here, there
aren‚Äôt any pre-defined style, but a lot of utility CSS classes are available,
like <em>‚Äúpam‚Äù</em> to make an element have a <em>medium padding</em>, or <em>‚Äúba‚Äù</em> to make it
have a <em>border all</em> around it.</p>
</li>
<li>
<p>The second one is quite interesting, as our final CSS file will only weigh
10kB and never more, even if the  website grows¬†! But the HTML will have a lot
of gibberish classes.
It‚Äôs comparable with having all the styles inline, with a
weight optimization comparable with minification, as <em>‚Äúba‚Äù</em> is shorter than
<em>‚Äúborder-style: solid; border-width: 1px;‚Äù</em>.</p>
</li>
</ul>
<p>These frameworks will keep us from complex CSS cascade calculations¬†! But I
quite didn‚Äôt like the fact to use a framework, and to have a lot of quite
unreadable CSS classes in my HTML. But the full re-usability and modularity of
the styles, without any cascade problems, are awesome.</p>
<p>This bring us to this amazing tool, directly forged with the best JavaScript
magic:</p>
<h3 id="css-modules"><a href="#css-modules" class="phenomic-HeadingAnchor">#</a>CSS Modules</h3>
<p>This concept first took shape from a simple observation: nowadays, the CSS code
is compiled from other languages to make its writing way easier, and for the
same reason HTML code is mainly generated with JavaScript templating tools. But
the CSS selectors, the link between the elements and the styles, the ones for
which the coder really needs to cogitate to prevent them to collide, are not
tooled at all.</p>
<p>And so <a href="https://github.com/css-modules/css-modules">CSS Modules</a> was created.
The first awesome feature is the CSS class names automatic generation. No more
worries about their uniqueness, we can name them as we want, the final one
generated on the HTML element will be unique. Promise. This allows to rewrite
this previous CSS BEM and HTML code:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.Title</span> {
  <span class="hljs-attribute">color</span>: $textColor;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>into this CSS and JS template code:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName</span> {
  <span class="hljs-attribute">color</span>: $textColor
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.styleName}</span>&gt;&lt;/h1&gt;`</span></code></pre>
<p>And when compiled, this code will generate something like this¬†!</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.styleName__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}</code></pre>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"styleName__abc5436"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>
<p>A casc-what¬†? I don‚Äôt know what this is¬†! ‚ù§Ô∏è</p>
<p>The second main feature, which is directly inspired by modular CSS frameworks
like Tachyons, is the styles composition. Just like it allowed to style HTML
elements with some common utility classes, CSS modules allows to compose our
classes with common styles. Let me show you¬†!</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle</span> {
  <span class="hljs-attribute">composes</span>: titleColor;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./style.css'</span>;
<span class="hljs-string">`&lt;h1 class=<span class="hljs-subst">${styles.bigTitle}</span>&gt;&lt;/h1&gt;
 &lt;h2 class=<span class="hljs-subst">${styles.mediumTitle}</span>&gt;&lt;/h2&gt;`</span></code></pre>
<p>will compile into:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-class">.titleColor__abc5436</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333333</span>;
}

<span class="hljs-selector-class">.bigTitle__def6547</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>;
}

<span class="hljs-selector-class">.mediumTitle__1638bcd</span> {
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
}</code></pre>
<pre><code class="hljs language-js">&lt;h1 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 bigTitle__def6547"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
&lt;h2 <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"titleColor__abc5436 mediumTitle__1638bcd"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre>
<p>And that, Sir, is pretty awesome. Styles are composable and modularizable, and
not with a lot of gibberish utility classes but directly in the stylesheet. And
styles colliding are just an old nightmare.</p>
<p>That‚Äôs how I‚Äôve been playing around with CSS and its cascade until now. I expect
the months and years to come to surprise me with new and better tools or
methodologies, and I‚Äôll be happy to learn and test them üëç.</p>
]]></description><link>http://putaindecode.io/en/articles/css/modules/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/css/modules/</guid><pubDate>Tue, 23 Feb 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction √† Grid Layout]]></title><description><![CDATA[<p>La mise en page d&#x27;un site ou d&#x27;une application est toujours quelque chose de
complexe et fastidieux √† d√©velopper/maintenir. Pour cela, de nombreux designs
sont √©labor√©s √† partir d&#x27;une grille. En effet, l&#x27;objectif de la grille est de
servir de base pour placer les diff√©rents √©l√©ments et de faire en sorte qu&#x27;ils
soient align√©s et espac√©s uniform√©ment. Le probl√®me de CSS est qu&#x27;il rencontre
beaucoup de lacunes pour mettre en place cette logique.</p>
<p>L&#x27;arriv√©e du module <code>Flexbox</code> a commenc√© √† bien faciliter les choses. Toutefois,
ce module n&#x27;est pas adapt√© √† toutes les situations et il est bien plus pertinent
sur du layout de composants.</p>
<p>C&#x27;est pour cette raison qu&#x27;a √©t√© d√©velopp√© le module <code>Grid Layout</code>, plus
puissant et orient√© mise en page.</p>
<h2 id="tat-des-lieux"><a href="#tat-des-lieux" class="phenomic-HeadingAnchor">#</a>√âtat des lieux</h2>
<p>Parlons des choses qui f√¢chent d√®s le d√©but. √Ä l&#x27;heure actuelle la derni√®re
r√©vision date du <a href="http://www.w3.org/TR/css-grid-1/">17 septembre 2015</a> et la
sp√©cification en est toujours √† l&#x27;√©tat de <em>working draft</em>.</p>
<p>La compatibilit√© des <a href="http://caniuse.com/#feat=css-grid">navigateurs est quelque peu
limit√©e</a>. Except√© Internet Explorer 10+ (Edge
√©galement), il est n√©cessaire d&#x27;activer le flag <code>layout.css.grid.enabled</code> dans
Firefox et <code>experimental Web Platform features</code> pour Chrome pour activer le
support du module.</p>
<p>Autant dire qu&#x27;une utilisation en production est relativement pr√©matur√©e, quand
bien m√™me cela ne doit pas nous emp√™cher d&#x27;exp√©rimenter ce module.</p>
<h2 id="grid"><a href="#grid" class="phenomic-HeadingAnchor">#</a>Grid</h2>
<p>La notion de Grid n&#x27;est pas nouvelle, de multiples frameworks/librairies
utilisent d√©j√† la mise en page en <code>Grid</code> :</p>
<ul>
<li><a href="https://github.com/suitcss/components-grid">SUIT CSS components-grid</a></li>
<li><a href="http://foundation.zurb.com/docs/components/grid.html">Zurb Foundation</a></li>
<li><a href="http://960.gs/">960</a></li>
<li><a href="https://github.com/cssrecipes/grid">cssrecipes Grid</a></li>
</ul>
<p>Toutes ces solutions se basent soit sur du <code>inline-block</code>, soit plus r√©cemment
sur <code>Flexbox</code>. M√™me si elles sont relativement √©l√©gantes, elles n√©cessitent
quand m√™me quelques petits hacks ou tricks pour r√©ussir √† faire quelque chose de
coh√©rent (hello, <code>font-size: 0</code>, goutti√®re, <code>calc</code> avec marge n√©gative, etc.).
La raison est simple¬†: les techniques utilis√©es ne sont pas adapt√©es pour un
syst√®me complet de <code>Grid</code>.</p>
<h2 id="thinking-in-grid"><a href="#thinking-in-grid" class="phenomic-HeadingAnchor">#</a>Thinking in Grid</h2>
<p>De fa√ßon √† pouvoir pr√©senter une partie de la sp√©cification, nous allons partir
sur cette mise en page :</p>
<p><img src="maquette.png" alt="Maquette Grid Layout"></p>
<p>Avant de commencer √† pr√©senter les diff√©rentes propri√©t√©s, r√©fl√©chissons au
concept de <code>Grid</code>.</p>
<h3 id="grid-lines"><a href="#grid-lines" class="phenomic-HeadingAnchor">#</a>Grid lines</h3>
<p>Si on applique cette notion √† notre maquette, voici ce qu&#x27;on obtient :</p>
<p><img src="grid-line.png" alt="Caniuse Grid Layout"></p>
<p>Concr√®tement, cela consiste √† d√©couper notre interface de fa√ßon √† pouvoir en
extraire une grille et ainsi virtualiser la position et l&#x27;espace pris pour
chaque √©l√©ment.</p>
<p>On va donc pouvoir extrapoler notre UI en lignes (<code>rows</code>), en colonnes
(<code>columns</code>), en cellules (<code>cells</code>) et en zones (<code>areas</code>).</p>
<p>Cette derni√®re notion (<code>areas</code>) est peut-√™tre nouvelle dans la th√©orie, mais va
s&#x27;av√©rer tr√®s utile dans la pratique pour la suite.</p>
<h2 id="grid-layout"><a href="#grid-layout" class="phenomic-HeadingAnchor">#</a>Grid Layout</h2>
<p>On dispose de suffisamment d&#x27;informations sur notre interface pour d√©marrer
(enfin) notre int√©gration.</p>
<p>Voici le markup que l&#x27;on va utiliser pour notre maquette.</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Layout"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Header"</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Aside"</span>&gt;</span>Aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Main"</span>&gt;</span>
    Main
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Footer"</span>&gt;</span>Footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>Dans un premier temps, nous allons &quot;configurer&quot; notre <code>Grid</code>:</p>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.Layout</span> {
  <span class="hljs-comment">/*
   * On d√©clare un nouveau contexte dans le parent
   * qui devient alors un grid-container
   * tous les enfants deviennent des grid-items
   */</span>
   <span class="hljs-attribute">display</span>: grid;

  <span class="hljs-comment">/* Configuration de notre canvas */</span>

  <span class="hljs-comment">/*
   * On d√©finit le nombre de colonnes¬†:
   * - la premi√®re fera 200px de large
   * - la deuxi√®me fera 10px de large
   * - la troisi√®me prendra tout l'espace restant
   */</span>
   <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1</span>fr;

  <span class="hljs-comment">/*
   * Cette fois-ci au tour des lignes¬†:
   * - la premi√®re fera 70px de haut
   * - la deuxi√®me fera 10px de haut
   * - la troisi√®me ligne s'adaptera √† la hauteur de son contenu
   * - la quatri√®me fera 50px de haut
   */</span>
   <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">70px</span> <span class="hljs-number">10px</span> auto <span class="hljs-number">10px</span> <span class="hljs-number">50px</span>;

  <span class="hljs-comment">/*
   * On peut utiliser grid qui est le raccourci
   * des deux propri√©t√©s pr√©c√©dentes
   */</span>
   <span class="hljs-attribute">grid</span>: <span class="hljs-number">200px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1</span>fr / <span class="hljs-number">70px</span> <span class="hljs-number">10px</span> auto <span class="hljs-number">10px</span> <span class="hljs-number">50px</span>;
}</code></pre>
<p>Notre <code>Grid</code> est pr√™te, passons au positionnement de nos √©l√©ments.</p>
<h2 id="grid-area"><a href="#grid-area" class="phenomic-HeadingAnchor">#</a>grid-area</h2>
<p>Pour notre exemple nous allons utiliser la m√©thode la plus originale du module √†
savoir les <code>areas</code>. L&#x27;inter√™t de cette m√©thode est de pouvoir contr√¥ler tant en
terme d&#x27;espace occup√© que de positionnement les diff√©rentes zones (<code>areas</code>) de
notre grille. On pourrait d√©finir la forme des valeurs de <code>grid-template-areas</code>
comme de l&#x27;<code>ASCII art</code>.</p>
<pre><code class="hljs language-CSS"><span class="hljs-selector-class">.Layout</span> {
  <span class="hljs-comment">/**
   * 1. Header s'affichera sur 3 colonnes
   * 2. On utilisera le symbole . pour d√©finir un √©l√©ment
   *    virtuel et ainsi l'utiliser pour d√©finir les goutti√®res
   * 3. Aside s'affichera sur 1 colonne et 3 lignes
   */</span>
  <span class="hljs-attribute">grid-template-areas</span>:
   <span class="hljs-string">"Header Header Header"</span>  <span class="hljs-comment">/* 1 */</span>
   <span class="hljs-string">".        .      .   "</span>  <span class="hljs-comment">/* 2 */</span>
   <span class="hljs-string">"Aside    .     Main "</span>  <span class="hljs-comment">/* 3 */</span>
   <span class="hljs-string">"Aside    .      .   "</span>  <span class="hljs-comment">/* 3 */</span>
   <span class="hljs-string">"Aside    .    Footer"</span>; <span class="hljs-comment">/* 3 */</span>
}

<span class="hljs-comment">/**
 * 1. Il est donc n√©cessaire de nommer chaque √©l√©ment
 *    pour le contr√¥ler dans notre area
 */</span>

<span class="hljs-selector-class">.Header</span> {
  <span class="hljs-attribute">grid-area</span>: Header; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Main</span> {
  <span class="hljs-attribute">grid-area</span>: Main; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Aside</span> {
  <span class="hljs-attribute">grid-area</span>: Aside; <span class="hljs-comment">/* 1 */</span>
}

<span class="hljs-selector-class">.Footer</span> {
  <span class="hljs-attribute">grid-area</span>: Footer; <span class="hljs-comment">/* 1 */</span>
}</code></pre>
<p>Notre int√©gration est termin√©e, on constate qu&#x27;avec tr√®s peu d&#x27;HTML et de CSS,
on arrive d√©j√† √† quelque chose d&#x27;int√©ressant. Il devient alors tr√®s facile de
manipuler et d√©placer nos diff√©rents √©l√©ments en fonction du contexte de notre
application (mobile first, responsive, etc.).</p>
<h2 id="et-cest-pas-fini-"><a href="#et-cest-pas-fini-" class="phenomic-HeadingAnchor">#</a>Et c&#x27;est pas fini !</h2>
<p><code>Grid-Layout</code> dispose d&#x27;une quantit√© assez impressionnante de propri√©t√©s, il
embarque pratiquement toutes les propri√©t√©s introduites par <code>Flexbox</code>
(<code>align-items</code>, <code>order</code>, <code>justify-content</code> etc..).</p>
<p>De nouvelles fonctions font leur apparition comme <code>repeat</code> (permet d&#x27;appliquer
des motifs de r√©p√©tition), mais aussi de nouvelles unit√©s tels que
<code>xfr</code> (fraction de l&#x27;espace restant), <code>min-content</code> (se rapporte √† l&#x27;√©l√©ment le
plus petit), <code>max-content</code> (se rapporte √† l&#x27;√©l√©ment le plus grand). La notion de
<code>subgrid</code> est √©galement pr√©sente pour l&#x27;imbrication de grilles.</p>
<p>Il est d&#x27;ailleurs tout √† fait possible d&#x27;int√©grer une m√™me interface de
plusieurs mani√®res diff√©rentes. Si l&#x27;on reprend notre exemple, nous somme partis
sur les propri√©t√©s utilisant les <code>areas</code>, mais on aurait tr√®s bien pu utiliser
<code>grid-row</code> et <code>grid-column</code> qui s&#x27;appliquent non pas sur le parent mais sur les
enfants. Cette solution peut s&#x27;av√©rer tr√®s pratique pour des syst√®mes de grilles
classiques.</p>
<p><code>Grid Layout</code> est un module tr√®s puissant et tr√®s complet. En le combinant avec
<code>Flexbox</code>, on dispose de suffisament d&#x27;outils pour travailler sur des mises en
pages complexes. Reste plus qu&#x27;aux navigateurs √† rapidement valider/int√©grer/supporter
cette nouvelle sp√©cification.</p>
]]></description><link>http://putaindecode.io/fr/articles/css/grilles/grid-layout/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/css/grilles/grid-layout/</guid><pubDate>Tue, 05 Jan 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les Proxy]]></title><description><![CDATA[<h2 id="proxies-origin"><a href="#proxies-origin" class="phenomic-HeadingAnchor">#</a>Proxies Origin</h2>
<h3 id="what-the-dom"><a href="#what-the-dom" class="phenomic-HeadingAnchor">#</a>What the DOM?</h3>
<p>ES5 avait laiss√© un petit trou nomm√©
<em><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.8">&quot;host objects&quot;</a></em>
afin de donner un &quot;cadre l√©gal&quot; aux trucs bizarres qui peuvent arriver dans le
DOM. Par exemple, certaines collections sont dites
<a href="https://dom.spec.whatwg.org/#concept-collection-live">&quot;live&quot;</a> et m√™me si on ne
touche pas l&#x27;objet directement, on se rend compte que la collection a √©t√©
modifi√©e.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> childNodes = <span class="hljs-built_in">document</span>.body.childNodes;
<span class="hljs-built_in">console</span>.log(childNodes.length); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))
<span class="hljs-comment">// Personne n'a touch√© explicitement l'objet dans la variable divs, pourtant :</span>
<span class="hljs-built_in">console</span>.log(childNodes.length); <span class="hljs-comment">// 1, wat!</span></code></pre>
<p>Ce genre de comportement n&#x27;est pas explicable par la s√©mantique d&#x27;ES5 (√† moins
d&#x27;accepter des gros probl√®mes de performances qui consisteraient √† ce que le
DOM garde une r√©f√©rence vers toutes les collections live et les mette √† jour
r√©guli√®rement, ou des getter partout, etc.). La
<a href="https://heycam.github.io/webidl/">spec WebIDL</a> qui fait le lien entre les
objets d√©crits dans les spec W3C et la s√©mantique ECMAScript se contentait d&#x27;un
&quot;c&#x27;est un <em>host object</em>, all√©, salut les gars les filles !&quot; (en fait, c&#x27;√©tait
pire que √ßa¬†:
<a href="http://www.w3.org/TR/DOM-Level-2-Core/ecma-script-binding.html">la spec de
l&#x27;√©poque</a>
√©tait absurde tant elle manquait de d√©tails, mais je vous fais la version de
No√´l).</p>
<p>Mais ce genre d&#x27;explication n&#x27;est pas vraiment acceptable. Et si un navigateur
a un bug, comment je polyfille le comportement correct, hein ?</p>
<p>Les proxies peuvent aider.</p>
<h3 id="quest-il-arriv--mon-objet-"><a href="#quest-il-arriv--mon-objet-" class="phenomic-HeadingAnchor">#</a>Qu&#x27;est-il arriv√© √† mon objet ?</h3>
<p>Avant que la plan√®te JS ne s&#x27;amourache des
<a href="https://facebook.github.io/immutable-js/">structures des donn√©es immutables</a>,
on cr√©ait des objets et des fois, on les passait √† du code qui les modifiait et
on se demandait bien quand/comment l&#x27;objet en question en √©tait arriv√© dans cet
√©tat. Depuis ES5, on peut logger dans des <em>getters</em> et <em>setters</em>, mais on ne
peut pas savoir quand on s&#x27;est pris un <code>delete</code> ou un
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze</a>¬†;
on peut constater le r√©sultat, mais c&#x27;est dur de remonter √† la source.</p>
<p>Les proxies peuvent aider.</p>
<h3 id="laisse-mon-objet-tranquille-"><a href="#laisse-mon-objet-tranquille-" class="phenomic-HeadingAnchor">#</a>Laisse mon objet tranquille !</h3>
<p>La s√©mantique des objets tel qu&#x27;on les utilise permet √† diff√©rents scripts
d&#x27;agir sur les m√™mes objets, mais d&#x27;une mani√®re qui ne permet pas forc√©ment
toujours un contr√¥le fin. Par exemple, si je donne acc√®s √† la r√©f√©rence d&#x27;un
objet √† quelqu&#x27;un, il poss√®de cette r√©f√©rence pour toujours et dans la foul√©e
tous les droits associ√©s (donc modifier l&#x27;objet arbitrairement souvent) ; il
n&#x27;est pas possible de <strong>r√©voquer</strong> l&#x27;acc√®s dans le temps. Ce script a aussi
acc√®s √† toutes les propri√©t√©s de l&#x27;objet, m√™me si on voudrait n&#x27;en partager
que certaines ; il n&#x27;est pas facile <strong>d&#x27;att√©nuer</strong> les droits √† un objet (sans
cr√©er de nouveaux objets et de se lancer dans des synchronisations co√ªteuses).</p>
<h2 id="les-proxies-comment-a-marche"><a href="#les-proxies-comment-a-marche" class="phenomic-HeadingAnchor">#</a>Les proxies, comment √ßa marche</h2>
<p>Un <strong>proxy</strong> est un nouvel objet (on ne peut pas transformer un objet en un
proxy) qui &quot;emballe&quot; (<em>wrap</em>) un objet existant, la <strong>target</strong> et d√©crit le
comportement du proxy via un objet appel√© le <strong>handler</strong> qui d√©finit les
<em>traps</em> du proxy.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = {a:<span class="hljs-number">1</span>};

<span class="hljs-keyword">const</span> handler = {
    get(target, prop){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"It's a (get) trap!"</span>, prop, target[prop]);
        <span class="hljs-keyword">return</span> target[prop]+<span class="hljs-number">1</span>;
    }
}

<span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
<span class="hljs-built_in">console</span>.log(proxy.a);</code></pre>
<p>console output:</p>
<pre><code>It&#x27;s a (get) trap! a 1 // inside the trap
2 // new value modified by the trap
</code></pre>
<h3 id="liste-des-traps"><a href="#liste-des-traps" class="phenomic-HeadingAnchor">#</a>Liste des traps</h3>
<p>L&#x27;exemple ci-dessus montre la trap <code>get</code>. Voici la liste des traps
disponible¬†:</p>
<ul>
<li>
<p>getPrototypeOf</p>
<ul>
<li>pour <code>Object.getPrototypeOf</code></li>
</ul>
</li>
<li>
<p>setPrototypeOf</p>
<ul>
<li>pour <code>Object.setPrototypeOf</code></li>
</ul>
</li>
<li>
<p>isExtensible</p>
<ul>
<li>pour <code>Object.isExtensible</code></li>
</ul>
</li>
<li>
<p>preventExtensions</p>
<ul>
<li>pour <code>Object.preventExtensions</code></li>
</ul>
</li>
<li>
<p>getOwnPropertyDescriptor</p>
<ul>
<li>pour <code>Object.getOwnPropertyDescriptor</code></li>
</ul>
</li>
<li>
<p>defineProperty</p>
<ul>
<li>pour <code>Object.defineProperty</code></li>
</ul>
</li>
<li>
<p>has</p>
<ul>
<li>pour l&#x27;op√©rateur <code>in</code></li>
</ul>
</li>
<li>
<p>get</p>
<ul>
<li>pour <em>getter</em> une propri√©t√©</li>
</ul>
</li>
<li>
<p>set</p>
<ul>
<li>pour <em>setter</em> une propri√©t√©</li>
</ul>
</li>
<li>
<p>deleteProperty</p>
<ul>
<li>pour l&#x27;op√©rateur <code>delete</code></li>
</ul>
</li>
<li>
<p>enumerate</p>
<ul>
<li>pour les <code>for...in</code> et <code>Object.keys</code></li>
</ul>
</li>
<li>
<p>ownKeys</p>
<ul>
<li>pour <code>Object.getOwnPropertyNames</code></li>
</ul>
</li>
<li>
<p>apply</p>
<ul>
<li>pour quand on appelle le proxy comme une fonction.</li>
</ul>
</li>
<li>
<p>construct</p>
<ul>
<li>pour quand on appelle le proxy comme un constructeur (avec <code>new</code>).</li>
</ul>
</li>
</ul>
<p>Le lecteur attentif aura remarqu√© que cette liste (et les signatures des
fonctions) correspondent √† l&#x27;API</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect#Methods">Reflect</a></p>
<h2 id="solutions-aux-problmes-prcdents"><a href="#solutions-aux-problmes-prcdents" class="phenomic-HeadingAnchor">#</a>Solutions aux probl√®mes pr√©c√©dents</h2>
<h3 id="logger-les-oprations"><a href="#logger-les-oprations" class="phenomic-HeadingAnchor">#</a>Logger les op√©rations</h3>
<p>Vous voulez savoir quand on objet se prend un <code>delete</code>¬†? Rien de plus
facile¬†!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({b: <span class="hljs-number">2</span>}, {
    deleteProperty(target, prop){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Wow, someone just deleted'</span>, prop);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.deleteProperty(target, prop);
    },
    freeze(target){
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Wow, someone just froze the object'</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.freeze(target);
    }
})

<span class="hljs-keyword">delete</span> p.b;
<span class="hljs-built_in">Object</span>.freeze(p);</code></pre>
<h3 id="implmenter-des-nodelist-live"><a href="#implmenter-des-nodelist-live" class="phenomic-HeadingAnchor">#</a>Impl√©menter des NodeList live</h3>
<p>Ici, on pr√©tend r√©impl√©menter une collection DOM <em>live</em>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getChildNodesLiveCollection</span>(<span class="hljs-params">parent</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {
        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, prop</span>)</span>{
            <span class="hljs-keyword">if</span>(prop === <span class="hljs-string">"length"</span>){
                <span class="hljs-comment">// l'astuce qui n'est pas de la triche , c'est qu'on va</span>
                <span class="hljs-comment">// chercher la valeur au moment de l'appel</span>
                <span class="hljs-keyword">return</span> parent.childNodes.length;
            }
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> target[prop];
        }
    })

}


<span class="hljs-keyword">var</span> liveChildNodes = getChildNodesLiveCollection(<span class="hljs-built_in">document</span>.body);
<span class="hljs-built_in">console</span>.log(liveChildNodes.length); <span class="hljs-comment">// 0</span>
<span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))
<span class="hljs-built_in">console</span>.log(liveChildNodes.length); <span class="hljs-comment">// 1, magie magie !</span></code></pre>
<h3 id="attnuation"><a href="#attnuation" class="phenomic-HeadingAnchor">#</a>Att√©nuation</h3>
<p>J&#x27;ai un objet avec plein de propri√©t√© et je veux en partager une version
att√©nu√©e √† une biblioth√®que en laquelle je n&#x27;ai qu&#x27;une confiance partielle.</p>
<pre><code class="hljs language-js">// On va se faire MitM avec ce HTTP sans 'S' !
import dubiousLib from 'http://dubious-lib.com/main.js';

const myImportantObject = {
    jfkKillerName: '...',
    elvisGeoloc: {
        long: '...',
        lat: '...'
    },
    name: "David Bruant",
    xmasPresentList: [
        "Raspberry Pi B",
        "Nouveau t√©l√©phone (mais pas FirefoxOS, parce qu'ils arr√™tent les
t√©ls)",
        "Une bo√Æte de Tic Tac"
    ]
}

function makeWhitelistProxy(t, whitelist){
    return new Proxy(t, {
        get(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.get(target, prop);
        },
        set(target, prop, value){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.set(target, prop, value);
        },
        getOwnPropertyDescriptor(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        deleteProperty(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.deleteProperty(target, prop);
        },
        defineProperty(target, prop, desc){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.defineProperty(target, prop, desc);
        },
        has(target, prop){
            if(!whitelist.has(prop))
                throw new Error('Attempt to access forbidden property')

            return Reflect.has(target, prop);
        }
    })
}

const attenatedObject = makeWhitelistProxy(
    myImportantObject,
    new Set(["name", "xmasPresentList"])
);

console.log(myImportantObject.name === attenatedObject.name);
console.log(myImportantObject.jfkKillerName); // "..."
console.log(attenatedObject.jfkKillerName);
// error thrown! 'Error: Attempt to access forbidden property'

dubiousLib(attenatedObject);</code></pre>
<p>On peut imaginer d&#x27;autres formes d&#x27;att√©nuation, comme ne donner acc√®s qu&#x27;en
lecture √† l&#x27;objet alors que l&#x27;on garde soi-m√™me un acc√®s en √©criture (ce qui
est impossible avec <code>Object.freeze</code>).</p>
<h3 id="rvocation"><a href="#rvocation" class="phenomic-HeadingAnchor">#</a>R√©vocation</h3>
<p>On peut r√©voquer l&#x27;acc√®s √† un objet en impl√©mentant le <em>pattern</em> &quot;caretaker&quot;</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCaretaker</span>(<span class="hljs-params">t</span>)</span>{
    <span class="hljs-keyword">return</span> {
        revoke(){
            t = <span class="hljs-literal">undefined</span>;
        },
        proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(t, {
            get(target, prop){
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop);
            },
            set(target, prop, value){
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, value);
            }
            <span class="hljs-comment">// flemme d'√©crire et vous faire lire les autres traps,</span>
            <span class="hljs-comment">// mais faut toutes les faire ;-)</span>
        })
    }
}

<span class="hljs-keyword">const</span> o = {};
<span class="hljs-keyword">const</span> {revoke, proxy} = makeCaretaker(o);

proxy.a = <span class="hljs-number">12</span>;

<span class="hljs-built_in">console</span>.log(o.a, proxy.a); <span class="hljs-comment">// 12 12</span>

proxy.b = <span class="hljs-number">37</span>;
<span class="hljs-keyword">delete</span> proxy.a;

revoke();

proxy.b; <span class="hljs-comment">// BOOM! TypeError: target is not a non-null object</span></code></pre>
<h4 id="via-un-meta-proxy"><a href="#via-un-meta-proxy" class="phenomic-HeadingAnchor">#</a>...via un meta-proxy</h4>
<p>La petite astuce rigolote avec les proxy, vu que l&#x27;API est dite <em>stratifi√©e</em>,
c&#x27;est que vu que le handler est un objet, on pourrait en faire un proxy pour
impl√©menter la r√©vocation plus simplement.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCaretaker</span>(<span class="hljs-params">target</span>)</span>{
    <span class="hljs-keyword">const</span> metaHandler = {
        get(handler, trapName){
            <span class="hljs-keyword">if</span>(!target)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Revoked object!'</span>)
            <span class="hljs-keyword">else</span>
                <span class="hljs-comment">// Le miroir entre les traps et l'API Reflect vient de l√† ;-)</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>[trapName];
        }
    }

    <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, metaHandler);

    <span class="hljs-keyword">return</span> {
        revoke(){
            target = <span class="hljs-literal">undefined</span>;
        },
        proxy: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)
    };
}

<span class="hljs-keyword">const</span> o = {};
<span class="hljs-keyword">const</span> {revoke, proxy} = makeCaretaker(o);

proxy.a = <span class="hljs-number">12</span>;

<span class="hljs-built_in">console</span>.log(o.a, proxy.a); <span class="hljs-comment">// 12 12</span>

proxy.b = <span class="hljs-number">37</span>;
<span class="hljs-keyword">delete</span> proxy.a;

revoke();

proxy.b; <span class="hljs-comment">// BOOM! TypeError: target is not a non-null object</span></code></pre>
<p>Il fait mal au cr√¢ne au d√©but celui-l√†, mais apr√®s relecture, on se sent bien.</p>
<p>Pour des raisons par tr√®s int√©ressantes, les proxy r√©vocables sont fournis
directement via</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable">Proxy.revocable</a>,
donc, pas besoin de se fatiguer √† le coder avec toutes les traps ou avec un
meta handler.</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Les proxies sont un outil bas niveau et puissant. Avec de grands pouvoirs
viennent de grandes responsabilit√©s, alors comprenez bien cet outil avant de
vouloir l&#x27;utiliser partout.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/proxy/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/proxy/</guid><pubDate>Fri, 18 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les symboles]]></title><description><![CDATA[<p>Dans sa politique d&#x27;enrichissement des types primitifs, ES6 introduit les
symboles. Chers aux d√©veloppeurs de nombreux langages, Ruby en t√™te, les
symboles constituent une √©tape de plus vers l&#x27;√©radication du <em>stringly-typed
programming</em>. En effet, les symboles fournissent un moyen plus robuste de
repr√©senter des identifiants.</p>
<h2 id="crer-un-symbole"><a href="#crer-un-symbole" class="phenomic-HeadingAnchor">#</a>Cr√©er un symbole</h2>
<p>La fonction <code>Symbol()</code> permet de cr√©er de nouveaux symboles :</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Un symbole tout b√™te</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">typeof</span> mySymbol === <span class="hljs-string">'symbol'</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Un symbole avec une description</span>
<span class="hljs-keyword">const</span> myOtherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"description"</span>);


<span class="hljs-comment">// Chaque symbole est unique</span>
<span class="hljs-keyword">const</span> yetAnotherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"description"</span>);
yetAnotherSymbol === myOtherSymbol; <span class="hljs-comment">// false</span></code></pre>
<p>Chaque symbole cr√©√© avec <code>Symbol</code> est unique et immutable. Cela permet
d&#x27;√©viter les collisions : on ne peut pas avoir deux symboles identiques par
erreur.</p>
<h2 id="utiliser-les-symboles-pour-limplmentation-dun-enum"><a href="#utiliser-les-symboles-pour-limplmentation-dun-enum" class="phenomic-HeadingAnchor">#</a>Utiliser les symboles pour l&#x27;impl√©mentation d&#x27;un <em>enum</em></h2>
<p>Plut√¥t que d&#x27;utiliser des cha√Ænes de caract√®res comme valeurs possible d&#x27;un
<em>enum</em>, on peut utiliser des symboles.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ANIMAL_DOG = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> ANIMAL_CAT = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDescription</span>(<span class="hljs-params">animal</span>) </span>{
  <span class="hljs-keyword">switch</span>(animal) {
    <span class="hljs-keyword">case</span> ANIMAL_DOG:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Loving animal"</span>;
    <span class="hljs-keyword">case</span> ANIMAL_CAT:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Evil, sadistic animal"</span>;
  }
}</code></pre>
<p>De cette mani√®re, on ne risque pas de m√©langer accidentellement une chaine de
caract√®res fournie par l&#x27;utilisateur et la valeur d&#x27;un <em>enum</em>. On est oblig√©
de passer par une phase de parsing et de v√©rification.</p>
<h2 id="utiliser-un-symbole-comme-cl"><a href="#utiliser-un-symbole-comme-cl" class="phenomic-HeadingAnchor">#</a>Utiliser un symbole comme cl√©</h2>
<p>Il est possible d&#x27;employer des symboles comme cl√©s d&#x27;un objet ou d&#x27;une classe.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKey = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"MY_KEY"</span>);

<span class="hljs-keyword">const</span> myMutableObject = {};
myMutableObject[myKey] = <span class="hljs-string">"a value"</span>;

<span class="hljs-comment">// En utilisant les *computed property keys*</span>
<span class="hljs-keyword">const</span> myObj = {
    [myKey]: <span class="hljs-string">"a value"</span>
}</code></pre>
<p>Gr√¢ce √† l&#x27;unicit√© des symboles, plus de probl√®mes de collision entre les cl√©s
d&#x27;un objet. On peut laisser l&#x27;utilisateur √©tendre des objets sans prendre le
risque d&#x27;avoir des propri√©t√©s √©cras√©es par erreur.</p>
<p>Par exemple, l&#x27;it√©rateur d&#x27;un objet employ√© par <code>for..of</code> est une propri√©t√©
qui a pour cl√© un symbole, accessible via <code>Symbol.iterator</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myIterableObject = {
  * [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Three"</span>;
  }
}

<span class="hljs-comment">// Affichera One, Two et Three</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> myIterableObject) {
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-comment">// Plantera avec 'TypeError: undefined is not a function'</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> {}) {}</code></pre>
<p>Diff√©rents symboles (les <em>well-known symbols</em>) sont disponibles pour indexer
des propri√©t√©s qui personnalisent le comportement des objets :
<code>Symbol.iterator</code> pour it√©rer sur les valeurs d&#x27;un objet, <code>Symbol.hasInstance</code>
pour modifier le retour de <code>instanceof</code>, ‚Ä¶</p>
<p>Ces propri√©t√©s sont ainsi prot√©g√©es contre tout acc√®s involontaire.</p>
<h3 id="diffrences-avec-lutilisation-dune-chaine-de-caractres-comme-cl"><a href="#diffrences-avec-lutilisation-dune-chaine-de-caractres-comme-cl" class="phenomic-HeadingAnchor">#</a>Diff√©rences avec l&#x27;utilisation d&#x27;une chaine de caract√®res comme cl√©</h3>
<p>Les propri√©t√©s index√©es par des symboles ne sont pas accessibles depuis les
fonctions habituellement utilis√©es pour it√©rer sur les propri√©t√©s ou les
valeurs.</p>
<h4 id="numration"><a href="#numration" class="phenomic-HeadingAnchor">#</a>√ânum√©ration</h4>
<p>Les propri√©t√©s index√©es par des symboles ne sont pas visit√©es par <code>for..in</code>,
ni list√©es par <code>Object.keys</code> ni <code>Object.getOwnPropertyNames</code>. En revanche,
elles sont list√©es par <code>Object.getOwnPropertySymbols</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myObject = {
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}

<span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject) <span class="hljs-comment">// [ "key" ]</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject) <span class="hljs-comment">// [ Symbol() ]</span></code></pre>
<p>Ainsi, du code utilisant <code>Object.getOwnPropertyNames</code> et s&#x27;attendant √†
recevoir des cha√Ænes de caract√®res ne sera pas cass√© par l&#x27;utilisation de
symboles en tant que cl√©s.</p>
<h4 id="jsonstringify"><a href="#jsonstringify" class="phenomic-HeadingAnchor">#</a><code>JSON.stringify</code></h4>
<p>Les propri√©t√©s index√©es par un symbole sont ignor√©es par <code>JSON.stringify</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">JSON</span>.stringify({
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}) <span class="hljs-comment">// '{"key":"string-keyed value"}'</span></code></pre>
<h2 id="registre-global-des-symboles"><a href="#registre-global-des-symboles" class="phenomic-HeadingAnchor">#</a>Registre global des symboles</h2>
<p>Un symbole est unique, une fois cr√©√©, il est impossible d&#x27;en cr√©√©r un autre
ayant les m√™mes propri√©t√©s. Il faut donc que le symbole cr√©√© soit accessible
d&#x27;une mani√®re ou d&#x27;une autre pour pouvoir l&#x27;employer. En revanche, il est
possible de cr√©er un symbole dans un registre global accessible de n&#x27;importe
o√π, gr√¢ce √† <code>Symbol.for</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Renvoie un symbole, en le cr√©ant s'il n'existe pas d√©j√†</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>)

mySymbol === <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// Il est possible de r√©cup√©rer la cl√© avec laquelle un symbole a √©t√© ins√©r√©</span>
<span class="hljs-comment">// dans le registre</span>
<span class="hljs-built_in">Symbol</span>.keyFor(mySymbol) <span class="hljs-comment">// 'mySymbol'</span>

<span class="hljs-comment">// Un symbole non cr√©√© dans le registre n'est pas disponible</span>
<span class="hljs-built_in">Symbol</span>.keyFor(<span class="hljs-built_in">Symbol</span>()) <span class="hljs-comment">// undefined</span></code></pre>
<p><code>Symbol.for</code> permet donc de partager des symboles partout dans le code, y
compris dans des contextes d&#x27;ex√©cution diff√©rents (diff√©rentes frames).</p>
<h2 id="support"><a href="#support" class="phenomic-HeadingAnchor">#</a>Support</h2>
<p>C√¥t√© navigateur, les symboles sont support√©s depuis Chrome 38, Firefox 36,
Opera 25 et Safari 9. Rien chez Internet Explorer. Le support Babel est
limit√©.</p>
<p>C√¥t√© Node.js, le support des symboles est l√† depuis la version <code>0.12</code>.</p>
<p>Les <em>well-known symbols</em> ne sont pas tous disponibles sur les diff√©rentes
plates-formes, leur pr√©sence d√©pendant des fonctionnalit√©s auxquelles ils sont
li√©s.</p>
<h2 id="pour-rsumer"><a href="#pour-rsumer" class="phenomic-HeadingAnchor">#</a>Pour r√©sumer</h2>
<p>Les symboles fournissent un moyen de cr√©er des tokens uniques, ce qui est bien
plus robuste que l&#x27;utilisation de cha√Ænes de caract√®res. L&#x27;utilisation des
symboles pour repr√©senter les valeurs d&#x27;un <em>enum</em> permet d&#x27;√©viter les
collisions et le m√©lange avec des donn√©es non qualifi√©es.</p>
<p>En tant que cl√©s d&#x27;un objet, les symboles permettent d&#x27;√©viter les collisions
et d&#x27;avoir des <em>m√©ta-propri√©t√©s</em> s√©par√©es et ind√©pendantes des propri√©t√©s
index√©es par des cl√©s. Les propri√©t√©s index√©es par des symboles ne peuvent pas
√™tre lues, modifi√©es ou list√©es par erreur, ce qui leur offre un certain degr√©
de protection contre des manipulations accidentelles.</p>
<h2 id="pour-aller-plus-loin"><a href="#pour-aller-plus-loin" class="phenomic-HeadingAnchor">#</a>Pour aller plus loin</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">La documentation des symboles sur MDN</a></li>
<li><a href="http://www.2ality.com/2014/12/es6-symbols.html">Un article complet sur le fonctionnement des symboles et leur cas
d&#x27;utilisation</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/symbols/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/symbols/</guid><pubDate>Thu, 17 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : symbols]]></title><description><![CDATA[<p>Following its goal of enriching primitive types, ES6 introduces symbols.
Familiar to developers in many langages, especially Ruby, symbols bring us a
step further towards the eradication of <em>stringly-typed programming</em>. Symbols
provide us with a more robust way to encode identifiers.</p>
<h2 id="creating-symbols"><a href="#creating-symbols" class="phenomic-HeadingAnchor">#</a>Creating Symbols</h2>
<p>The <code>Symbol()</code> function lets us create new symbols:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// A simple symbol</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">typeof</span> mySymbol === <span class="hljs-string">'symbol'</span> <span class="hljs-comment">// true</span>

<span class="hljs-comment">// A symbol with a label</span>
<span class="hljs-keyword">const</span> myOtherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"label"</span>);


<span class="hljs-comment">// Each symbol is unique</span>
<span class="hljs-keyword">const</span> yetAnotherSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"label"</span>);
yetAnotherSymbol === myOtherSymbol; <span class="hljs-comment">// false</span></code></pre>
<p>Each symbol created with <code>Symbol</code> is both unique and immutable. This allows to
avoid collisions: it&#x27;s impossible to mistakenly have two identical symbols.</p>
<h2 id="implement-an-enum-with-symbols"><a href="#implement-an-enum-with-symbols" class="phenomic-HeadingAnchor">#</a>Implement an <em>enum</em> with symbols</h2>
<p>Instead of using strings as possible values for an <em>enum</em>, it&#x27;s possible to
use symbols.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ANIMAL_DOG = <span class="hljs-built_in">Symbol</span>();
<span class="hljs-keyword">const</span> ANIMAL_CAT = <span class="hljs-built_in">Symbol</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDescription</span>(<span class="hljs-params">animal</span>) </span>{
  <span class="hljs-keyword">switch</span>(animal) {
    <span class="hljs-keyword">case</span> ANIMAL_DOG:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Loving animal"</span>;
    <span class="hljs-keyword">case</span> ANIMAL_CAT:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Evil, sadistic animal"</span>;
  }
}</code></pre>
<p>This way, there is no risk of mistakenly mixing a user-provided string with an
<em>enum</em>. This forces the value through a verifying and parsing stage.</p>
<h2 id="symbols-as-keys"><a href="#symbols-as-keys" class="phenomic-HeadingAnchor">#</a>Symbols as keys</h2>
<p>We can use symbols as a key in an object or in a class.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKey = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"MY_KEY"</span>);

<span class="hljs-keyword">const</span> myMutableObject = {};
myMutableObject[myKey] = <span class="hljs-string">"a value"</span>;

<span class="hljs-comment">// With *computed property keys*</span>
<span class="hljs-keyword">const</span> myObj = {
    [myKey]: <span class="hljs-string">"a value"</span>
}</code></pre>
<p>Due to symbols unicity, no more collisions between the keys of an object.
The user can extend objects without having properties overriden by mistake.</p>
<p>For instance, the iterator on an object (used by <code>for..of</code>), is a property
whose key is a symbol, available through <code>Symbol.iterator</code>.</p>
<p>For instance, an object&#x27;s iterator (used by <code>for..of</code>) is made available as
the property indexed by <code>Symbol.iterator</code>, a symbol devised for this use.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myIterableObject = {
  * [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">"Three"</span>;
  }
}

<span class="hljs-comment">// Displays One, Two and Three</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> myIterableObject) {
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-comment">// Blows up with 'TypeError: undefined is not a function'</span>
<span class="hljs-keyword">for</span>(x <span class="hljs-keyword">of</span> {}) {}</code></pre>
<p>Several symbols (called <em>well-known symbols</em>) index behaviour defining
object properties: <code>Symbol.iterator</code> for the iterator on an object&#x27;s
values, <code>Symbol.hasInstance</code> to alter the result of <code>instanceof</code>, ‚Ä¶</p>
<p>These properties are therefore protected against tampering.</p>
<h3 id="differences-between-symbol-keys-and-string-keys"><a href="#differences-between-symbol-keys-and-string-keys" class="phenomic-HeadingAnchor">#</a>Differences between symbol keys and string keys</h3>
<p>Properties indexed by symbols are not available from the commonly used key or
values functions.</p>
<h4 id="list-symbol-keys"><a href="#list-symbol-keys" class="phenomic-HeadingAnchor">#</a>List symbol keys</h4>
<p>Properties indexed by symbols are not visited by <code>for..in</code>, nor listed by
<code>Object.keys</code>, or <code>Object.getOwnPropertyNames</code>. However, they are listed by
<code>Object.getOwnPropertySymbols</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myObject = {
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}

<span class="hljs-built_in">Object</span>.getOwnPropertyNames(myObject) <span class="hljs-comment">// [ "key" ]</span>
<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(myObject) <span class="hljs-comment">// [ Symbol() ]</span></code></pre>
<p>This way, a piece of code written with <code>Object.getOwnPropertyNames</code> -- and
expecting strings -- won&#x27;t be broken by the use of symbols as keys.</p>
<h4 id="jsonstringify"><a href="#jsonstringify" class="phenomic-HeadingAnchor">#</a><code>JSON.stringify</code></h4>
<p>Symbol-indexed properties are ignored by <code>JSON.stringify</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">JSON</span>.stringify({
  [<span class="hljs-built_in">Symbol</span>()]: <span class="hljs-string">"symbol-keyed value"</span>,
  <span class="hljs-string">"key"</span>: <span class="hljs-string">"string-keyed value"</span>
}) <span class="hljs-comment">// '{"key":"string-keyed value"}'</span></code></pre>
<h2 id="global-symbol-registry"><a href="#global-symbol-registry" class="phenomic-HeadingAnchor">#</a>Global symbol registry</h2>
<p>Symbols being unique, one cannot create a new symbol that is equal to an
already existing one. To be useful, a symbol must be somehow accessible. It&#x27;s
also possible to create a symbol in a global registry with <code>Symbol.for</code>, to
make it available from anywhere.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Returns a symbol, creating it if it doesn't already exist</span>
<span class="hljs-keyword">const</span> mySymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>)

mySymbol === <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"mySymbol"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// It's possible to get the key indexing a symbol in the registry</span>
<span class="hljs-built_in">Symbol</span>.keyFor(mySymbol) <span class="hljs-comment">// 'mySymbol'</span>

<span class="hljs-comment">// Symbols not created in the registry are not available in it</span>
<span class="hljs-built_in">Symbol</span>.keyFor(<span class="hljs-built_in">Symbol</span>()) <span class="hljs-comment">// undefined</span></code></pre>
<p><code>Symbol.for</code> allows to share symbols everywhere in the code, including
different execution contexts (different frames).</p>
<h2 id="support"><a href="#support" class="phenomic-HeadingAnchor">#</a>Support</h2>
<p>In browsers, symbols are supported since Chrome 38, Firefox 36, Opera 25 and
Safari 9. Nothing in Internet Explorer. Babel support is limited.</p>
<p>In Node.js, symbols are supported since version <code>0.12</code>.</p>
<p>Some <em>well-known symbols</em> are not available on all platforms. This depends on
implemented features support.</p>
<h2 id="round-up"><a href="#round-up" class="phenomic-HeadingAnchor">#</a>Round up</h2>
<p>Symbols are a way to create unique tokens, which is way more robust than
using strings. Using symbols to implement <em>enums</em> prevents collisions and
unwanted mix-up with unqualified data.</p>
<p>Lastly, symbols as object keys prevent collisions and lets us have
<em>meta-properties</em> cleanly separated from regular, string-indexed properties.
Properties indexed with symbols can&#x27;t be read, modified or listed by mistake.
This offers some protection against tampering.</p>
<h2 id="further-reading"><a href="#further-reading" class="phenomic-HeadingAnchor">#</a>Further reading</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN documentation on symbols</a></li>
<li><a href="http://www.2ality.com/2014/12/es6-symbols.html">Thorough article on how symbols work and how they can be used</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/symbols/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/symbols/</guid><pubDate>Thu, 17 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : for..of loop]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>With the arrival of new iterable objects, ECMAScript had to create new ways to read through them.
In the unique concern of maintaining the backward compatibility, ES6 had to const his <code>for..in</code> loop untouched.</p>
<blockquote>
<p>But then, how to create a copycat of this same loop with improved capabilities ?</p>
</blockquote>
<p>Solution is quite simple: &quot;Welcome to the <code>of</code> keyword!&quot;</p>
<p>But before I tell you more, and to fully understand the usefulness of this new keyword, const review the existing.</p>
<h2 id="the-good-ol-forin"><a href="#the-good-ol-forin" class="phenomic-HeadingAnchor">#</a>The good ol&#x27; <code>for..in</code></h2>
<p>All self-respecting <em>JavaScript enthousiast</em> already knows the famous <code>for..in</code> loop
whose first value is to iterate over the different keys of an object or an array.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>The <code>for..in</code> loop, despite its ease of use hide some pitfalls:</p>
<ul>
<li>
<p>When itarating over an array, index value is parsed to string : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc..
This behaviour can lead to potential error when index is used in computation.</p>
</li>
<li>
<p>The loop iterate across all the table keys, but also over each of its properties.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>];
arr.oups = <span class="hljs-string">'baz'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + arr[key] ); <span class="hljs-comment">// '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'</span>
}</code></pre>
</li>
<li>
<p>Iteration order over a given object properties may vary across depending on the code executing environment.</p>
</li>
</ul>
<h2 id="the-alternative-foreach-method"><a href="#the-alternative-foreach-method" class="phenomic-HeadingAnchor">#</a>The alternative <code>.forEach()</code> method</h2>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.prototype.forEach()</code></a>
loop allow a more secure iteration, but bring other downsides as:</p>
<ul>
<li>Impossibility to halt the loop with the traditional <code>break;</code> and <code>return;</code> statements.</li>
<li>Array only dedicated method.</li>
</ul>
<h2 id="forof-to-the-rescue"><a href="#forof-to-the-rescue" class="phenomic-HeadingAnchor">#</a><code>for..of</code> to the rescue</h2>
<p>ECMA consortium has so decided to proceed with establishment of a new enhanced version of the <code>for..in</code> loop.
Thus was born the <code>for..of</code> loop which, from now on, will coexist with the previous one allowing to maintain
the backward compatibility with former version of the standard.</p>
<p>The principal is the same : run across any type of <em>iterable object</em>.</p>
<p>In its simplest form, the <code>for..of</code> loop therefore allow to iterate over all values of a table keys.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>The <code>for..of</code> loop can also iterate over more complex types like:</p>
<h3 id="strings"><a href="#strings" class="phenomic-HeadingAnchor">#</a><em>Strings</em></h3>
<p>In this case, each character is evaluated as a Unicode entity.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="nodelist"><a href="#nodelist" class="phenomic-HeadingAnchor">#</a><em>NodeList</em></h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// Note: This will only work in platforms that have</span>
<span class="hljs-comment">// implemented NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// this code add a "read" class to each &lt;p&gt; markup</span>
<span class="hljs-comment">// contained in each &lt;article&gt; markup</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="maps"><a href="#maps" class="phenomic-HeadingAnchor">#</a><em>Maps</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="sets"><a href="#sets" class="phenomic-HeadingAnchor">#</a><em>Sets</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="generators"><a href="#generators" class="phenomic-HeadingAnchor">#</a><em>Generators</em></h3>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>What about traditional object ?</p>
</blockquote>
<p>Suprisingly, objects can&#x27;t be directly browsed by this brand new loop.
Fortunately a workaround exists such as
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="in-a-nutshell"><a href="#in-a-nutshell" class="phenomic-HeadingAnchor">#</a>In a nutshell</h2>
<p><code>for..of</code> comes to address <code>for..in</code> loop gaps and allow
a simplified iteration over <em>iterable objects</em> such as:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">String</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Maps &amp; WeakMaps</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a></li>
</ul>
<p>Furthermore, <code>for..of</code> as of now resolve pitfalls such as unpredictable iteration order or
automated coercion of index to string.</p>
<h2 id="to-go-further"><a href="#to-go-further" class="phenomic-HeadingAnchor">#</a>To go further</h2>
<p><code>for..of</code> loop is another added arrow to ES6 bow that
allows to run through, in a native way, the brand new <em>iterable objects</em> of the language.</p>
<p>For information about this feature :</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">MDN Documentation</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">The post of Jason Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">The post of Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">ECMA-262 Specification</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : la boucle for..of]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>Avec l&#x27;arriv√©e de nouveaux objets it√©rables, ECMAScript avait la n√©cessit√© de
s&#x27;enrichir de
nouvelles fa√ßons de parcourir ces derniers. Dans l&#x27;unique souci de maintenir la
r√©tro-compatibilit√©
avec l&#x27;existant, l&#x27;ES6 se devait de garder la boucle <code>for..in</code> intacte.</p>
<blockquote>
<p>Mais alors, comment cr√©er une variante de cette m√™me boucle avec des capacit√©s
am√©lior√©es ?</p>
</blockquote>
<p>La solution est simple : &quot;Bienvenue au mot-cl√© <code>of</code> !&quot;</p>
<p>Mais avant d&#x27;en dire plus, et pour comprendre l&#x27;utilit√© de ce nouveau mot-cl√©,
revoyons un peu l&#x27;existant.</p>
<h2 id="le-bon-vieux-forin"><a href="#le-bon-vieux-forin" class="phenomic-HeadingAnchor">#</a>Le bon vieux <code>for..in</code></h2>
<p>Tout <em>JavaScript enthusiast</em> qui se respecte connaissait d√©j√† la fameuse boucle
<code>for..in</code>
dont l&#x27;utilit√© premi√®re est d&#x27;it√©rer sur les diff√©rentes cl√©s d&#x27;un objet ou d&#x27;un
tableau.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>La boucle <code>for..in</code>, malgr√© son apparente simplicit√© d&#x27;utilisation, cache
certains pi√®ges :</p>
<ul>
<li>
<p>Lors de l&#x27;it√©ration sur un tableau la valeur de l&#x27;index est convertie en
cha√Æne
de caract√®res : &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, etc. Cela peut potentiellement poser probl√®me
lors de
l&#x27;utilisation de l&#x27;index dans des op√©rations de calcul.</p>
</li>
<li>
<p>La boucle it√®re sur l&#x27;ensemble des cl√©s du tableau, mais aussi sur chacune de
ses propri√©t√©s.</p>
<pre><code>&#x60;&#x60;&#x60;js
const arr = [&#x27;foo&#x27;, &#x27;bar&#x27;];
arr.oups = &#x27;baz&#x27;;

for ( const key in arr ) {
  console.log( key + &#x27;-&gt;&#x27; + arr[key] ); // &#x27;0-&gt;foo&#x27;, &#x27;1-&gt;bar&#x27;, &#x27;oups-&gt;baz&#x27;
}
&#x60;&#x60;&#x60;
</code></pre>
</li>
<li>
<p>L&#x27;ordre d&#x27;it√©ration sur l&#x27;ensemble des cl√©s d&#x27;un objet peut varier selon
l&#x27;environnement d&#x27;√©xecution du code.</p>
</li>
</ul>
<h2 id="la-methode-alternative-foreach"><a href="#la-methode-alternative-foreach" class="phenomic-HeadingAnchor">#</a>La methode alternative <code>.forEach()</code></h2>
<p>La boucle
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach"><code>Array.prototype.forEach()</code></a>
permet une it√©ration plus s√©curis√©e, mais pr√©sente certains autres inconv√©nients
tels que :</p>
<ul>
<li>L&#x27;impossibilit√© d&#x27;interrompre la boucle avec les instructions traditionnelles
<code>break;</code> et <code>return;</code></li>
<li>Il s&#x27;agit d&#x27;une m√©thode r√©serv√©e aux tableaux.</li>
</ul>
<h2 id="forof--la-rescousse"><a href="#forof--la-rescousse" class="phenomic-HeadingAnchor">#</a><code>for..of</code> √† la rescousse</h2>
<p>Le consortium ECMA a donc d√©cid√© de proc√©der √† la cr√©ation d&#x27;une nouvelle
version am√©lior√©e
de la boucle <code>for..in</code>. Ainsi naquit la boucle <code>for..of</code> qui coexistera
d√©sormais avec la pr√©c√©dente,
permettant de maintenir la r√©tro-compatibilit√© avec les versions ant√©rieures de
la norme.</p>
<p>Le principe est le m√™me : parcourir n&#x27;importe quel type <em>d&#x27;objet it√©rable</em>.</p>
<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d&#x27;it√©rer sur
l&#x27;ensemble des valeurs des cl√©s d&#x27;un tableau.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>La boucle <code>for..of</code> peut aussi it√©rer sur des types plus complexes. Examinons
cela de plus pr√®s.</p>
<h3 id="les-strings"><a href="#les-strings" class="phenomic-HeadingAnchor">#</a>Les <em>Strings</em></h3>
<p>Dans ce cas, chaque caract√®re est trait√© comme une entit√© Unicode.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="les-nodelist"><a href="#les-nodelist" class="phenomic-HeadingAnchor">#</a>Les <em>NodeList</em></h3>
<pre><code class="hljs language-js"><span class="hljs-comment">// Note: cela ne fonctionnera que sur les environnements</span>
<span class="hljs-comment">// impl√©mentant NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// ce code ajoute une class "read" √† toutes les balises &lt;p&gt;</span>
<span class="hljs-comment">// contenues dans la(les) balises &lt;article&gt;</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="les-maps"><a href="#les-maps" class="phenomic-HeadingAnchor">#</a>Les <em>Maps</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="les-sets"><a href="#les-sets" class="phenomic-HeadingAnchor">#</a>Les <em>Sets</em></h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="les-generators"><a href="#les-generators" class="phenomic-HeadingAnchor">#</a>Les <em>Generators</em></h3>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>Et les objets traditionnels dans tout √ßa ?</p>
</blockquote>
<p>√âtonnamment, les objets ne peuvent pas √™tre parcourus avec cette nouvelle
boucle sauf s&#x27;ils d√©finissent le symbole <code>Symbol.iterator</code>. Heureusement,
il existe une solution de contournement par l&#x27;utilisation de
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a>
ou encore
d&#x27;<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/values"><code>Object.values()</code></a>
et
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/entries"><code>Object.entries()</code></a>
(ajouts ECMAScript7).</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>Exemple d√©finissant un it√©rateur :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> iterableObj = {
  *[<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-keyword">yield</span>* <span class="hljs-built_in">Object</span>.entries(obj);
  }
};

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [key, val] <span class="hljs-keyword">of</span> iterableObj ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + val); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="en-rsum"><a href="#en-rsum" class="phenomic-HeadingAnchor">#</a>En r√©sum√©</h2>
<p><code>for..of</code> vient compl√©ter les lacunes de <code>for..in</code> et permet
une it√©ration simplifi√©e sur les <em>objets it√©rables</em> tels que :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String">String</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/">Maps &amp; WeakMaps</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments">arguments</a></li>
</ul>
<p>De plus, <code>for..of</code> r√©sout √† pr√©sent les pi√®ges tels que l&#x27;ordre d&#x27;it√©ration non
constant ou la coercion
automatique des index en cha√Æne de caract√®res.</p>
<h2 id="pour-aller-plus-loin"><a href="#pour-aller-plus-loin" class="phenomic-HeadingAnchor">#</a>Pour aller plus loin</h2>
<p>La boucle <code>for..of</code> est donc une corde de plus √† l&#x27;arc de l&#x27;ES6 qui
permet de parcourir, de mani√®re native, les tout nouveaux <em>objets it√©rables</em> du
langage.</p>
<p>Pour en savoir plus sur ses sp√©cificit√©s :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of">Documentation
MDN</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">Le post de Jason
Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">Le post de Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">Specification
ECMA-262</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Arrow functions]]></title><description><![CDATA[<p>ES2015 brings us some new syntax sugar that will likely make you stop using
<code>Function.prototype.bind()</code>.</p>
<p>Arrow functions are just a function shorthand using the <code>=&gt;</code> syntax.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Arrow functions are syntactically similar to the related feature that exists in
other languages like CoffeeScript, Java (8+), C#‚Ä¶</p>
<p>They support both expression and statement bodies.
In our example above, we have seen a classic statement.
But for simple function, we can use an simple expression, to make things shorter.
That means that the previous example can be also written like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Note that when you have only one argument, you can omit parenthesis around it.
So we can also wrote the example like this</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>And you can also wrap the body in parenthesis if you want to make a multiline expression</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// that can be multilines, you can imagine some JSX here ;)</span>
)</code></pre>
<p>So this examples are all the same¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>In practice you will use this small functions in method like Array
reduce/filter/map etc.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="arrow-functions-dont-have-a-this"><a href="#arrow-functions-dont-have-a-this" class="phenomic-HeadingAnchor">#</a>Arrow functions don‚Äôt have a <code>this</code></h2>
<p>Yes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.
So that means the <code>this</code> you might use use in the body of an arrow function refer to the parent scope:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Someone = {
  name: ‚ÄúMoOx‚Äù,
  friends: [], <span class="hljs-comment">// he got no friends atm :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` is not the function of the forEach !</span>
    )
  }
}</code></pre>
<p>By reading this code, you might understand that you are likely to stop using
<code>bind()</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> ‚Äúreact‚Äù
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stuff</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  <span class="hljs-comment">// old way</span>
  onClick(e) {
    <span class="hljs-keyword">this</span>.setState({ omg: <span class="hljs-literal">false</span> })
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        { /* old way */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.onClick.bind</span>(<span class="hljs-attr">this</span>) }&gt;</span>
          Old binded call
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* LOOK MA', NO BIND ! */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.onClick(e) }&gt;
          I don‚Äôt need `bind` anymore !
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* Simpler way */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;
          Hell yeah
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<h2 id="note-about-expression-body-and-object"><a href="#note-about-expression-body-and-object" class="phenomic-HeadingAnchor">#</a>Note about expression body and Object</h2>
<p>If you want to return an object you might be surprised to get <code>undefined</code>
with this code:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}</code></pre>
<p>Indeed the above snippet could be translated into ES5 this way:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> aFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
  key:         <span class="hljs-comment">// Defines a label named `key`</span>
    obj.value  <span class="hljs-comment">// Gets `obj.value`</span>
               <span class="hljs-comment">// Implicit returns `undefined`</span>
}</code></pre>
<p>Keep in mind that in this context, a brace is to start a statement body, not an
object.
So you will need this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>But wait, there is a trick: a stupid couple of parenthesis.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works!</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">compatibility table</a>.
You will see that arrow functions are already supported by most browsers but you
might need <a href="http://babeljs.io">Babel</a> to use it today.</p>
<p>You will probably use this more and more.
Even if <code>function</code> keyword is not dead, arrow functions <code>=&gt;</code> are probably
going to be a thing !</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les fonctions fl√©ch√©es]]></title><description><![CDATA[<p>ES2015 nous apporte encore du sucre syntaxique qui risque tr√®s probablement de
vous faire oublier <code>Function.prototype.bind()</code>.</p>
<p>Les fonctions fl√©ch√©es offrent une syntaxe raccourcie des fonctions en utilisant
la syntaxe <code>=&gt;</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Les fonctions fl√©ch√©es sont syntaxiquement similaires √† ce qu&#x27;on trouve d√©j√† dans
d&#x27;autres langages comme CoffeeScript, Java (8+), C#‚Ä¶</p>
<p>Elles supportent les expressions ou les blocs en tant que corps de fonction.
Dans notre exemple pr√©c√©dent, nous avons utilis√© un corps classique.
Pour de simples fonctions, nous pouvons utiliser des expressions, le but √©tant
d&#x27;avoir quelque chose de concis.
Notre exemple pr√©c√©dent peut ainsi s&#x27;√©crire de la sorte¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Notez que lorsque l&#x27;on a qu&#x27;un argument dans notre fonction, on peut omettre les
parenth√®ses. Notre exemple peut donc aussi s&#x27;√©crire ainsi¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Si notre expression m√©rite d&#x27;√™tre sur plusieurs lignes, on peut aussi utiliser des
parenth√®ses¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX</span>
)</code></pre>
<p>Les exemples suivants sont donc tous les m√™mes¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>Dans la pratique, vous utiliserez souvent cette syntaxe pour des petites m√©thodes
comme par exemple lors de l&#x27;utilisation des fonctions de tableau
reduce/filter/map, etc.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="les-fonctions-flches-nont-pas-de-this"><a href="#les-fonctions-flches-nont-pas-de-this" class="phenomic-HeadingAnchor">#</a>Les fonctions fl√©ch√©es n&#x27;ont pas de <code>this</code></h2>
<p>Oui, vous avez bien lu¬†: √† l&#x27;inverse des fonctions normales, les fonctions
fl√©ch√©es partagent le m√™me <code>this</code> lexical que leur scope parent.
Du coup, le <code>this</code> que vous pourrez utiliser dans votre corps de fonction
fl√©ch√©e est celui du code parent¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> Someone = {
  name: ‚ÄúMoOx‚Äù,
  friends: [], <span class="hljs-comment">// Malheureusement, il n'a pas d'amis :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` ne r√©f√®re pas √† la fonction fl√©ch√©e du forEach !</span>
    )
  }
}</code></pre>
<p>En lisant ce code, vous avez peut √™tre compris qu&#x27;il peut √™tre possible de ne
plus avoir besoin du <code>bind()</code> aussi souvent que √ßa pouvait √™tre le cas¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> ‚Äúreact‚Äù
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stuff</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{

  <span class="hljs-comment">// √† l'ancienne</span>
  onClick(e) {
    <span class="hljs-keyword">this</span>.setState({ omg: <span class="hljs-literal">false</span> })
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        { /* √† l'ancienne */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.onClick.bind</span>(<span class="hljs-attr">this</span>) }&gt;</span>
          Old binded call
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* REGARDE MAMAN, JE BIND RIEN */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.onClick(e) }&gt;
          I don‚Äôt need `bind` anymore !
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        { /* Encore plus simplement */ }
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> this.setState({ omg: true }) }&gt;
          Hell yeah
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}</code></pre>
<h2 id="note-sur-les-expressions-et-les-objets"><a href="#note-sur-les-expressions-et-les-objets" class="phenomic-HeadingAnchor">#</a>Note sur les expressions et les objets</h2>
<p>Si vous voulez retourner un objet, vous serez surement supris de ne pas obtenir
le r√©sultat attendu avec ce code :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}
<span class="hljs-built_in">console</span>.log(aFn()) <span class="hljs-comment">// undefined</span></code></pre>
<p>En effet, l&#x27;exemple ci-dessus pourrait √™tre traduit en ES5 de la mani√®re suivante :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> aFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>{
  key:         <span class="hljs-comment">// Defines a label named `key`</span>
    obj.value  <span class="hljs-comment">// Gets `obj.value`</span>
               <span class="hljs-comment">// Implicit returns `undefined`</span>
}</code></pre>
<p>Gardez en t√™te que dans ce contexte, une accolade ouvre un corps de fonction,
pas un objet.
Vous devrez donc faire comme ceci¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>Mais attendez, avec une simple astuce, on s&#x27;en sort avec un couple de
parenth√®ses¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works !</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Regardez
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">la table de compatibilit√©</a>.
C&#x27;est plut√¥t bien support√© par la plupart des navigateurs, mais vous risquez
s√ªrement d&#x27;avoir √† utiliser <a href="http://babeljs.io">Babel</a> afin d&#x27;√™tre tranquille.</p>
<p>Vous verrez que vous utiliserez les fonctions fl√©ch√©es de plus en plus.
M√™me si le mot cl√© <code>function</code> n&#x27;est pas mort, les fonctions fl√©ch√©es ont un
avenir certain !</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES2016 (?): fonctions asynchrones (async/await)]]></title><description><![CDATA[<p>Aujourd&#x27;hui, une fonctionnalit√© peut-√™tre abusivement tagg√©e &quot;ES6&quot; puisqu&#x27;elle ne
fait pas partie des propositions accept√©es cette ann√©e : les fonctions asynchrones (async/await).
La <a href="https://tc39.github.io/ecmascript-asyncawait/">sp√©cification</a> est encore au
stade 3 (candidate) √† l&#x27;heure de cet article. Mais il ne fait plus aucun doute
qu&#x27;elle (ou une variante) fera partie de la sp√©cification ES2016.</p>
<h2 id="fonctions-asynchrones"><a href="#fonctions-asynchrones" class="phenomic-HeadingAnchor">#</a>Fonctions asynchrones</h2>
<p>Pour les traitements asynchrones, vous connaissez d√©j√†
<a href="/fr/articles/js/es2015/promises/">les promesses</a> qui ont
√©videmment remplac√© les callbacks dans votre code. Si vous n&#x27;avez pas d√©j√† fait
la bascule vers les promesses (ne serait-ce que pour la propagation d&#x27;erreur),
<a href="/fr/articles/js/es2015/generators/">les g√©n√©rateurs</a> ont
d√ª finir de vous convaincre gr√¢ce aux <a href="/fr/articles/js/es2015/generators/#use-case-co-routines">coroutines</a>.</p>
<p>Nous allons voir aujourd&#x27;hui une nouvelle mani√®re de traiter les fonctions
asynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d&#x27;elles.</p>
<h2 id="exemple-de-traitement-asynchrone-promise"><a href="#exemple-de-traitement-asynchrone-promise" class="phenomic-HeadingAnchor">#</a>Exemple de traitement asynchrone‚ÄØ: Promise</h2>
<p>Partons du programme suivant ex√©cut√© le
6 d√©cembre dernier dont l&#x27;API est bas√©e sur les promesses‚ÄØ:</p>
<ul>
<li>Il r√©cup√®re tous les utilisateurs pr√©nomm√©s Nicolas</li>
<li>Il envoie un mail √† chacun pour souhaiter bonne f√™te</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> usersP = getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-comment">// On r√©cup√®re le champ "email" de tous les utilisateurs</span>
  <span class="hljs-keyword">const</span> emailsP = usersP.then((users) =&gt; users.map(u =&gt; u.email))
  <span class="hljs-comment">// Pour chaque email‚Ä¶</span>
  <span class="hljs-keyword">const</span> sentP = emailsP.then((emails) =&gt; emails.map((email) =&gt; {
    <span class="hljs-comment">// ‚Ä¶ on envoie un mail</span>
    <span class="hljs-keyword">return</span> sendMail(email, <span class="hljs-string">'Bonne f√™te'</span>)
  }))
  <span class="hljs-comment">// On attend que tous les envois soient r√©solus</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
  .then(() =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>))
  .catch(() =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>))</code></pre>
<h2 id="nouveaux-mot-cls-async-et-await"><a href="#nouveaux-mot-cls-async-et-await" class="phenomic-HeadingAnchor">#</a>Nouveaux mot-cl√©s <code>async</code> et <code>await</code></h2>
<p>Une fonction peut √™tre marqu√©e comme asynchrone lorsque pr√©fix√©e par <code>async</code>‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ‚Ä¶</span>
}</code></pre>
<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le
mot-cl√© <code>await</code> devient disponible. Lorsqu&#x27;il est utilis√© en pr√©fixe d&#x27;une
promesse, l&#x27;√©valuation de l&#x27;expression est &quot;mise en pause&quot; jusqu&#x27;√† la r√©solution
(ou le rejet) de la promesse‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> aPromise
  <span class="hljs-comment">// on n'arrivera √† cette ligne que lorsque "aPromise" sera r√©solue</span>
}</code></pre>
<p>√âvidemment, l&#x27;expression a alors pour valeur celle de r√©solution de la
promesse, et en cas d&#x27;erreur l&#x27;expression va lever (<code>throw</code>) une erreur‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> aPromise
    <span class="hljs-comment">// Ici "aPromise" est r√©solue avec la valeur "result"</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// Ici "aPromise" est rejet√©e avec l'erreur "err"</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// cette ligne n'est atteinte qu'apr√®s r√©solution/rejet</span>
}</code></pre>
<p>Concr√®tement, si vous vous souvenez de l&#x27;article sur les g√©n√©rateurs et de la
partie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et
<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>
<h2 id="notre-premier-exemple-avec-les-fonctions-asynchrones"><a href="#notre-premier-exemple-avec-les-fonctions-asynchrones" class="phenomic-HeadingAnchor">#</a>Notre premier exemple, avec les fonctions asynchrones</h2>
<p>R√©√©crivons notre premier exemple avec des fonctions asynchrones‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-keyword">const</span> emails = users.map(u =&gt; u.email)
  <span class="hljs-keyword">const</span> sentP = emails.map((email) =&gt; sendMail(email, <span class="hljs-string">'Bonne f√™te'</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

<span class="hljs-comment">// Attention, on ne peut pas utiliser "await" hors d'une fonction "async"</span>
<span class="hljs-comment">// il faut donc "wrapper" notre code autour d'une fonction asynchrone</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>)
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>)
  }
}

main()</code></pre>
<p>Mieux‚ÄØ? Moins bien‚ÄØ? Question de go√ªt, mais on retrouve un code imp√©ratif plus
habituel.</p>
<h2 id="attention-au-pige-de-lexcution-en-srie"><a href="#attention-au-pige-de-lexcution-en-srie" class="phenomic-HeadingAnchor">#</a>Attention au pi√®ge de l&#x27;ex√©cution en s√©rie‚ÄØ!</h2>
<p>Prenons l&#x27;exemple de requ√™tes qu&#x27;on ex√©cute en concurrence avant d&#x27;utiliser
leurs r√©sultats‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requ√™te Ajax</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requ√™te BDD</span>
<span class="hljs-keyword">const</span> resultP = <span class="hljs-built_in">Promise</span>.all([xP, yP]).then(sum)</code></pre>
<p>Dans cet exemple, les requ√™tes sont lanc√©es, ex√©cut√©es en parall√®le puis leurs
retours attendus avant de passer √† la suite.</p>
<p>Si on le traduit b√™tement ainsi, on perd l&#x27;aspect concurrentiel‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> getX() <span class="hljs-comment">// Requ√™te Ajax‚Ä¶</span>
<span class="hljs-comment">// ‚Ä¶ requ√™te termin√©e‚ÄØ!</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> getY() <span class="hljs-comment">// Requ√™te BDD‚Ä¶</span>
<span class="hljs-comment">// ‚Ä¶ requ√™te termin√©e‚ÄØ!</span>
<span class="hljs-keyword">const</span> result = sum([x, y])</code></pre>
<p>Il faudra bien distinguer le moment o√π on souhaite <strong>d√©marrer l&#x27;action</strong> et le
moment o√π l&#x27;on souhaite <strong>disposer de son r√©sultat</strong>, il y a plusieurs mani√®res
de r√©soudre le probl√®me, qui d√©pendent essentiellement du go√ªt du d√©veloppeur ;)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requ√™te Ajax d√©marr√©e‚Ä¶</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requ√™te BDD d√©marr√©e‚Ä¶</span>

<span class="hljs-comment">// Version 1‚ÄØ:</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> xP <span class="hljs-comment">// ‚Ä¶requ√™te Ajax termin√©e‚ÄØ!</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> yP <span class="hljs-comment">// ‚Ä¶requ√™te BDD termin√©e‚ÄØ!</span>
<span class="hljs-keyword">const</span> result = sum([x, y])

<span class="hljs-comment">// Version 2 avec un tableau‚ÄØ:</span>
<span class="hljs-keyword">const</span> vars = [<span class="hljs-keyword">await</span> xP, <span class="hljs-keyword">await</span> yP]
<span class="hljs-keyword">const</span> result = sum(vars)

<span class="hljs-comment">// Version 3 avec Promise.all‚ÄØ:</span>
<span class="hljs-keyword">const</span> vars = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([xP, yP])
<span class="hljs-keyword">const</span> result = sum(vars)</code></pre>
<h2 id="et-aujourdhui"><a href="#et-aujourdhui" class="phenomic-HeadingAnchor">#</a>Et aujourd&#x27;hui‚ÄØ?</h2>
<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un
code bas√© sur les g√©n√©rateurs‚ÄØ: il vous suffira d&#x27;ajouter les plugins Babel
<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention √†
inclure <code>babel-polyfill</code> en fichier d&#x27;entr√©e).</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Gr√¢ce aux fonctions asynchrones, la refactorisation d&#x27;un code bloquant vers un
code non bloquant devient vraiment ais√©e. Les promesses simplifiaient d√©j√† le
processus mais on n&#x27;√©tait pas d√©barass√© des callbacks. L√†, √† deux mot-cl√©s pr√®s,
c&#x27;est exactement la m√™me chose‚ÄØ!</p>
<p>D&#x27;un certain c√¥t√©, c&#x27;est un retour en arri√®re‚ÄØ: l&#x27;asynchrone m√®ne aux promesses,
qui m√®nent √† la programmation fonctionnelle, qui apporte tant de bienfaits‚Ä¶ Il
s&#x27;agira de trouver le bon √©quilibre, je ne suis pas convaincu d&#x27;abandonner mes
<code>.then</code> tout de suite, mais il est certain que c&#x27;est une v√©ritable avanc√©e
pour ce langage‚ÄØ: la courbe d&#x27;apprentissage des traitements asynchrones va √™tre
drastiquement aplanie ;)</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2016/async-await/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2016/async-await/</guid><pubDate>Mon, 14 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les nouvelles m√©thodes d'Array]]></title><description><![CDATA[<p><del>ES6</del>  ES2015 enrichit les objets de la bibilioth√®que standard de nouvelles fonctionnalit√©s.
Voici les nouveaut√©s que l&#x27;on va trouver dans <code>Array</code>.</p>
<h2 id="arrayfrom"><a href="#arrayfrom" class="phenomic-HeadingAnchor">#</a>Array.from()</h2>
<p>Parmi les nouvelles m√©thodes ajout√©es √† Array, <code>Array.from()</code> est peut-√™tre celle que vous allez utiliser le plus souvent. Elle va nous permettre de cr√©er un tableau √† partir d&#x27;un it√©rable ou d&#x27;un objet qui ressemble √† un tableau comme une NodeList, ou encore <code>arguments</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySeletorAll(<span class="hljs-string">'div'</span>))
nodes.forEach(node =&gt; <span class="hljs-built_in">console</span>.log(node))</code></pre>
<h2 id="arrayof"><a href="#arrayof" class="phenomic-HeadingAnchor">#</a>Array.of()</h2>
<p>Cette m√©thode va permettre de cr√©er un tableau √† partir des arguments re√ßus.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.of(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)
<span class="hljs-built_in">console</span>.log(arr.join(<span class="hljs-string">" "</span>)) <span class="hljs-comment">// "hello world"</span></code></pre>
<h2 id="arrayprototypekeys--arrayprototypeentries"><a href="#arrayprototypekeys--arrayprototypeentries" class="phenomic-HeadingAnchor">#</a>Array.prototype.keys() &amp; Array.prototype.entries()</h2>
<p>On retrouve aussi ces m√©thodes sur d&#x27;autres it√©rables comme Map ou Set.
<code>Array.prototype.keys()</code> va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau pass√©es en param√®tre¬†:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr =  [...Array(<span class="hljs-number">3</span>).keys()]
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [0,1,2]</span></code></pre>
<p><code>Array.prototype.entries()</code> quant √† lui va renvoyer un tableau compos√© des paires cl√©/valeur¬†:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>]
<span class="hljs-built_in">console</span>.log(arr.entries()) <span class="hljs-comment">// [[0, "hello"], [1, "world"]]</span></code></pre>
<h2 id="arrayprototypefind"><a href="#arrayprototypefind" class="phenomic-HeadingAnchor">#</a>Array.prototype.find()</h2>
<p>Cette m√©thode va permettre de renvoyer une valeur contenue dans le tableau si celle-ci v√©rifie
la condition d√©finie par la fonction de pr√©dicat pass√©e en param√®tre. On retrouve le m√™me principe qu&#x27;avec <code>filter</code>, <code>some</code> et <code>every</code>. Si aucune valeur ne
valide la fonction de pr√©dicat, alors la m√©thode renverra <code>undefined</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [{id:<span class="hljs-number">1</span>, label:<span class="hljs-string">"hello"</span>}, {id:<span class="hljs-number">2</span>, name: <span class="hljs-string">"world"</span>}]
<span class="hljs-keyword">const</span> found = arr.find(item =&gt; item.id === <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> notfound = arr.find(item =&gt; item.id === <span class="hljs-number">3</span>)
<span class="hljs-built_in">console</span>.log(found, notfound) <span class="hljs-comment">// {id:2, name: "worl"}, undefined</span></code></pre>
<p>√Ä noter qu&#x27;il existe aussi <code>Array.prototype.findIndex()</code> qui renverra non pas l&#x27;objet, mais l&#x27;index de l&#x27;objet qui validera la fonction de pr√©dicat.</p>
<h2 id="arrayprototypefill"><a href="#arrayprototypefill" class="phenomic-HeadingAnchor">#</a>Array.prototype.fill()</h2>
<p>Cette m√©thode va permettre de remplir un tableau avec une valeur pass√©e en param√®tre. Il est toutefois possible de d√©finir un index de d√©but et un index de fin (comme avec slice par exemple) si l&#x27;on ne souhaite remplacer qu&#x27;une partie du tableau.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).fill(<span class="hljs-number">1</span>)
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [1,1,1]</span></code></pre>
<h2 id="arrayprototypecopywithin"><a href="#arrayprototypecopywithin" class="phenomic-HeadingAnchor">#</a>Array.prototype.copyWithin()</h2>
<p>Cette m√©thode va permettre de renvoyer un nouveau tableau en rempla√ßant une partie du tableau par une s√©quence de ce dernier. Pour cela, on va indiquer √† partir de quel index on souhaite d√©marrer la copie de la s√©quence, ainsi que l&#x27;index de d√©but et de fin de la s√©quence que l&#x27;on souhaite voir r√©p√©t√©e.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>,<span class="hljs-string">"alice"</span>, <span class="hljs-string">"my"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"is"</span> <span class="hljs-string">"bob"</span>]
<span class="hljs-built_in">console</span>.log(arr.copyWithin(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]) <span class="hljs-comment">//  "hello","bob", "my", "name", "is" "bob"]</span></code></pre>
<p>Certaines m√©thodes ne paraissent pas forc√©ment super utiles alors n&#x27;h√©sitez √† utiliser les commentaires pour partager des exemples d&#x27;utilisation plus int√©ressants üòõ</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</guid><pubDate>Sun, 13 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : param√®tres rest et op√©rateur spread]]></title><description><![CDATA[<p>Identiques en apparence et en syntaxe, ils permettent d&#x27;effectuer plus
simplement des op√©rations complexes sur les tableaux, ou tout autre objet
it√©rable.</p>
<h2 id="les-paramtres-rest"><a href="#les-paramtres-rest" class="phenomic-HeadingAnchor">#</a>Les param√®tres rest</h2>
<p>Avez-vous d√©j√† eu l&#x27;occasion d&#x27;utiliser l&#x27;horrible variable magique <code>arguments</code>¬†?
Disponible au sein de chaque fonction, elle permet d&#x27;en r√©cup√©rer, comme son
nom l&#x27;indique, les arguments. Si l&#x27;objet r√©cup√©r√© est similaire √† un <code>Array</code>,
il ne dispose d&#x27;aucune des propri√©t√©s ou des m√©thodes de celui-ci, √†
l&#x27;exception de <code>length</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">separator</span>) </span>{
  <span class="hljs-comment">// conversion n√©cessaire en objet de type Array</span>
  <span class="hljs-keyword">var</span> words = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> words.join(separator)
}

myFunction(<span class="hljs-string">"-"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>) <span class="hljs-comment">// "foo-bar"</span></code></pre>
<p>Les param√®tres rest vous permettent de r√©cup√©rer un v√©ritable <code>Array</code> √† l&#x27;aide
du simple pr√©fixe <code>...</code> appliqu√© sur le <strong>dernier</strong> argument de votre fonction.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">separator, ...words</span>) </span>{
  <span class="hljs-keyword">return</span> words.join(separator)
}

myFunction(<span class="hljs-string">"-"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>) <span class="hljs-comment">// "foo-bar"</span></code></pre>
<p>Il vous sera en revanche impossible de lui attribuer une <a href="/fr/articles/js/es2015/defaults/">valeur par d√©faut</a>.</p>
<h2 id="loprateur-spread"><a href="#loprateur-spread" class="phenomic-HeadingAnchor">#</a>L&#x27;op√©rateur spread</h2>
<p>Aussi appel√© op√©rateur de d√©composition, il permet de d√©velopper un objet
it√©rable (comme un <code>Array</code>) lorsqu&#x27;on a besoin de plusieurs arguments.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">1991</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(...myArray) <span class="hljs-comment">// object Date - √©quivaut √†: new Date(1991, 8, 1)</span>

<span class="hljs-keyword">const</span> myString = <span class="hljs-string">"foo bar"</span>
<span class="hljs-comment">// les objets String √©tant it√©rables</span>
[...myString] <span class="hljs-comment">// ["f", "o", "o", " ", "b", "a", "r"]</span></code></pre>
<p>√Ä noter que contrairement aux param√®tres rest, l&#x27;op√©rateur spread peut √™tre
m√©lang√© aux autres arguments d&#x27;une fonction.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">8</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1991</span>, ...myArray, <span class="hljs-number">12</span>) <span class="hljs-comment">// object Date - √©quivaut √†: new Date(1991, 8, 1, 12)</span></code></pre>
<p>Les possibilit√©s offertes par cette nouveaut√© sont tr√®s nombreuses. Voici
quelques usages un peu plus avanc√©s pour stimuler votre inspiration¬†:</p>
<h4 id="viter-lutilisation-de-apply"><a href="#viter-lutilisation-de-apply" class="phenomic-HeadingAnchor">#</a>√âviter l&#x27;utilisation de .apply()</h4>
<pre><code class="hljs language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>])

<span class="hljs-comment">// ES6 / ES2015</span>
<span class="hljs-built_in">console</span>.log(...[<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>]) <span class="hljs-comment">// m√™me r√©sultat</span></code></pre>
<h4 id="concatner-plusieurs-itrables"><a href="#concatner-plusieurs-itrables" class="phenomic-HeadingAnchor">#</a>Concat√©ner plusieurs it√©rables</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> stronglyTyped = [<span class="hljs-string">"scala"</span>, <span class="hljs-string">"haskell"</span>]

<span class="hljs-comment">// ES5</span>
[<span class="hljs-string">"go"</span>, <span class="hljs-string">"rust"</span>].concat(stronglyTyped) <span class="hljs-comment">// ["go", "rust", "scala", "haskell"]</span>

<span class="hljs-comment">// ES6 / ES2015</span>
[<span class="hljs-string">"go"</span>, <span class="hljs-string">"rust"</span>, ...stronglyTyped] <span class="hljs-comment">// ["go", "rust", "scala", "haskell"]</span></code></pre>
<h4 id="dstructurer-dans-un-tableau"><a href="#dstructurer-dans-un-tableau" class="phenomic-HeadingAnchor">#</a>D√©structurer dans un tableau</h4>
<p>Si vous n&#x27;avez pas encore connaissance des possibilit√©s offertes par le
destructuring, je vous invite √† lire ce <a href="/fr/articles/js/es2015/destructuring/">pr√©c√©dent article</a>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"baz"</span>]

<span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">const</span> first = words[<span class="hljs-number">0</span>] <span class="hljs-comment">// "foo"</span>
<span class="hljs-keyword">const</span> rest = words.slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// ["bar", "baz"]</span>

<span class="hljs-comment">// ES6 / ES2015</span>
<span class="hljs-keyword">const</span> [first, ...rest] = words <span class="hljs-comment">// m√™me r√©sulat</span></code></pre>
<h4 id="itrer-sur-le-rsultat-dun-queryselectorall"><a href="#itrer-sur-le-rsultat-dun-queryselectorall" class="phenomic-HeadingAnchor">#</a>It√©rer sur le r√©sultat d&#x27;un .querySelectorAll()</h4>
<pre><code class="hljs language-js">[...document.querySelectorAll(<span class="hljs-string">'div'</span>)] <span class="hljs-comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></code></pre>
<h2 id="en-rsum"><a href="#en-rsum" class="phenomic-HeadingAnchor">#</a>En r√©sum√©</h2>
<p>Comme vous avez pu le constater par vous-m√™me, les cas d&#x27;utilisation des
param√®tres rest et de l&#x27;op√©rateur spread sont l√©gion.</p>
<p><a href="http://kangax.github.io/compat-table/es6/#spread_(...)_operator">G√©r√©s</a>
correctement par Babel et Traceur, ils vous permettront de rendre votre code
plus concis en √©vitant bien souvent l&#x27;√©criture de boucles inutiles.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/rest-spread/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/rest-spread/</guid><pubDate>Sat, 12 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les Maps & WeakMaps]]></title><description><![CDATA[<h2 id="maps"><a href="#maps" class="phenomic-HeadingAnchor">#</a>Maps</h2>
<p>Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La diff√©rence avec un objet, c&#x27;est que n&#x27;importe quelle valeur peut √™tre utilis√©e comme cl√©.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
myMap.set(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>)
myMap.get(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// 1</span></code></pre>
<p>Pour cr√©er une map avec des valeurs, on peut passer un tableau de cl√©s/valeurs en argument :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [ <span class="hljs-number">1</span>, <span class="hljs-string">"foo"</span> ],
  [ <span class="hljs-built_in">window</span>, <span class="hljs-string">"bar"</span> ],
])</code></pre>
<p>Pour tester si une cl√© est pr√©sente, on peut utiliser la m√©thode <code>has</code> :</p>
<pre><code class="hljs language-javascript">map.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span></code></pre>
<p>On peut it√©rer sur les entr√©es d&#x27;une map √† l&#x27;aide de <code>forEach</code> :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [ <span class="hljs-number">1</span>, <span class="hljs-string">"foo"</span> ],
  [ <span class="hljs-built_in">window</span>, <span class="hljs-string">"bar"</span> ],
])

myMap.forEach((value, key) =&gt; {
	<span class="hljs-comment">// do something</span>
})</code></pre>
<p>On peut aussi it√©rer √† l&#x27;aide du <code>for ‚Ä¶ of</code> :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) {
  <span class="hljs-built_in">console</span>.log(key, value)
}</code></pre>
<p>Ainsi que convertir la map en tableau √† l&#x27;aide du spread, puisqu&#x27;une map est it√©rable :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myEntries = [...myMap] <span class="hljs-comment">// [‚Ä¶[key, value]]</span>
<span class="hljs-keyword">const</span> myEntries = [...myMap.entries()] <span class="hljs-comment">// alternativement</span></code></pre>
<p>On peut aussi r√©cup√©rer des it√©rables par cl√©s et valeurs :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myKeys = [...myMap.keys()]
<span class="hljs-keyword">const</span> myValues = [...myMap.values()]</code></pre>
<p>Particularit√©, la valeur <code>NaN</code>, qui en JS n&#x27;est pas √©gale √† elle m√™me, est bien g√©r√©e :</p>
<pre><code class="hljs language-javascript">myMap.set(<span class="hljs-literal">NaN</span>, <span class="hljs-number">1</span>)
myMap.get(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// 1</span></code></pre>
<p>Une utilisation possible des Maps est la fonction <code>dedupe</code> pour √©liminer les doublons d&#x27;un array :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> dedupe = (array) =&gt; {
  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Map</span>(array.map((item) =&gt; [item, <span class="hljs-literal">true</span>])).keys()]
}

dedupe([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment">// [1, 2, 3, 4]</span></code></pre>
<h2 id="weakmaps"><a href="#weakmaps" class="phenomic-HeadingAnchor">#</a>WeakMaps</h2>
<p>Les WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs &quot;oubli√©es&quot;. Le garbage collector ne tient donc pas compte des weak maps.</p>
<p>Les WeakMaps ne poss√®dent pas de m√©thodes d&#x27;it√©ration et n&#x27;acceptent pas de valeurs primitives comme cl√©s.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()
myWeakMap.set(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// TypeError</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()
myWeakMap.set(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>)
(() =&gt; {
  <span class="hljs-keyword">const</span> object = {}
  myWeakMap.set(object, <span class="hljs-number">2</span>)
})()
<span class="hljs-comment">// myWeakMap a oubli√© la valeur 2, car `object` n'est plus accessible</span>
<span class="hljs-comment">// seule la cl√© `window` persiste.</span></code></pre>
<p>Un usage possible est le stockage d&#x27;informations li√© √† une instance de classe, permettant de &quot;cacher&quot; cette information de l&#x27;instance :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> callbacks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleEventEmitter</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    callbacks.set(<span class="hljs-keyword">this</span>, [])
  }
  addEventListener(callback) {
    callbacks.set(<span class="hljs-keyword">this</span>, callbacks.get(<span class="hljs-keyword">this</span>).concat(callback))
  }
  removeEventListener(callback) {
    callbacks.set(<span class="hljs-keyword">this</span>, callbacks.get(<span class="hljs-keyword">this</span>)
      .filter((func) =&gt; func !== callback))
  }
  triggerEvent(...args) {
    callbacks.get(<span class="hljs-keyword">this</span>).forEach((func) =&gt; func(...args))
  }
}</code></pre>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/</guid><pubDate>Fri, 11 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : iterators and generators]]></title><description><![CDATA[<p>ES2015 brings a lot of syntax sugar but not a lot of new real features.
Generators are a new feature to generate iterators that follow the
<a href="/en/articles/js/es2015/iterators/">iterator protocol</a>.
They allow to take control of the execution of a function from the outside.</p>
<h2 id="idle-function"><a href="#idle-function" class="phenomic-HeadingAnchor">#</a>Idle function</h2>
<p>A function followed by an asterisk (<code>function*</code>) is never executed directly
and instead calling it will return an iterator.
A generator is able to pause itself (and will do that by default).
It&#x27;s also capable of continue where it was paused: the iterator returned is an
object that contains a <code>next</code> method which allows (when you call it) to
continue the execution of the generator where it was paused.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// The execution is paused, and is waiting to be continued</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// The execution will now continue and will log "World"</span></code></pre>
<p>Note that this is not <strong>blocking</strong> code: the function is paused, the execution
can continue later, but meanwhile, the <em>event-loop</em> is still running.</p>
<h2 id="emitting-new-values-with-yield"><a href="#emitting-new-values-with-yield" class="phenomic-HeadingAnchor">#</a>Emitting new values with <code>yield</code></h2>
<p>Following the <a href="/en/articles/js/es2015/iterators/">iterator protocol</a>, the
<code>next()</code> method will returns an object with 2 properties¬†:</p>
<ul>
<li><code>done</code> is equal to <code>true</code> when generator has finished its job ex√©cution</li>
<li><code>value</code> is the value emitted by the generator when it become idle</li>
</ul>
<p>How to emit a value ? The keyword <code>yield</code> is made for this:
it will returns a value and idle the execution of the function.
The thing is: you are going to use yield multiple times in the same function.
Otherwise a generator does not make sense, and a simple function with <code>return</code>
is enough.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note: if our generator <code>return</code>s a value, it will be affected to the <code>value</code>
of the last iteration.</p>
<h3 id="use-case-infinite-lists"><a href="#use-case-infinite-lists" class="phenomic-HeadingAnchor">#</a><em>Use case</em>‚ÄØ: infinite lists</h3>
<p>At this stage, the first interesting use case is to handle an infinite list.
We can loop on a list that do not have a precise length.
Here is an example with the Fibonacci sequence to get all results lower than
100‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note‚ÄØ: The <code>for ‚Ä¶ of</code> will be explained in another article.</p>
<h2 id="sending-value-to-the-generator"><a href="#sending-value-to-the-generator" class="phenomic-HeadingAnchor">#</a>Sending value to the generator</h2>
<p>We have seen that <code>yield</code> allows to emit a value from the generator.
The opposite is possible too : <code>next</code> accepts a value that will be returned by
<code>yield</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// the first next() will "start" the generator</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// the first value will be undefined</span>
  <span class="hljs-comment">// x = the argument of the other next() call</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// value of the second iteration‚ÄØ: x + 1</span>
  <span class="hljs-comment">// y = third call of next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// value of the last iteration‚ÄØ: y</span>
  <span class="hljs-comment">// the fourth call and the others will return { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un param√®tre au premier appel √† next() n'est pas utile‚ÄØ: cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le g√©n√©rateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le g√©n√©rateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le g√©n√©rateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>This might sound not really useful, but keep in mind that you can send any type
of data to <code>next()</code>¬†: a function, an object, another iterator...
Possiblities are limitless ! Let&#x27;s take a look to an example using promises.</p>
<h3 id="use-case-co-routines"><a href="#use-case-co-routines" class="phenomic-HeadingAnchor">#</a><em>Use case</em>‚ÄØ: co-routines</h3>
<p>The code of the generator itself cannot be async: call to <code>yield</code> follow each
others synchronously.
The main controller can still be free to call <code>next()</code> when it wants to.</p>
<p>So we have functions that we can play and pause whenever we want.
What if our generator emitted a promise? In order to tell when it&#x27;s time to
continue.
What if the controller, when it knows it got a promise wait for it to be
resolved in order to send back the value to the generator?
This way, the generator will be able to run synchronous code in an non blocking
way when handling async operations¬†:</p>
<pre><code class="hljs language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request‚Ä¶"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work‚Ä¶"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save‚Ä¶"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request‚Ä¶ Work‚Ä¶ Save‚Ä¶ OK.</span></code></pre>
<p>How cool is that? This is clearly the most interesting use case for us and is
actually pretty simple¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// pause‚Ä¶</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// That's the part to detect the last return</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// this is a generator of promise, we we wait for the resolution</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// promise is resolved so we can send back the value to the generator</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// this value is returned by the</span>
      <span class="hljs-comment">// same "yield" which emitted the promise, how convenient is that?</span>

      <span class="hljs-comment">// NEXXXTTTT</span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next()
  <span class="hljs-comment">// we continue the execution until the next "yield"</span>
  <span class="hljs-comment">// the generator will be paused again until the next call to "iter.next"</span>

  <span class="hljs-comment">// We run the first iteration it and return it</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a href="#more-more-more" class="phenomic-HeadingAnchor">#</a>More! more! more!</h2>
<h3 id="error-handling"><a href="#error-handling" class="phenomic-HeadingAnchor">#</a>Error handling</h3>
<p>Errors, like everything, can be emitted in both directions.
The generator can <code>throw</code> (the code is synchronous)¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>The controller can also emit an error inside with the <code>throw</code> method of the
iterator¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note: you need to keep in mind that the first <code>next</code> is used to unlock
the execution of the generator, until the first <code>yield</code>, evaluate the emitted
expression, and send it in the <code>next()</code>, and pause the function.
That&#x27;s the second <code>yield</code> that will continue <strong>from the <code>yield 1</code></strong>.
This is a part not really intuitive that can be hard to understand.</p>
<h3 id="delegation"><a href="#delegation" class="phenomic-HeadingAnchor">#</a>Delegation</h3>
<p>The <code>yield*</code> operator allow to emit value from another iterator¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>That works with all <a href="/en/articles/js/es2015/iterators/"><em>iterables</em></a>¬†:
for example <code>yield * [1, 2, 3]</code> is valid.</p>
<h3 id="anticipated-return"><a href="#anticipated-return" class="phenomic-HeadingAnchor">#</a>Anticipated return</h3>
<p>It&#x27;s possible to end an operation of a generator from the controller using the
<code>return</code> method of the iterator.
Everything will happen like if the generator was ending immediately with the
returned value.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } ‚Üí yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-generators">compatibility table</a>.</p>
<p>Generators bring us a new bundle of feature that allow us to inverse
responsibility¬†: the code that calling the generator can take over the way the
called function will be executed.
They represent a new concept that will probably really change the way we will
code in the incoming months/years¬†:
async function, observables... take their roots in generators.
Understanding generators will helps you to work with those other new features.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : it√©rateurs et g√©n√©rateurs]]></title><description><![CDATA[<p>Un gros morceau aujourd&#x27;hui‚ÄØ: les it√©rateurs et les fonctions qui les g√©n√®rent,
appel√©es &quot;g√©n√©rateurs&quot;.
ES6/2015 apporte √©norm√©ment de &quot;sucres syntaxiques&quot;, m√™me s&#x27;ils sont
terriblement pratiques. Les valeurs par d√©faut, l&#x27;affectation par
d√©structuration, les fonctions fl√™ch√©es‚Ä¶
Tout √ßa n&#x27;apporte pas de r√©elle nouvelle fonctionnalit√©.
C&#x27;est un peu diff√©rent pour les g√©n√©rateurs qui vont permettre de prendre le
contr√¥le sur l&#x27;√©x√©cution d&#x27;une fonction depuis l&#x27;ext√©rieur.</p>
<h2 id="fonction-en-pause"><a href="#fonction-en-pause" class="phenomic-HeadingAnchor">#</a>Fonction &quot;en pause&quot;</h2>
<p>Un nouveau mot-cl√© fait son apparition‚ÄØ: <code>function*</code>, une fonction marqu√©e par
l&#x27;ast√©risque n&#x27;est jamais ex√©cut√©e directement, √† la place, elle retourne un
<em>it√©rateur</em>. Un g√©n√©rateur est donc capable de s&#x27;interrompre (d&#x27;ailleurs, il
l&#x27;est par d√©faut).
Il est √©galement capable de reprendre l√† o√π il s&#x27;√©tait arr√™t√©‚ÄØ:
l&#x27;it√©rateur retourn√© est un objet exposant une m√©thode  <code>next</code> qui
lorsqu&#x27;elle est appel√©e demande au g√©n√©rateur de reprendre l√† o√π il en √©tait.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// L'ex√©cution de la fonction est interrompue en attente d'√™tre "d√©bloqu√©e"</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// L'√©x√©cution reprend et on affiche "World"</span></code></pre>
<p>Notez qu&#x27;il ne s&#x27;agit pas de code <strong>bloquant</strong>‚ÄØ: la fonction est mise en pause,
son traitement sera repris plus tard, pendant ce temps l&#x27;<em>event-loop</em> continue
sa petite vie.</p>
<h2 id="reprise-du-traitement-et-mission-de-valeur-avec-yield"><a href="#reprise-du-traitement-et-mission-de-valeur-avec-yield" class="phenomic-HeadingAnchor">#</a>Reprise du traitement et √©mission de valeur avec <code>yield</code></h2>
<p>La m√©thode <code>next()</code> de l&#x27;it√©rateur retourne un objet poss√©dant les propri√©t√©s
suivantes‚ÄØ:</p>
<ul>
<li><code>done</code> vaut <code>true</code> quand le g√©n√©rateur a termin√© son ex√©cution</li>
<li><code>value</code> est la valeur √©mise par le g√©n√©rateur dans cette portion de code</li>
</ul>
<p>Comment √©mettre une valeur‚ÄØ? Le mot-cl√© <code>yield</code> a le double r√¥le de fournir
une valeur et de remettre en pause l&#x27;ex√©cution de la fonction. Le principe √©tant
qu&#x27;on va √©mettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement
<code>return</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note‚ÄØ: si notre g√©n√©rateur <code>return</code> une valeur, elle sera affect√©e √† la
propri√©t√© <code>value</code> de la derni√®re it√©ration.</p>
<h3 id="use-case-listes-infinies"><a href="#use-case-listes-infinies" class="phenomic-HeadingAnchor">#</a><em>Use case</em>‚ÄØ: listes infinies</h3>
<p>Un premier <em>use case</em> √† ce stade est la possibilit√© de g√©n√©rer des listes de
longueur non d√©finie √† l&#x27;avance. On peut parcourir une suite dont on ne sait pas
√† l&#x27;avance <em>combien</em> d&#x27;√©l√©ments on veut, par exemple r√©cup√©rer tous les √©l√©ments
de la suite de Fibonacci inf√©rieurs √† 100‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note‚ÄØ: l&#x27;op√©rateur <code>for ‚Ä¶ of</code> sera vu plus en d√©tail dans un prochain article.</p>
<h2 id="passage-de-valeur-au-gnrateur"><a href="#passage-de-valeur-au-gnrateur" class="phenomic-HeadingAnchor">#</a>Passage de valeur au g√©n√©rateur</h2>
<p>On a vu que <code>yield</code> permettait d&#x27;√©mettre une valeur depuis le g√©n√©rateur vers
le code contr√¥leur. Mais le sens inverse est √©galement possible‚ÄØ: la m√©thode
<code>next</code> de l&#x27;it√©rateur accepte une valeur en param√®tre, qui sera alors
retourn√©e par l&#x27;appel correspondant √† <code>yield</code>. Exemple‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Le premier appel √† next() permet de "d√©marrer" le g√©n√©rateur</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// la valeur de la premi√®re it√©ration sera undefined</span>
  <span class="hljs-comment">// x = le param√®tre du second appel √† next()</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// valeur de la seconde it√©ration‚ÄØ: x + 1</span>
  <span class="hljs-comment">// y = param√®tre du troisi√®me appel √† next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// valeur de la troisi√®me it√©ration‚ÄØ: y</span>
  <span class="hljs-comment">// le 4e appel (et +) √† next() retournent { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un param√®tre au premier appel √† next() n'est pas utile‚ÄØ: cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le g√©n√©rateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le g√©n√©rateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le g√©n√©rateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>√áa ne semble pas tr√®s utile vu comme √ßa, mais on peut passer √† <code>next()</code>
n&#x27;importe quel type de donn√©e‚ÄØ: une fonction, un objet, un autre it√©rateur‚Ä¶ Les
possibilit√©s sont infinies. On va en explorer une rapidement avec les promesses.</p>
<h3 id="use-case-co-routines"><a href="#use-case-co-routines" class="phenomic-HeadingAnchor">#</a><em>Use case</em>‚ÄØ: co-routines</h3>
<p>Le code du g√©n√©rateur lui-m√™me ne peut √™tre r√©ellement asynchrone‚ÄØ: les appels √†
<code>yield</code> se suivent de mani√®re synchrone. Le code contr√¥leur par contre, est
libre d&#x27;appeler <code>next()</code> √† loisir, et peut donc le faire de mani√®re asynchrone.</p>
<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et
quand elles peuvent reprendre leur traitement. Et si‚Ä¶ notre g√©n√©rateur √©mettait
des promesses‚ÄØ? Histoire d&#x27;expliquer √† son code contr√¥leur <em>quand</em> il est s√ªr de
reprendre le traitement. Et si ce code contr√¥leur, voyant qu&#x27;il r√©cup√®re une
promesse, attendait que cette derni√®re soit r√©solue pour transmettre au
g√©n√©rateur en retour la valeur r√©solue‚ÄØ? Dans ce cas le g√©n√©rateur pourrait
disposer de mani√®re <strong>synchrone</strong> mais <strong>non bloquante</strong> de r√©sultats de
traitements asynchrones‚ÄØ:</p>
<pre><code class="hljs language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request‚Ä¶"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work‚Ä¶"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save‚Ä¶"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request‚Ä¶ Work‚Ä¶ Save‚Ä¶ OK.</span></code></pre>
<p>Ne serait-ce pas merveilleux‚ÄØ? C&#x27;est le <em><em>use case</em></em> le plus int√©ressant pour
nous au quotidien, et c&#x27;est assez simple en fait‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// en pause‚Ä¶</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// Le g√©n√©rateur a return'√©, fin du game</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// c'est un g√©n√©rateur de promesse, dont on attend la r√©solution ici</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// La promesse est r√©solue, on peut repasser sa valeur au g√©n√©rateur</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// cette valeur est return'√©e par</span>
      <span class="hljs-comment">// le m√™me "yield" qui a √©mis la promesse, √ßa tombe bien :)</span>

      <span class="hljs-comment">// Puis on relance notre boucle, et on continue r√©cursivement</span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next() <span class="hljs-comment">// ex√©cution reprise jusqu'au prochain "yield"</span>
  <span class="hljs-comment">// le g√©n√©rateur est remis en pause jusqu'au prochain appel √† "iter.next"</span>

  <span class="hljs-comment">// Premi√®re it√©ration de la boucle</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a href="#more-more-more" class="phenomic-HeadingAnchor">#</a>More! more! more!</h2>
<h3 id="gestion-derreur"><a href="#gestion-derreur" class="phenomic-HeadingAnchor">#</a>Gestion d&#x27;erreur</h3>
<p>Les erreurs, tout comme les valeurs, peuvent √™tre √©mises dans les deux
directions. Le g√©n√©rateur peut <code>throw</code> vers le code contr√¥leur (le code est
synchrone)‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>Mais le code contr√¥leur peut √©galement √©mettre une erreur vers le g√©n√©rateur
avec la m√©thode <code>throw</code> de l&#x27;it√©rateur‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// affiche "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note‚ÄØ: il faut bien se souvenir que le premier <code>next</code> sert √† <em>d√©bloquer</em>
l&#x27;ex√©cution du g√©n√©rateur, qui va alors jusqu&#x27;au premier <code>yield</code>, √©value
l&#x27;expression √©mise, la transmet en retour de <code>next()</code>, et remet la fonction en
pause. C&#x27;est au second <code>yield</code> seulement que l&#x27;ex√©cution reprend <strong>√† partir de
<code>yield 1</code></strong>. C&#x27;est une partie que je trouve contre-intuitive et que j&#x27;ai eu du
mal √† assimiler.</p>
<h3 id="dlgation"><a href="#dlgation" class="phenomic-HeadingAnchor">#</a>D√©l√©gation</h3>
<p>L&#x27;op√©rateur <code>yield*</code> permet d&#x27;√©mettre les valeurs d&#x27;un autre it√©rateur, par
exemple‚ÄØ:</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>Cela fonction bien s√ªr avec tous
<a href="/fr/articles/js/es2015/iterators/">les <em>it√©rables</em></a>¬†:
<code>yield * [1, 2, 3]</code> est valide par exemple.</p>
<h3 id="retour-anticip"><a href="#retour-anticip" class="phenomic-HeadingAnchor">#</a>Retour anticip√©</h3>
<p>Il est possible de terminer le traitement d&#x27;un g√©n√©rateur depuis le code
contr√¥leur avec la m√©thode <code>return</code> de l&#x27;it√©rateur. Tout se passera comme si
le g√©n√©rateur se terminait imm√©diatement avec la valeur de retour fournie.</p>
<pre><code class="hljs language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } ‚Üí yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Un habituel petit coup d&#x27;≈ìil sur <a href="https://kangax.github.io/compat-table/es6/#test-generators">la compatibilit√©</a>‚ÄØ:</p>
<ul>
<li>Les navigateurs modernes (donc pas IE)</li>
<li>IE Edge ‚â• 13</li>
<li>Niveau polyfill, c&#x27;est vers Babel ou Traceur qu&#x27;il faudra se tourner</li>
</ul>
<p>Les g√©n√©rateurs am√®nent tout un nouveau panel de fonctionnalit√©s qui permettent
d&#x27;inverser la responsabilit√©‚ÄØ: c&#x27;est le code appelant qui prend le pouvoir sur
la fa√ßon dont va s&#x27;ex√©cuter la fonction appel√©e. Ils repr√©sentent le premier pas
vers d&#x27;autres concepts qui bouleverseront probablement votre fa√ßon de coder dans
quelques mois/ann√©es‚ÄØ: fonctions asynchrones, observables‚Ä¶ prennent leurs
racines dans les g√©n√©rateurs. Les comprendre permettra de mieux appr√©hender de
futures fonctionnalit√©s.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Iteration protocol]]></title><description><![CDATA[<p>Imagine something so big, that if you remove it from the language, you will need
to remove lots of others features like spread operator, destructuring,
generators, for of...
This thing is just a protocol: the iterator protocol.</p>
<p>The principle is just a convention in the language which allow to standardise
how we can iterate on some data.</p>
<p>First good news, this protocol is pretty simple to understand and use 2
&quot;interfaces&quot; (quotes are just to warn you that we cannot really call that
<em>Interface</em>, since we don&#x27;t have this &quot;thing&quot; in JavaScript).</p>
<p>The first interface, <strong>Iterator</strong>, allow to an object to produce sequences of
values. An object is an iterator when it implements a <code>next()</code> function
which return an object that contains two properties¬†:</p>
<ul>
<li><code>value</code>: current value of the current execution</li>
<li><code>done</code> : a boolean that indicates whether the iteration is finished or not</li>
</ul>
<p>Successif calls of the <code>next()</code> method of an iterator will allow to get all
the value of an object.
Let&#x27;s see how we can iterate on a simple array <code>[&quot;a&quot;, &quot;b&quot;]</code>¬†:</p>
<pre><code class="hljs language-js">iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>So you will probably now ask &quot;How to get this Iterator?&quot;.
That&#x27;s the second interface,  <strong>Iterable</strong>.
An iterable object implements a particular method which is going to return an
iterator.
This method (called <em>@@iterator</em> in the spec) must be defined using the
Symbol <code>[Symbol.iterator]</code>.
(Symbol will be explained in a dedicated).</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iteratorArray = arr[<span class="hljs-built_in">Symbol</span>.iterator]()
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>Now you know how to use the array iterator implementation.
Not really useful right?
Here is another example to loop on an array following this protocol¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iterator = arr[<span class="hljs-built_in">Symbol</span>.iterator]()

<span class="hljs-keyword">const</span> result = iterator.next()
<span class="hljs-keyword">while</span> (!result.done) {
  <span class="hljs-built_in">console</span>.log(result.value)
  result = iterator.next()
}
<span class="hljs-comment">// 'a'</span>
<span class="hljs-comment">// 'b'</span></code></pre>
<p>Let&#x27;s recap: when an object which implements the iteration protocol is traversed
its <em>@@iterator</em> method is called once and the iterator is returned to be used
to loop an all values.</p>
<h1 id="iterable-consumers"><a href="#iterable-consumers" class="phenomic-HeadingAnchor">#</a>Iterable consumers</h1>
<p>Second good new is that a lots of concept of JavaScript benefits of this
protocol¬†:</p>
<ul>
<li>Some syntaxes expect to get iterables</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// for...of has been precisely made to loop on custom iterables</span>
<span class="hljs-keyword">for</span> (val <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(val)
}

<span class="hljs-comment">// spred operator will use it too</span>
[<span class="hljs-string">'0'</span>, ...arr, <span class="hljs-string">'1'</span>] <span class="hljs-comment">// 0, a, b, 1</span>

<span class="hljs-comment">// yield also needs an iterator</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">yield</span>* arr
}
gen().next() <span class="hljs-comment">// { value:"a", done:false }</span>

<span class="hljs-comment">// same for destructuring</span>
<span class="hljs-keyword">const</span> [x, y] = arr <span class="hljs-comment">// x = 'a',  y = "b"</span></code></pre>
<ul>
<li>Some APIs acccepts iterables</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// Set and Weakset accepts iterables</span>
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)
set.has(<span class="hljs-string">"b"</span>) <span class="hljs-comment">// true</span>
<span class="hljs-comment">// same for Map and WeakMap</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr.entries()) <span class="hljs-comment">// Not that a (weak)map needs a [key, value] combo</span>
map.get(<span class="hljs-number">0</span>) <span class="hljs-comment">// 'a'</span>


<span class="hljs-comment">// MOAR APIs</span>

<span class="hljs-built_in">Array</span>.from(iterable) <span class="hljs-comment">// tunr anything into an array !</span>
<span class="hljs-built_in">Promise</span>.all(iterableCollectionDePromises) <span class="hljs-comment">// any iterable that will contains a set of Promises</span>
<span class="hljs-built_in">Promise</span>.race(iterableCollectionDePromises) <span class="hljs-comment">// same</span></code></pre>
<h1 id="built-in-iterable"><a href="#built-in-iterable" class="phenomic-HeadingAnchor">#</a>Built-in Iterable</h1>
<p>Third good news: a lot&#x27;s of objects already implement this protocol¬†:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// obviously, arrays</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"l"</span>]
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> arr) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// strings too</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">"lol"</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> str) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// Map and Set (BUT NOT WeakMap and WeakSet)</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">'l'</span>, <span class="hljs-number">1</span>).set(<span class="hljs-string">'o'</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// ["l", 1]</span>
  <span class="hljs-comment">// ["o", 2]</span>
}
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>().add(<span class="hljs-string">'l'</span>).add(<span class="hljs-string">'o'</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
}

<span class="hljs-comment">// TypedArray that you use EVERY SINGLE DAYS</span>
<span class="hljs-keyword">const</span> int16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(<span class="hljs-number">2</span>)
int16[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> int16) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 42</span>
  <span class="hljs-comment">// 0</span>
}

<span class="hljs-comment">// Even the special `argument` object</span>
<span class="hljs-comment">// (that you will probably stop to use in es6, thanks to spread operator)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
    <span class="hljs-built_in">console</span>.log(v)
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
    <span class="hljs-comment">// 'l'</span>
  }
}
test(<span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'l'</span>)

<span class="hljs-comment">// NodeList returned by DOM APIs</span>
<span class="hljs-keyword">const</span> matches = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>)
<span class="hljs-keyword">for</span> (m <span class="hljs-keyword">of</span> matches) {
  <span class="hljs-built_in">console</span>.log(m)
  <span class="hljs-comment">// &lt;div id="topSection"&gt;</span>
  <span class="hljs-comment">// &lt;div id="brandLogo"&gt;</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Another detail: Array, TypedArray, Map, Set are iterables but also define
methods which also return iterables (...Are you still with us ?)¬†:</p>
<ul>
<li>entries() returns a set of key/values</li>
<li>keys() returns keys</li>
<li>values() returns values</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">for</span> (cleVals <span class="hljs-keyword">of</span> arr.entries()) {
  <span class="hljs-built_in">console</span>.log(cleVals)
  <span class="hljs-comment">// [0, "l"]</span>
  <span class="hljs-comment">// [1, "o"]</span>
  <span class="hljs-comment">// [2, "l"]</span>
}</code></pre>
<p>Important note: <code>Object</code> is not an iterable (but we might get in ES2016
entries(), keys() and values() on <code>Object</code>
(<a href="https://github.com/tc39/proposal-object-values-entries">spec proposal</a>).</p>
<h1 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h1>
<p>We have seen that a lots of interesting syntaxes and features use the iterable
protocol, so we hope that you will use all of that in your libraries.
That&#x27;s important to rely on commons patterns so we can reach an agreement.</p>
<p>Libraries can do that by¬†:</p>
<ul>
<li>offering data that implements this protocol</li>
<li>use this protocol directly (eg: for a sorting algorithm)</li>
</ul>
<h1 id="one-last-thing"><a href="#one-last-thing" class="phenomic-HeadingAnchor">#</a>One last thing...</h1>
<p>The following post will allow you to deep dive into this subject¬†:</p>
<ul>
<li><a href="http://www.2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocols</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 in depth : iterators and the for of loop</a></li>
<li><a href="https://ponyfoo.com/articles/es6-iterators-in-depth">ES6 iterators in depth</a></li>
</ul>
<p>The practice remains the best way to train yourself, so take a look to
<a href="http://es6katas.org/">ES6 Katas</a> which has been made for that.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/iterators/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/iterators/</guid><pubDate>Wed, 09 Dec 2015 00:00:00 GMT</pubDate></item></channel></rss>